==================== Ğ¡Ğ¢Ğ Ğ£ĞšĞ¢Ğ£Ğ Ğ ĞŸĞ ĞĞ•ĞšĞ¢Ğ ====================

Mihi donor bot/
â”œâ”€â”€ alembic/
â”‚   â”œâ”€â”€ README
â”‚   â”œâ”€â”€ env.py
â”‚   â””â”€â”€ script.py.mako
â”œâ”€â”€ bot/
â”‚   â”œâ”€â”€ db/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ admin_requests.py
â”‚   â”‚   â”œâ”€â”€ analytics_requests.py
â”‚   â”‚   â”œâ”€â”€ engine.py
â”‚   â”‚   â”œâ”€â”€ event_requests.py
â”‚   â”‚   â”œâ”€â”€ info_requests.py
â”‚   â”‚   â”œâ”€â”€ merch_requests.py
â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”œâ”€â”€ qa_management.py
â”‚   â”‚   â”œâ”€â”€ question_requests.py
â”‚   â”‚   â””â”€â”€ user_requests.py
â”‚   â”œâ”€â”€ filters/
â”‚   â”‚   â””â”€â”€ role.py
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â”œâ”€â”€ admin/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ analytics.py
â”‚   â”‚   â”‚   â”œâ”€â”€ event_management.py
â”‚   â”‚   â”‚   â”œâ”€â”€ info_management.py
â”‚   â”‚   â”‚   â”œâ”€â”€ mailing.py
â”‚   â”‚   â”‚   â”œâ”€â”€ merch_management.py
â”‚   â”‚   â”‚   â”œâ”€â”€ qa_management.py
â”‚   â”‚   â”‚   â”œâ”€â”€ system.py
â”‚   â”‚   â”‚   â””â”€â”€ user_management.py
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ common.py
â”‚   â”‚   â”œâ”€â”€ main_admin.py
â”‚   â”‚   â”œâ”€â”€ other.py
â”‚   â”‚   â”œâ”€â”€ student.py
â”‚   â”‚   â””â”€â”€ volunteer.py
â”‚   â”œâ”€â”€ keyboards/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ inline.py
â”‚   â”‚   â””â”€â”€ reply.py
â”‚   â”œâ”€â”€ middlewares/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ block.py
â”‚   â”‚   â””â”€â”€ db.py
â”‚   â”œâ”€â”€ states/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ states.py
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ analytics_service.py
â”‚   â”‚   â”œâ”€â”€ calendar_service.py
â”‚   â”‚   â”œâ”€â”€ data_import.py
â”‚   â”‚   â”œâ”€â”€ graduation.py
â”‚   â”‚   â”œâ”€â”€ qr_service.py
â”‚   â”‚   â”œâ”€â”€ scheduler.py
â”‚   â”‚   â””â”€â”€ text_messages.py
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ config_reader.py
â”œâ”€â”€ donor_bot_telegram.egg-info/
â”‚   â”œâ”€â”€ PKG-INFO
â”‚   â”œâ”€â”€ SOURCES.txt
â”‚   â”œâ”€â”€ dependency_links.txt
â”‚   â””â”€â”€ top_level.txt
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py
â”‚   â”œâ”€â”€ test_admin_fsm.py
â”‚   â”œâ”€â”€ test_analytics.py
â”‚   â”œâ”€â”€ test_api.py
â”‚   â”œâ”€â”€ test_calendar_service.py
â”‚   â”œâ”€â”€ test_data_io.py
â”‚   â”œâ”€â”€ test_db_requests.py
â”‚   â”œâ”€â”€ test_filters.py
â”‚   â”œâ”€â”€ test_fsm_unhappy_paths.py
â”‚   â”œâ”€â”€ test_graduation.py
â”‚   â”œâ”€â”€ test_handlers_logic.py
â”‚   â”œâ”€â”€ test_keyboards.py
â”‚   â”œâ”€â”€ test_mailing_logic.py
â”‚   â”œâ”€â”€ test_middlewares.py
â”‚   â”œâ”€â”€ test_registration_logic.py
â”‚   â”œâ”€â”€ test_scheduler_config.py
â”‚   â”œâ”€â”€ test_scheduler_logic.py
â”‚   â”œâ”€â”€ test_security.py
â”‚   â”œâ”€â”€ test_survey_logic.py
â”‚   â”œâ”€â”€ test_utils.py
â”‚   â””â”€â”€ test_volunteer_fsm.py
â”œâ”€â”€ webapp/
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ .env
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ README.md
â”œâ”€â”€ alembic.ini
â”œâ”€â”€ collector_faker.py
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ main.py
â”œâ”€â”€ populate_db.py
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ pytest.ini
â”œâ”€â”€ requirements-dev.txt
â””â”€â”€ requirements.txt

==================== Ğ¡ĞĞ”Ğ•Ğ Ğ–Ğ˜ĞœĞĞ• Ğ¤ĞĞ™Ğ›ĞĞ’ ====================

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: .env ---

BOT_TOKEN=8140767983:AAEjtVpc8avWtV86wfpRfW2O9l8SYzbswhM
SUPER_ADMIN_ID=1031233699

NGROK_AUTHTOKEN=1qZfvDIREz2QtiVo9UL6yNY8v0B_5N2XU9ZjX2DoXpPe8tUae

DB_HOST=db
DB_PORT=5432
DB_NAME=donor_bot_db
DB_USER=donor_user
DB_PASS=strong123321
QR_SECRET_KEY=a_very_secret_key_for_hashing_qr_codes_!@#$

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: .env ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: .gitignore ---

__pycache__/ 
*.py[cod] 
*$py.class 
venv/ 
.venv/ 
.env 
.idea/ 
.vscode/ 
*.pyc
db_volume/

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: .gitignore ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: Dockerfile ---

FROM python:3.11-slim
RUN apt-get update && apt-get install -y libzbar0 && rm -rf /var/lib/apt/lists/*
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
CMD ["python", "main.py"]

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: Dockerfile ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: README.md ---

ĞŸÑ€Ğ¾ĞµĞºÑ‚ "Ğ”Ğ¾Ğ½Ğ¾Ñ€-Ğ±Ğ¾Ñ‚ ĞœĞ˜Ğ¤Ğ˜"
ĞšÑ€Ğ°Ñ‚ĞºĞ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ

Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ» .env Ğ¸ Ğ·Ğ°Ğ¿Ğ¾Ğ¼Ğ½Ğ¸Ñ‚ÑŒ ĞµĞ³Ğ¾ Ğ¿Ğ¾ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ñƒ .env.example

Ğ­Ñ‚Ğ¾Ñ‚ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚ Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ±Ğ¾Ğ¹ Telegram-Ğ±Ğ¾Ñ‚Ğ°, Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑĞºĞ¾Ğ³Ğ¾ Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜. Ğ‘Ğ¾Ñ‚ ÑĞ»ÑƒĞ¶Ğ¸Ñ‚ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ¼ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ¸Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ° Ğ”Ğ½Ğ¸ Ğ”Ğ¾Ğ½Ğ¾Ñ€Ğ° (Ğ”Ğ”) Ğ¸ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ².
ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»:

    Ğ”Ğ»Ñ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²:
        Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¸ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ğ½Ğ¾Ğ¼ĞµÑ€Ñƒ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°.
        ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ»Ğ¸Ñ‡Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸: Ğ¤Ğ˜Ğ, ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹, Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹.
        Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ½Ğ° Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğ¹ Ğ”ĞµĞ½ÑŒ Ğ”Ğ¾Ğ½Ğ¾Ñ€Ğ°.
        Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑÑ‚Ğ²Ğµ ĞºÑ€Ğ¾Ğ²Ğ¸ Ğ¸ ĞºĞ¾ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ·Ğ³Ğ°.
        Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ·Ğ°Ğ´Ğ°Ñ‚ÑŒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼.
    Ğ”Ğ»Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²:
        Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ğ¾Ğ¹ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ².
        Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸ÑĞ¼Ğ¸ (Ğ”Ğ½ÑĞ¼Ğ¸ Ğ”Ğ¾Ğ½Ğ¾Ñ€Ğ°).
        Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ¿Ğ¾ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¼ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ².
        ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ¿Ğ¾ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑĞºĞ¸Ğ¼ Ğ°ĞºÑ†Ğ¸ÑĞ¼.
        ĞÑ‚Ğ²ĞµÑ‚Ñ‹ Ğ½Ğ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹.

Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°

    bot/: ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ¿Ğ°Ğ¿ĞºĞ° Ñ ĞºĞ¾Ğ´Ğ¾Ğ¼ Ğ±Ğ¾Ñ‚Ğ°.
        db/: ĞœĞ¾Ğ´ÑƒĞ»Ğ¸ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ±Ğ°Ğ·Ğ¾Ğ¹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… (Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸, Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹).
        handlers/: ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹, ĞºĞ¾Ğ»Ğ±ÑĞºĞ¾Ğ², Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ Ñ€Ğ¾Ğ»ÑĞ¼ (Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€, ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚, Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€).
        keyboards/: ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ñ Ğ±Ğ¾Ñ‚Ğ¾Ğ¼.
        middlewares/: ĞŸÑ€Ğ¾Ğ¼ĞµĞ¶ÑƒÑ‚Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸.
        states/: Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ FSM.
        utils/: Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ÑƒÑ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹ (Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº, QR-ĞºĞ¾Ğ´Ñ‹ Ğ¸ Ñ‚.Ğ´.).
    tests/: Ğ¢ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ¾ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸ ĞºĞ¾Ğ´Ğ°.
    webapp/: Ğ¤Ğ°Ğ¹Ğ»Ñ‹ Ğ´Ğ»Ñ Telegram Web App.
    main.py: Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ²Ñ…Ğ¾Ğ´Ğ° Ğ² Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ.
    docker-compose.yml: Ğ¤Ğ°Ğ¹Ğ» Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ Docker.
    requirements.txt: Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°.
    ĞŸÑ€ĞµĞ·ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ.pptx: ĞŸÑ€ĞµĞ·ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° Ğ´Ğ»Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ñ‹.

ĞšĞ°Ğº Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚

Ğ”Ğ»Ñ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Docker Ğ¸ Docker Compose.

    ĞšĞ»Ğ¾Ğ½Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹:

    git clone https://github.com/sasha2004-art/donor-bot-telegram
    cd <Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ_Ğ¿Ğ°Ğ¿ĞºĞ¸_Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°>

    Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¸ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚Ğµ Ñ„Ğ°Ğ¹Ğ» .env Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ .env.example. Ğ’Ğ½ĞµÑĞ¸Ñ‚Ğµ Ñ‚ÑƒĞ´Ğ° Ñ‚Ğ¾ĞºĞµĞ½ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ±Ğ¾Ñ‚Ğ° Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ.

    Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚ Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ Docker Compose:

    docker-compose up --build

    ĞŸĞ¾ÑĞ»Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ğ±Ğ¾Ñ‚ Ğ±ÑƒĞ´ĞµÑ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ.

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: README.md ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: alembic.ini ---

# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = postgresql+asyncpg://test:test@localhost/test


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: alembic.ini ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: collector_faker.py ---

import asyncio
import datetime
import random
import logging
from faker import Faker
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy import select, func

# Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ‘Ğ”
import os
from dotenv import load_dotenv

load_dotenv()

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸ Ğ¸ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ· Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
try:
    from bot.db.models import (
        Base, User, Event, EventRegistration, Donation, MedicalWaiver,
        Survey, BloodCenter
    )
    from bot.config_reader import config
except ImportError as e:
    print(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ°: {e}")
    print("Ğ£Ğ±ĞµĞ´Ğ¸Ñ‚ĞµÑÑŒ, Ñ‡Ñ‚Ğ¾ ÑĞºÑ€Ğ¸Ğ¿Ñ‚ 'collector_faker.py' Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ² ĞºĞ¾Ñ€Ğ½ĞµĞ²Ğ¾Ğ¹ Ğ¿Ğ°Ğ¿ĞºĞµ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°.")
    exit()

# ĞŸĞ•Ğ Ğ•ĞĞŸĞ Ğ•Ğ”Ğ•Ğ›Ğ¯Ğ•Ğœ Ğ¥ĞĞ¡Ğ¢ Ğ‘Ğ” Ğ¡ĞŸĞ•Ğ¦Ğ˜ĞĞ›Ğ¬ĞĞ Ğ”Ğ›Ğ¯ Ğ­Ğ¢ĞĞ“Ğ Ğ¡ĞšĞ Ğ˜ĞŸĞ¢Ğ
config.db_host = "localhost"

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# --- ĞšĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ---
NEW_USER_COUNT = 300
# Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ÑĞµĞ³Ğ¼ĞµĞ½Ñ‚Ğ°Ğ¼ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸
CHURN_DONOR_COUNT = 30
LAPSED_DONOR_COUNT = 40
DKM_CANDIDATE_COUNT = 50
ACTIVE_DONOR_COUNT = 100
SURVEY_DROPOFF_COUNT = 20
# ĞÑÑ‚Ğ°Ğ²ÑˆĞ¸ĞµÑÑ 60 Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ½ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼Ğ¸

PAST_EVENTS_TO_CREATE = 10

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ Faker Ğ´Ğ»Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ€ÑƒÑÑĞºĞ¾ÑĞ·Ñ‹Ñ‡Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
faker = Faker('ru_RU')

# --- ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ñ Ğ‘Ğ” (Ğ°Ğ½Ğ°Ğ»Ğ¾Ğ³Ğ¸Ñ‡Ğ½Ğ¾ Ğ²Ğ°ÑˆĞµĞ¼Ñƒ engine.py) ---
engine = create_async_engine(
    url=config.database_url,
    echo=False
)
async_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

# --- Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ---
UNIVERSITIES = ["ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜"] * 8 + ["Ğ”Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ’Ğ£Ğ—"] * 2
FACULTIES_MIFI = ["Ğ˜Ğ˜ĞšĞ¡", "Ğ¤Ğ˜Ğ‘Ğ¡", "Ğ˜Ğ¤Ğ¢Ğ­Ğ‘", "Ğ˜Ğ¤Ğ˜Ğ‘", "Ğ°", "Ğ˜Ğ½Ğ¯Ğ·", "Ğ˜ĞŸĞ¢Ğ˜Ğ¡"]
GENDERS = ["male", "female"]
DONATION_TYPES = ['whole_blood', 'plasma', 'platelets']


async def get_max_ids(session: AsyncSession) -> tuple[int, int]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ telegram_id Ğ¸ Ğ¾Ğ±Ñ‰ĞµĞµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ğ½Ğ¸Ñ ĞºĞ¾Ğ»Ğ»Ğ¸Ğ·Ğ¸Ğ¹."""
    max_tg_id_res = await session.execute(select(func.max(User.telegram_id)))
    max_tg_id = max_tg_id_res.scalar_one_or_none() or 1000000000

    count_users_res = await session.execute(select(func.count(User.id)))
    count_users = count_users_res.scalar_one() or 0
    
    return max_tg_id, count_users


async def create_new_users(session: AsyncSession) -> list[User]:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ 300 Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹, Ğ½Ğµ Ğ·Ğ°Ñ‚Ñ€Ğ°Ğ³Ğ¸Ğ²Ğ°Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ñ…."""
    logger.info(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ {NEW_USER_COUNT} Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹...")
    users_to_create = []

    max_tg_id, user_count_base = await get_max_ids(session)
    
    for i in range(NEW_USER_COUNT):
        gender = random.choice(GENDERS)
        university = random.choice(UNIVERSITIES)
        faculty = random.choice(FACULTIES_MIFI) if university == "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜" else "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
        
        user = User(
            phone_number=f"+79{random.randint(100, 999):03d}{user_count_base + i:07d}",
            telegram_id=max_tg_id + i + 1,
            telegram_username=faker.user_name() + str(i),
            full_name=faker.name_male() if gender == 'male' else faker.name_female(),
            university=university,
            faculty=faculty,
            study_group=f"{random.choice(['Ğ‘', 'Ğœ'])}{random.randint(20, 24)}-{random.randint(101, 515)}",
            gender=gender,
            points=0,
            role='student',
            is_blocked=False,
            created_at=faker.date_time_between(start_date='-1y', end_date='now'),
            is_dkm_donor=False,
            consent_given=True,
            graduation_year=datetime.date.today().year + random.randint(0, 4)
        )
        users_to_create.append(user)
        
    session.add_all(users_to_create)
    await session.commit()
    
    logger.info(f"{len(users_to_create)} Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¾.")
    return users_to_create


async def create_past_events(session: AsyncSession, blood_centers: list[BloodCenter]) -> list[Event]:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞ¸Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ, Ğº ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¼ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¿Ñ€Ğ¸Ğ²ÑĞ·Ğ°Ğ½Ñ‹ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹."""
    logger.info(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ {PAST_EVENTS_TO_CREATE} Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞ¸Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹...")
    if not blood_centers:
        raise ValueError("ĞĞµÑ‚ Ñ†ĞµĞ½Ñ‚Ñ€Ğ¾Ğ² ĞºÑ€Ğ¾Ğ²Ğ¸ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ²ÑĞ·ĞºĞ¸ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹.")

    events_to_create = []
    today = datetime.datetime.now()

    for i in range(PAST_EVENTS_TO_CREATE):
        event_date = today - datetime.timedelta(days=random.randint(30, 500))
        center = random.choice(blood_centers)
        
        event = Event(
            name=f"ĞÑ€Ñ…Ğ¸Ğ²Ğ½Ğ°Ñ Ğ°ĞºÑ†Ğ¸Ñ (faker) â„–{i+1}",
            event_datetime=event_date,
            location=f"ĞœĞµÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ñ Ğ°Ñ€Ñ…Ğ¸Ğ²Ğ½Ğ¾Ğ¹ Ğ°ĞºÑ†Ğ¸Ğ¸ â„–{i+1}",
            blood_center_id=center.id,
            donation_type=random.choice(DONATION_TYPES),
            points_per_donation=random.randint(100, 200),
            participant_limit=random.randint(40, 80),
            is_active=False,
            registration_is_open=False
        )
        events_to_create.append(event)
    
    session.add_all(events_to_create)
    await session.commit()
    logger.info(f"{len(events_to_create)} Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞ¸Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¾.")
    return events_to_create


async def create_history_for_new_users(session: AsyncSession, new_users: list[User], past_events: list[Event]):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹, Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ² Ğ¸ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ¾Ğ² Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… ÑĞµĞ³Ğ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹."""
    logger.info("Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹ Ğ´Ğ»Ñ ÑĞµĞ³Ğ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹...")
    
    if not new_users or not past_events:
        logger.warning("ĞĞµÑ‚ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ¸Ğ»Ğ¸ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸.")
        return

    random.shuffle(new_users)
    
    # Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ¿Ğ¾ ÑĞµĞ³Ğ¼ĞµĞ½Ñ‚Ğ°Ğ¼
    segments = {
        "churn": new_users[:CHURN_DONOR_COUNT],
        "lapsed": new_users[CHURN_DONOR_COUNT : CHURN_DONOR_COUNT + LAPSED_DONOR_COUNT],
        "dkm_candidates": new_users[CHURN_DONOR_COUNT + LAPSED_DONOR_COUNT : - (ACTIVE_DONOR_COUNT + SURVEY_DROPOFF_COUNT)],
        "active": new_users[-(ACTIVE_DONOR_COUNT + SURVEY_DROPOFF_COUNT) : -SURVEY_DROPOFF_COUNT],
        "survey_dropoff": new_users[-SURVEY_DROPOFF_COUNT:]
    }

    donations_to_add, waivers_to_add, surveys_to_add = [], [], []
    user_updates = {}
    
    def create_donation_entry(user, event, donation_date):
        points = event.points_per_donation
        donations_to_add.append(Donation(
            user_id=user.id, event_id=event.id, donation_date=donation_date,
            donation_type=event.donation_type, points_awarded=points
        ))
        
        days_waiver = (90 if user.gender == 'female' else 60) if event.donation_type == 'whole_blood' else 14
        end_date = donation_date + datetime.timedelta(days=days_waiver)
        waivers_to_add.append(MedicalWaiver(
            user_id=user.id, start_date=donation_date, end_date=end_date,
            reason=f"Ğ¡Ğ´Ğ°Ñ‡Ğ° Â«{event.donation_type}Â»", created_by='system'
        ))
        user_updates[user.id] = user_updates.get(user.id, 0) + points

    # 1. "ĞĞ´Ğ½Ğ¾Ğ´Ğ½ĞµĞ²ĞºĞ¸": 1 Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ > 6 Ğ¼ĞµÑÑÑ†ĞµĞ² Ğ½Ğ°Ğ·Ğ°Ğ´
    logger.info(f"ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° {len(segments['churn'])} Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²-Ğ¾Ğ´Ğ½Ğ¾Ğ´Ğ½ĞµĞ²Ğ¾Ğº...")
    for user in segments['churn']:
        event = random.choice(past_events)
        donation_date = datetime.date.today() - datetime.timedelta(days=random.randint(185, 300))
        create_donation_entry(user, event, donation_date)

    # 2. "Ğ£Ğ³Ğ°ÑĞ°ÑÑ‰Ğ¸Ğµ": 2+ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸, Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ > 9 Ğ¼ĞµÑÑÑ†ĞµĞ² Ğ½Ğ°Ğ·Ğ°Ğ´
    logger.info(f"ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° {len(segments['lapsed'])} ÑƒĞ³Ğ°ÑĞ°ÑÑ‰Ğ¸Ñ… Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²...")
    for user in segments['lapsed']:
        num_donations = random.randint(2, 4)
        last_date = datetime.date.today() - datetime.timedelta(days=random.randint(275, 400))
        for i in range(num_donations):
            create_donation_entry(user, random.choice(past_events), last_date - datetime.timedelta(days=i*90))

    # 3. "ĞšĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚Ñ‹ Ğ² Ğ”ĞšĞœ": 2+ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸, is_dkm_donor=False
    logger.info(f"ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° {len(segments['dkm_candidates'])} ĞºĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ğ² Ğ² Ğ”ĞšĞœ...")
    for user in segments['dkm_candidates']:
        for _ in range(random.randint(2, 5)):
            create_donation_entry(user, random.choice(past_events), datetime.date.today() - datetime.timedelta(days=random.randint(30, 365)))

    # 4. "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ": 1+ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹, Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ < 3 Ğ¼ĞµÑÑÑ†ĞµĞ² Ğ½Ğ°Ğ·Ğ°Ğ´
    logger.info(f"ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° {len(segments['active'])} Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²...")
    for user in segments['active']:
        for i in range(random.randint(1, 6)):
            create_donation_entry(user, random.choice(past_events), datetime.date.today() - datetime.timedelta(days=random.randint(15, 90) * (i + 1)))
        if random.random() < 0.3:
            user.is_dkm_donor = True

    # 5. "ĞŸĞ¾Ñ‚ĞµÑ€ÑĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ°": ĞŸÑ€Ğ¾ÑˆĞ»Ğ¸ Ğ¾Ğ¿Ñ€Ğ¾Ñ, Ğ½Ğ¾ Ğ½Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ»Ğ¸ÑÑŒ
    logger.info(f"ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° {len(segments['survey_dropoff'])} 'Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ½Ğ½Ñ‹Ñ…' Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹...")
    for user in segments['survey_dropoff']:
        surveys_to_add.append(Survey(
            user_id=user.id, passed=True, verdict_text="ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹ Ğ½Ğµ Ğ²Ñ‹ÑĞ²Ğ»ĞµĞ½Ğ¾.",
            created_at=datetime.datetime.now() - datetime.timedelta(days=random.randint(1, 20))
        ))

    session.add_all(donations_to_add + waivers_to_add + surveys_to_add)
    
    logger.info(f"ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ² Ğ´Ğ»Ñ {len(user_updates)} Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹...")
    for user_id, points in user_updates.items():
        user = await session.get(User, user_id)
        if user:
            user.points += points
            
    await session.commit()
    logger.info("Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°.")


async def main():
    """Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ²ÑĞµÑ… ÑÑ‚Ğ°Ğ¿Ğ¾Ğ² Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…."""
    logger.info("Ğ—Ğ°Ğ¿ÑƒÑĞº ÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ° Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµĞ¹ĞºĞ¾Ğ²Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
    async with async_session_maker() as session:
        
        logger.info("ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
        
        existing_centers_res = await session.execute(select(BloodCenter))
        existing_centers = existing_centers_res.scalars().all()
        if not existing_centers:
            logger.warning("Ğ¦ĞµĞ½Ñ‚Ñ€Ñ‹ ĞºÑ€Ğ¾Ğ²Ğ¸ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ Ğ´ĞµÑ„Ğ¾Ğ»Ñ‚Ğ½Ñ‹Ğµ.")
            centers = [BloodCenter(name="Ğ¦ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸ Ğ¤ĞœĞ‘Ğ Ğ Ğ¾ÑÑĞ¸Ğ¸"), BloodCenter(name="Ğ¦ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸ Ğ¸Ğ¼. Ğ.Ğš. Ğ“Ğ°Ğ²Ñ€Ğ¸Ğ»Ğ¾Ğ²Ğ°")]
            session.add_all(centers)
            await session.commit()
            existing_centers = centers

        new_users = await create_new_users(session)
        past_events = await create_past_events(session, existing_centers)
        await create_history_for_new_users(session, new_users, past_events)

    logger.info("ğŸ‰ Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! Ğ¤ĞµĞ¹ĞºĞ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ±Ñ‹Ğ»Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ Ğ² Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….")


if __name__ == "__main__":
    asyncio.run(main())

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: collector_faker.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15-alpine
    container_name: donor_db_container
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
    volumes:
      - db_volume:/var/lib/postgresql/data
    ports:
      - "5432:5432" 
    restart: always
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
      interval: 10s
      timeout: 5s
      retries: 5

  bot:
    build: .
    container_name: donor_bot_container
    env_file: .env
    depends_on:
      - db
    restart: always
    volumes:
      - .:/app
    expose:
      - "8000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"] 
      interval: 1m
      timeout: 10s
      retries: 3

  ngrok:
    image: ngrok/ngrok:latest
    container_name: donor_ngrok_container
    restart: always
    depends_on:
      - bot 
    environment:
      NGROK_AUTHTOKEN: ${NGROK_AUTHTOKEN}
    command: http bot:8000 --log=stdout
    ports:
      - "4040:4040"
  redis:
    image: redis:7-alpine
    container_name: donor_redis_container
    restart: always
    volumes:
      - redis_volume:/data

volumes:
  db_volume:
  redis_volume:

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: docker-compose.yml ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: main.py ---

import asyncio
import logging
import uvicorn
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, ValidationError
import json
import hmac
import hashlib
from urllib.parse import unquote, parse_qs
import datetime
import aiohttp
import time


import redis.asyncio as redis
from aiogram import Bot, Dispatcher, types
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.client.default import DefaultBotProperties
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.storage.redis import RedisStorage
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from bot.middlewares.block import BlockUserMiddleware
from bot.middlewares.db import DbSessionMiddleware
from bot.config_reader import config
from bot.db.engine import create_db_and_tables, async_session_maker
from bot.db import admin_requests, user_requests, event_requests
from bot.db.models import Survey, UserBlock, InfoText   
from bot.utils.scheduler import setup_scheduler
from bot.handlers import common, student, volunteer, other
from bot.handlers.admin import admin_router
from bot.handlers.student import feedback_router
from bot.utils.text_messages import Text




logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(name)s - %(message)s")
logger = logging.getLogger(__name__)


redis_client = redis.Redis(host='redis', port=6379, db=0) # host='redis' - Ğ¸Ğ¼Ñ ÑĞµÑ€Ğ²Ğ¸ÑĞ° Ğ¸Ğ· docker-compose
storage = RedisStorage(redis=redis_client)
bot = Bot(token=config.bot_token.get_secret_value(), default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher(storage=storage)



class SurveyAnswers(BaseModel):
    # ĞĞ±Ñ‰Ğ¸Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹
    age: str
    weight: str
    health_issues_last_month: str

    # ĞĞ¾Ğ²Ñ‹Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¸Ğ· Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹
    symptoms: str # ĞĞ Ğ’Ğ˜, Ğ°Ğ½Ğ³Ğ¸Ğ½Ğ°, Ğ³Ñ€Ğ¸Ğ¿Ğ¿
    pressure: str
    hemoglobin_level: str

    # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğº Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸
    diet_followed: str
    alcohol_last_48h: str
    medication_last_72h: str
    sleep_last_night: str
    smoking_last_hour: str

    # ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ
    tattoo_or_piercing: str
    tooth_removal_last_10_days: str
    antibiotics_last_2_weeks: str
    analgesics_last_3_days: str

    # ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ
    has_hiv_or_hepatitis: str
    has_cancer_or_blood_disease: str
    has_chronic_disease: str

class SurveyPayload(BaseModel):
    survey_data: SurveyAnswers
    auth_string: str

def validate_telegram_data(auth_data: str) -> dict:
    """
    ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ ÑÑ‚Ñ€Ğ¾ĞºÑƒ initData, Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ½ÑƒÑ Ğ¾Ñ‚ Telegram Web App.
    """
    bot_token = config.bot_token.get_secret_value()
    if not auth_data:
        raise HTTPException(status_code=403, detail="auth_data is empty.")
    try:
        parsed_data = parse_qs(auth_data)
        received_hash = parsed_data.pop('hash', [None])[0]
        if not received_hash:
            raise ValueError("Hash not found in auth data")
        data_check_string = "\n".join(
            f"{key}={value[0]}" for key, value in sorted(parsed_data.items())
        )
        secret_key = hmac.new("WebAppData".encode(), bot_token.encode(), hashlib.sha256).digest()
        calculated_hash = hmac.new(secret_key, data_check_string.encode(), hashlib.sha256).hexdigest()
        if calculated_hash != received_hash:
            raise ValueError("Invalid hash")
        user_data_str = parsed_data.get('user', [None])[0]
        if not user_data_str:
            raise ValueError("User data not found")
        return json.loads(user_data_str)
    except Exception as e:
        logger.error(f"Telegram WebApp data validation failed: {e}. Raw auth_data: '{auth_data}'")
        raise HTTPException(status_code=403, detail=str(e))

async def process_survey_rules(answers: SurveyAnswers, user_gender: str) -> tuple[str, int | None, str]:
    # ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ
    if answers.age == 'no':
        return ('temp_waiver', 365000, "Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ¼ĞµĞ½ĞµĞµ 18 Ğ»ĞµÑ‚.")
    if answers.has_hiv_or_hepatitis == 'yes' or answers.has_cancer_or_blood_disease == 'yes' or answers.has_chronic_disease == 'yes':
        return ('temp_waiver', 365000, "ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ (Ğ’Ğ˜Ğ§, Ğ³ĞµĞ¿Ğ°Ñ‚Ğ¸Ñ‚, Ğ¾Ğ½ĞºĞ¾Ğ»Ğ¾Ğ³Ğ¸Ñ, Ğ±Ğ¾Ğ»ĞµĞ·Ğ½Ğ¸ ĞºÑ€Ğ¾Ğ²Ğ¸, Ğ°ÑÑ‚Ğ¼Ğ°).")

    # Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ
    if answers.weight == 'no':
        return ('temp_waiver', 365000, "Ğ’ĞµÑ Ğ¼ĞµĞ½ĞµĞµ 50 ĞºĞ³.")
    if answers.health_issues_last_month == 'yes' or answers.symptoms == 'yes':
        return ('temp_waiver', 30, "ĞĞ Ğ’Ğ˜, Ğ³Ñ€Ğ¸Ğ¿Ğ¿ Ğ¸Ğ»Ğ¸ Ğ°Ğ½Ğ³Ğ¸Ğ½Ğ° Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ¼ĞµÑÑÑ†Ğ°.")
    if answers.tooth_removal_last_10_days == 'yes':
        return ('temp_waiver', 10, "Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ·ÑƒĞ±Ğ° Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 10 Ğ´Ğ½ĞµĞ¹.")
    if answers.tattoo_or_piercing == 'yes':
        return ('temp_waiver', 120, "ĞĞ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ÑĞ²ĞµĞ¶ĞµĞ¹ Ñ‚Ğ°Ñ‚ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸/Ğ¿Ğ¸Ñ€ÑĞ¸Ğ½Ğ³Ğ° (Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ½Ğ° 4 Ğ¼ĞµÑÑÑ†Ğ°).")
    if answers.antibiotics_last_2_weeks == 'yes':
        return ('temp_waiver', 14, "ĞŸÑ€Ğ¸ĞµĞ¼ Ğ°Ğ½Ñ‚Ğ¸Ğ±Ğ¸Ğ¾Ñ‚Ğ¸ĞºĞ¾Ğ² Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 2 Ğ½ĞµĞ´ĞµĞ»Ğ¸.")
    if answers.analgesics_last_3_days == 'yes' or answers.medication_last_72h == 'yes':
        return ('temp_waiver', 3, "ĞŸÑ€Ğ¸ĞµĞ¼ Ğ°Ğ½Ğ°Ğ»ÑŒĞ³ĞµÑ‚Ğ¸ĞºĞ¾Ğ² Ğ¸Ğ»Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ»ĞµĞºĞ°Ñ€ÑÑ‚Ğ² Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 3 Ğ´Ğ½Ñ.")

    # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğº Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸
    if answers.alcohol_last_48h == 'yes':
        return ('temp_waiver', 2, "Ğ£Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ»ĞµĞ½Ğ¸Ğµ Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»Ñ Ğ·Ğ° Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 48 Ñ‡Ğ°ÑĞ¾Ğ².")
    if answers.diet_followed == 'no':
        return ('ok', 0, "ĞĞµÑĞ¾Ğ±Ğ»ÑĞ´ĞµĞ½Ğ¸Ğµ Ğ´Ğ¸ĞµÑ‚Ñ‹. Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ Ğ¿ĞµÑ€ĞµĞ½ĞµÑÑ‚Ğ¸ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ.") # ĞĞµÑÑ‚Ñ€Ğ¾Ğ³Ğ¾Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾
    if answers.sleep_last_night == 'no':
        return ('ok', 0, "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ ÑĞ¾Ğ½. Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ Ğ¿ĞµÑ€ĞµĞ½ĞµÑÑ‚Ğ¸ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ.") # ĞĞµÑÑ‚Ñ€Ğ¾Ğ³Ğ¾Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾
    if answers.smoking_last_hour == 'yes':
        return ('ok', 0, "ĞšÑƒÑ€ĞµĞ½Ğ¸Ğµ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ñ‡Ğ°ÑĞ°. Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ Ğ²Ğ¾Ğ·Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒÑÑ.") # ĞĞµÑÑ‚Ñ€Ğ¾Ğ³Ğ¾Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾

    # Ğ•ÑĞ»Ğ¸ Ğ²ÑĞµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ñ‹
    return ('ok', 0, "ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹ Ğ½Ğµ Ğ²Ñ‹ÑĞ²Ğ»ĞµĞ½Ğ¾.")

async def get_ngrok_url():
    for _ in range(10):
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get("http://ngrok:4040/api/tunnels") as response:
                    if response.status == 200:
                        data = await response.json()
                        for tunnel in data['tunnels']:
                            if tunnel['proto'] == 'https':
                                return tunnel['public_url']
        except aiohttp.ClientConnectorError:
            logger.warning("Ngrok is not ready yet, retrying in 3 seconds...")
        await asyncio.sleep(3)
    return None

async def initial_admin_and_texts_setup(): 
    logger.info("Checking for initial admin and texts setup...")
    async with async_session_maker() as session:
        users_exist = await admin_requests.check_if_users_exist(session)
        if not users_exist:
            super_admin_id = config.super_admin_id
            logger.warning(f"Users table is empty. Creating main admin with ID: {super_admin_id}")
            try:
                await admin_requests.create_main_admin(session=session, tg_id=super_admin_id, tg_username="main_admin", full_name="Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€")
                await session.commit()
                logger.info(f"Main admin user created successfully for TG ID {super_admin_id}.")
            except Exception as e:
                logger.error(f"Failed to create main admin: {e}", exc_info=True)
        else:
            logger.info("Users table is not empty. Skipping admin creation.")
        
        info_texts_in_db = (await session.execute(select(func.count(InfoText.section_key)))).scalar()
        if info_texts_in_db == 0:
            logger.warning("InfoTexts table is empty. Populating from Text class.")
            texts_to_add = [
                InfoText(section_key="prepare", section_title="ĞšĞ°Ğº Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ñ‚ÑŒÑÑ?", section_text=Text.INFO_PREPARE),
                InfoText(section_key="contraindications", section_title="ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ", section_text=Text.INFO_CONTRAINDICATIONS),
                InfoText(section_key="after", section_title="Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»Ğµ?", section_text=Text.INFO_AFTER),
                InfoText(section_key="dkm", section_title="Ğ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑÑ‚Ğ²Ğµ ĞºĞ¾ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ·Ğ³Ğ° (Ğ”ĞšĞœ)", section_text=Text.INFO_DKM),
                InfoText(section_key="mifi_process", section_title="Ğ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ÑÑ… Ğ² ĞœĞ˜Ğ¤Ğ˜", section_text=Text.INFO_MIFI_PROCESS),
                InfoText(section_key="contacts", section_title="Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼Ğ¸", section_text=Text.INFO_CONTACTS)
            ]
            session.add_all(texts_to_add)
            await session.commit()
            logger.info("InfoTexts table populated successfully.")
        else:
            logger.info("InfoTexts table already populated. Skipping.")
            
def setup_aiogram_routers():
    dp.update.middleware(DbSessionMiddleware(session_pool=async_session_maker)) 
    dp.update.middleware(BlockUserMiddleware())
    dp.include_router(common.router)
    dp.include_router(student.router)
    dp.include_router(feedback_router)
    dp.include_router(volunteer.router)
    dp.include_router(admin_router)
    dp.include_router(other.router)

async def submit_survey_logic(session: AsyncSession, payload: SurveyPayload) -> tuple[int, str, types.InlineKeyboardMarkup | None]:
    """
    ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ°.
    Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ.
    """
    logger.info("submit_survey_logic: Starting survey processing.")
    try:
        user_data = validate_telegram_data(payload.auth_string)
        user_tg_id = user_data['id']
        user_username = user_data.get('username')
        logger.info(f"submit_survey_logic: Validation successful for user_tg_id: {user_tg_id}, username: {user_username}")
    except HTTPException as e:
        logger.error(f"Survey validation failed: {e.detail}")
        raise

    answers = payload.survey_data
    
    user = await user_requests.get_user_by_tg_id(session, user_tg_id)
    if not user and user_username:
        logger.warning(f"User with tg_id {user_tg_id} not found. Trying to find by username '{user_username}'.")
        found_users = await admin_requests.find_user_for_admin(session, user_username)
        if found_users:
            user = found_users[0]
            logger.info(f"Found user by username: '{user.full_name}'. Updating their tg_id from {user.telegram_id} to {user_tg_id}.")
            user.telegram_id = user_tg_id
            session.add(user)

    if not user:
        logger.error(f"submit_survey_logic: User with tg_id {user_tg_id} or username {user_username} not found in DB.")
        raise HTTPException(status_code=404, detail="User not found in DB")

    status, days, reason = await process_survey_rules(answers, user.gender)
    logger.info(f"submit_survey_logic: Survey rules processed. Status: {status}, Reason: {reason}")

    logger.info(f"submit_survey_logic: Found user '{user.full_name}' (ID: {user.id}) in DB.")
    survey_record = Survey(user_id=user.id, passed=(status == 'ok'), verdict_text=reason, **answers.model_dump())
    session.add(survey_record)

    chat_id_to_send = user_tg_id 
    message_text = ""
    reply_markup = None

    if status == 'ok':
        logger.info(f"submit_survey_logic: Status is OK. Preparing 'success' message.")
        events = await event_requests.get_active_events_for_user(session, user.id)
        message_text = "âœ… Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ¾Ñ‚Ğ²ĞµÑ‚Ñ‹! ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.\n\n"
        if not events:
            message_text += "Ğš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ ÑĞµĞ¹Ñ‡Ğ°Ñ Ğ½ĞµÑ‚."
        else:
            message_text += "Ğ’Ğ¾Ñ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹:"
            builder = InlineKeyboardBuilder() 
            for event in events:
                builder.row(types.InlineKeyboardButton(
                    text=f"{event.event_datetime.strftime('%d.%m.%Y')} - {event.name}",
                    callback_data=f"reg_event_{event.id}"
                ))
            reply_markup = builder.as_markup()
            
    elif status == 'temp_waiver':
        logger.info(f"submit_survey_logic: Status is TEMP_WAIVER. Creating waiver for {days} days.")
        end_date = datetime.date.today() + datetime.timedelta(days=days)
        await admin_requests.create_manual_waiver(session, user.id, end_date, reason, admin_id=0)
        message_text = f"Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ñ‡ĞµÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ. Ğ£ Ğ²Ğ°Ñ Ğ²Ñ‹ÑĞ²Ğ»ĞµĞ½Ğ¾ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ: <b>{reason}</b>\n\nĞœÑ‹ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ğ»Ğ¸ Ğ²Ğ°Ğ¼ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ´Ğ¾ <b>{end_date.strftime('%d.%m.%Y')}</b>. Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹ ÑÑ‡Ğ¸Ñ‚Ğ°ĞµÑ‚Ğµ, Ñ‡Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°, ÑĞ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼Ğ¸."
    
    return chat_id_to_send, message_text, reply_markup

from typing import AsyncGenerator

# Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹ ÑÑ‚Ñƒ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ
async def get_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_maker() as session:
        yield session

async def submit_survey_endpoint(request: Request, session: AsyncSession = Depends(get_session)):
    """
    API ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ¸ Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ.
    """
    try:
        body = await request.json()
        payload = SurveyPayload.model_validate(body)
    except Exception as e:
        logger.error(f"Error processing survey submission: {e}")
        raise HTTPException(status_code=400, detail="Invalid payload")

    chat_id, text, markup = await submit_survey_logic(session, payload)
    await session.commit()
    
    if chat_id and text:
        try:
            logger.info(f"Endpoint: Attempting to send message to chat_id: {chat_id}")
            await bot.send_message(chat_id, text, reply_markup=markup, parse_mode="HTML")
            logger.info(f"Endpoint: Successfully sent message to chat_id: {chat_id}")
        except Exception as e:
            logger.error(f"Endpoint: FAILED to send message to chat_id {chat_id}. Error: {e}", exc_info=True)
    else:
        logger.warning("Endpoint: No chat_id or text returned from logic, nothing to send.")
            
    return {"ok": True}

app = FastAPI()
app.mount("/webapp", StaticFiles(directory="webapp"), name="webapp")

@app.get("/health")
async def health_check():
    return {"status": "ok"}

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting up...")
    app.state.ngrok_url = await get_ngrok_url()

    if app.state.ngrok_url:
        logger.info(f"Successfully fetched ngrok URL: {app.state.ngrok_url}")
        dp["ngrok_url"] = app.state.ngrok_url
    else:
        logger.error("Could not get ngrok URL after several attempts. WebApp will not work.")
        dp["ngrok_url"] = None
    
    await create_db_and_tables()
    await initial_admin_and_texts_setup()
    scheduler = setup_scheduler(bot, async_session_maker, storage)
    scheduler.start()
    asyncio.create_task(dp.start_polling(bot, dp=dp))
    yield
    logger.info("Shutting down...")
    scheduler.shutdown()
    await dp.storage.close()
    await bot.session.close()

app.router.lifespan_context = lifespan
app.add_api_route("/api/submit_survey", submit_survey_endpoint, methods=["POST"])

if __name__ == "__main__":
    setup_aiogram_routers()
    uvicorn.run(app, host="0.0.0.0", port=8000)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: main.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: populate_db.py ---

import asyncio
import datetime
import random
import logging
from faker import Faker
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy import delete, select

# Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ‘Ğ”
import os
from dotenv import load_dotenv

load_dotenv()

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸ Ğ¸ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ· Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
try:
    # Ğ¤Ğ˜ĞĞĞ›Ğ¬ĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯ Ğ˜ĞœĞŸĞĞ Ğ¢ĞĞ’
    from bot.db.models import (
        Base, User, Event, EventRegistration, Donation, MedicalWaiver,
        UserBlock, MerchItem, MerchOrder, Survey, Feedback
    )
    from bot.config_reader import config
except ImportError as e:
    print(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ°: {e}")
    print("Ğ£Ğ±ĞµĞ´Ğ¸Ñ‚ĞµÑÑŒ, Ñ‡Ñ‚Ğ¾ ÑĞºÑ€Ğ¸Ğ¿Ñ‚ 'populate_db.py' Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ² ĞºĞ¾Ñ€Ğ½ĞµĞ²Ğ¾Ğ¹ Ğ¿Ğ°Ğ¿ĞºĞµ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°.")
    exit()

# ĞŸĞ•Ğ Ğ•ĞĞŸĞ Ğ•Ğ”Ğ•Ğ›Ğ¯Ğ•Ğœ Ğ¥ĞĞ¡Ğ¢ Ğ‘Ğ” Ğ¡ĞŸĞ•Ğ¦Ğ˜ĞĞ›Ğ¬ĞĞ Ğ”Ğ›Ğ¯ Ğ­Ğ¢ĞĞ“Ğ Ğ¡ĞšĞ Ğ˜ĞŸĞ¢Ğ
config.db_host = "localhost"


# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# --- ĞšĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ---
USER_COUNT = 1000
VOLUNTEER_COUNT = 5
ADMIN_COUNT = 1
PAST_EVENTS_COUNT = 5
FUTURE_EVENTS_COUNT = 3
REGISTRATION_CHANCE = 0.4
DONATION_CHANCE = 0.7
MANUAL_WAIVER_CHANCE = 0.05

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ Faker Ğ´Ğ»Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ€ÑƒÑÑĞºĞ¾ÑĞ·Ñ‹Ñ‡Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
faker = Faker('ru_RU')

# --- ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ñ Ğ‘Ğ” (Ğ°Ğ½Ğ°Ğ»Ğ¾Ğ³Ğ¸Ñ‡Ğ½Ğ¾ Ğ²Ğ°ÑˆĞµĞ¼Ñƒ engine.py) ---
engine = create_async_engine(
    url=config.database_url,
    echo=False
)
async_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

# --- Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ---
UNIVERSITIES = ["ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜"] * 8 + ["Ğ”Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ’Ğ£Ğ—"] * 2
FACULTIES_MIFI = ["Ğ˜Ğ˜ĞšĞ¡", "Ğ¤Ğ˜Ğ‘Ğ¡", "Ğ˜Ğ¤Ğ¢Ğ­Ğ‘", "Ğ˜Ğ¤Ğ˜Ğ‘", "Ğ°", "Ğ˜Ğ½Ğ¯Ğ·", "Ğ˜ĞŸĞ¢Ğ˜Ğ¡"]
GENDERS = ["male", "female"]
DONATION_TYPES = ['whole_blood', 'plasma', 'platelets']

async def clear_database(session: AsyncSession):
    """ĞÑ‡Ğ¸Ñ‰Ğ°ĞµÑ‚ Ğ²ÑĞµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ† Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞµ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ñ… ĞºĞ»ÑÑ‡ĞµĞ¹."""
    logger.info("ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
    # Ğ¤Ğ˜ĞĞĞ›Ğ¬ĞĞ«Ğ™ ĞŸĞĞ Ğ¯Ğ”ĞĞš ĞĞ§Ğ˜Ğ¡Ğ¢ĞšĞ˜
    tables_to_clear = [
        Survey, Feedback, Donation, EventRegistration, MedicalWaiver, UserBlock, MerchOrder,
        Event, MerchItem, User
    ]
    for table in tables_to_clear:
        stmt = delete(table)
        await session.execute(stmt)
    await session.commit()
    logger.info("Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½Ğ°.")


async def create_users(session: AsyncSession) -> list[User]:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ¿Ğ°Ñ‡ĞºÑƒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹, Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ¾Ğ² Ğ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ²."""
    logger.info(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ {USER_COUNT} Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹...")
    users_to_create = []

    for i in range(USER_COUNT):
        role = 'student'
        if i < ADMIN_COUNT:
            role = 'admin'
        elif i < ADMIN_COUNT + VOLUNTEER_COUNT:
            role = 'volunteer'

        university = random.choice(UNIVERSITIES)
        faculty = random.choice(FACULTIES_MIFI) if university == "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜" else "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
        gender = random.choice(GENDERS)

        user = User(
            phone_number=f"+79{random.randint(100000000, 999999999)}",
            telegram_id=1000000000 + i,
            telegram_username=faker.user_name(),
            full_name=faker.name_male() if gender == 'male' else faker.name_female(),
            university=university,
            faculty=faculty,
            study_group=f"{random.choice(['Ğ‘', 'Ğœ', 'Ğ¡'])}{random.randint(20, 23)}-{random.randint(101, 515)}",
            gender=gender,
            points=random.randint(0, 500),
            role=role,
            is_blocked=False,
            created_at=faker.date_time_between(start_date='-2y', end_date='now')
        )
        users_to_create.append(user)

    session.add_all(users_to_create)
    await session.commit()
    logger.info("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹.")
    
    result = await session.execute(select(User))
    return result.scalars().all()


async def create_events(session: AsyncSession) -> tuple[list[Event], list[Event]]:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞ¸Ğµ Ğ¸ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ."""
    logger.info(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ {PAST_EVENTS_COUNT} Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞ¸Ñ… Ğ¸ {FUTURE_EVENTS_COUNT} Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹...")
    past_events = []
    future_events = []
    today = datetime.datetime.now()

    for i in range(PAST_EVENTS_COUNT):
        event_date = today - datetime.timedelta(days=random.randint(15, 365))
        event = Event(
            name=f"ĞŸÑ€Ğ¾ÑˆĞµĞ´ÑˆĞ°Ñ Ğ°ĞºÑ†Ğ¸Ñ â„–{i+1}",
            event_datetime=event_date,
            location="Ğ³. ĞœĞ¾ÑĞºĞ²Ğ°, ÑƒĞ». Ğ©ÑƒĞºĞ¸Ğ½ÑĞºĞ°Ñ, Ğ´. 6, ĞºĞ¾Ñ€Ğ¿. 2",
            latitude=55.807920,
            longitude=37.491633,
            donation_type=random.choice(DONATION_TYPES),
            points_per_donation=random.randint(100, 250),
            participant_limit=random.randint(50, 100),
            is_active=False,
            registration_is_open=False
        )
        past_events.append(event)

    for i in range(FUTURE_EVENTS_COUNT):
        event_date = today + datetime.timedelta(days=random.randint(10, 60))
        event = Event(
            name=f"Ğ‘ÑƒĞ´ÑƒÑ‰Ğ°Ñ Ğ°ĞºÑ†Ğ¸Ñ â„–{i+1}",
            event_datetime=event_date,
            location="Ğ³. ĞœĞ¾ÑĞºĞ²Ğ°, ĞšĞ°ÑˆĞ¸Ñ€ÑĞºĞ¾Ğµ ÑˆĞ¾ÑÑĞµ, 31",
            latitude=55.649917,
            longitude=37.662128,
            donation_type=random.choice(DONATION_TYPES),
            points_per_donation=random.randint(100, 250),
            participant_limit=random.randint(60, 120),
            is_active=True,
            registration_is_open=True
        )
        future_events.append(event)

    session.add_all(past_events + future_events)
    await session.commit()
    logger.info("ĞœĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹.")
    return past_events, future_events


async def create_registrations_and_donations(session: AsyncSession, users: list[User], events: list[Event]):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ, Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞ¸Ñ… - Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ¸ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹."""
    logger.info("Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¹, Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹ Ğ¸ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ñ… Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ²...")
    regs_to_create = []
    donations_to_create = []
    waivers_to_create = []
    user_updates = {}

    for event in events:
        for user in users:
            if random.random() < REGISTRATION_CHANCE:
                regs_to_create.append(EventRegistration(user_id=user.id, event_id=event.id))
                if not event.is_active and random.random() < DONATION_CHANCE:
                    donation_date = event.event_datetime.date()
                    points_awarded = event.points_per_donation
                    donations_to_create.append(Donation(
                        user_id=user.id,
                        event_id=event.id,
                        donation_date=donation_date,
                        donation_type=event.donation_type,
                        points_awarded=points_awarded
                    ))
                    user_updates[user.id] = user_updates.get(user.id, 0) + points_awarded
                    days_waiver = (90 if user.gender == 'female' else 60) if event.donation_type == 'whole_blood' else 14
                    end_date = donation_date + datetime.timedelta(days=days_waiver)
                    waivers_to_create.append(MedicalWaiver(
                        user_id=user.id,
                        start_date=donation_date,
                        end_date=end_date,
                        reason=f"Ğ¡Ğ´Ğ°Ñ‡Ğ° Â«{event.donation_type}Â»",
                        created_by='system'
                    ))

    session.add_all(regs_to_create)
    session.add_all(donations_to_create)
    session.add_all(waivers_to_create)
    await session.commit()

    logger.info(f"ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ² Ğ´Ğ»Ñ {len(user_updates)} Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹...")
    for user_id, points in user_updates.items():
        user = await session.get(User, user_id)
        if user:
            user.points += points
    await session.commit()
    logger.info("Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¸ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹.")


async def create_manual_waivers(session: AsyncSession, users: list[User]):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğµ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹, ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ 'Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼'."""
    logger.info("Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¸Ñ… Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ²...")
    waivers_to_create = []
    users_with_waiver = random.sample(users, int(len(users) * MANUAL_WAIVER_CHANCE))
    today = datetime.date.today()

    for user in users_with_waiver:
        start_date = today - datetime.timedelta(days=random.randint(0, 10))
        end_date = today + datetime.timedelta(days=random.randint(5, 30))
        waiver = MedicalWaiver(
            user_id=user.id,
            start_date=start_date,
            end_date=end_date,
            reason=random.choice(["ĞŸÑ€Ğ¾ÑÑ‚ÑƒĞ´Ğ°", "ĞŸĞ»Ğ¾Ñ…Ğ¾Ğµ ÑĞ°Ğ¼Ğ¾Ñ‡ÑƒĞ²ÑÑ‚Ğ²Ğ¸Ğµ", "ĞŸÑ€Ğ¸ĞµĞ¼ Ğ»ĞµĞºĞ°Ñ€ÑÑ‚Ğ²"]),
            created_by='user'
        )
        waivers_to_create.append(waiver)

    session.add_all(waivers_to_create)
    await session.commit()
    logger.info(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾ {len(waivers_to_create)} Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¸Ñ… Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ².")


async def main():
    """Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ²ÑĞµÑ… ÑÑ‚Ğ°Ğ¿Ğ¾Ğ² Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ‘Ğ”."""
    async with async_session_maker() as session:
        await clear_database(session)
        users = await create_users(session)
        past_events, future_events = await create_events(session)
        all_events = past_events + future_events
        await create_registrations_and_donations(session, users, all_events)
        await create_manual_waivers(session, users)

    logger.info("ğŸ‰ Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ° Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸.")


if __name__ == "__main__":
    asyncio.run(main())

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: populate_db.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: pytest.ini ---

[pytest]
asyncio_mode = auto
log_file = logs/pytest-logs.txt

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: pytest.ini ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: requirements-dev.txt ---

bandit

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: requirements-dev.txt ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: requirements.txt ---

aiogram==3.4.1
aiogram[redis]==3.4.1
redis==5.0.1
sqlalchemy[asyncio]==2.0.27
asyncpg==0.29.0
python-dotenv==1.0.1
qrcode[pil]==7.4.2
pyzbar==0.1.9
pillow==10.3.0
apscheduler==3.10.4
alembic==1.13.1
pydantic-settings==2.2.1
ics==0.7.2
greenlet==3.0.3
aiohttp==3.9.5
aiosignal==1.3.1
attrs==23.2.0
frozenlist==1.4.1
multidict==6.0.5
yarl==1.9.4
pytz
fastapi==0.111.1
uvicorn[standard]==0.29.0
python-jose[cryptography]==3.4.0
python-multipart==0.0.18 
matplotlib==3.8.4 
pandas==2.2.2
openpyxl==3.1.2
httpx==0.27.0

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: requirements.txt ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: alembic/README ---

Generic single-database configuration.

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: alembic/README ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: alembic/env.py ---

from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
from bot.db.models import Base
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


import asyncio
from sqlalchemy.ext.asyncio import create_async_engine

# ... (other imports)

def do_run_migrations(connection):
    context.configure(connection=connection, target_metadata=target_metadata)
    with context.begin_transaction():
        context.run_migrations()

async def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = create_async_engine(
        config.get_main_option("sqlalchemy.url"),
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: alembic/env.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: alembic/script.py.mako ---

"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: alembic/script.py.mako ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/__init__.py ---



--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/__init__.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/config_reader.py ---

from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import SecretStr, StrictStr

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')
    bot_token: SecretStr
    super_admin_id: int
    ngrok_authtoken: SecretStr 
    db_host: StrictStr
    db_port: int
    db_name: StrictStr
    db_user: StrictStr
    db_pass: SecretStr
    qr_secret_key: SecretStr
    @property
    def database_url(self) -> str:
        return (f"postgresql+asyncpg://{self.db_user}:{self.db_pass.get_secret_value()}"
                f"@{self.db_host}:{self.db_port}/{self.db_name}")


config = Settings()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/config_reader.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/__init__.py ---

from . import user_requests
from . import event_requests
from . import merch_requests
from . import admin_requests
from . import info_requests
from . import question_requests

__all__ = [
    "user_requests",
    "event_requests",
    "merch_requests",
    "admin_requests",
    "info_requests",
    "question_requests",
]

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/__init__.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/admin_requests.py ---

# Ğ¤ĞĞ™Ğ›: bot/db/admin_requests.py

import datetime
import logging # <-- Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ¢Ğ¬ Ğ­Ğ¢Ğ£ Ğ¡Ğ¢Ğ ĞĞšĞ£
from sqlalchemy import select, update, or_, func, String, delete, distinct, extract
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload, selectinload
from .models import (
    User, Event, EventRegistration, Donation, MedicalWaiver, 
    MerchItem, MerchOrder, UserBlock, BloodCenter
)
from .models import Feedback
from .event_requests import find_specific_registration, add_event_registration, confirm_donation_transaction
import math

logger = logging.getLogger(__name__) 

async def check_if_users_exist(session: AsyncSession) -> bool:
    user_count = await session.scalar(select(func.count(User.id)))
    return user_count > 0


# --- User Management ---
async def find_user_for_admin(session: AsyncSession, query: str) -> User | None:
    stmt = select(User).where(
        or_(
            User.full_name.ilike(f"%{query}%"),
            User.telegram_username.ilike(f"%{query}%"),
            User.telegram_id.cast(String).ilike(f"%{query}%"),
            User.phone_number.ilike(f"%{query}%")
        )
    ).order_by(User.full_name)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_users_page(session: AsyncSession, page: int = 1, page_size: int = 10) -> tuple[list[User], int]:
    offset = (page - 1) * page_size
    total_count = (await session.execute(select(func.count(User.id)))).scalar_one()
    items_result = await session.execute(select(User).order_by(User.full_name).offset(offset).limit(page_size))
    items = items_result.scalars().all()
    total_pages = math.ceil(total_count / page_size) if total_count > 0 else 1
    return items, total_pages

async def update_user_field(session: AsyncSession, user_id: int, field_name: str, new_value: any):
    """
    Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ Ğ¿Ğ¾Ğ»Ğµ Ğ´Ğ»Ñ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.
    Ğ’ĞĞ–ĞĞ: Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ğ¸Ñ‚ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ñ.
    """
    if not hasattr(User, field_name):
        logger.error(f"Attempted to update a non-existent field '{field_name}' for User.")
        return

    stmt = update(User).where(User.id == user_id).values({field_name: new_value})
    await session.execute(stmt)


async def get_all_users(session: AsyncSession) -> list[User]:
    stmt = select(User).order_by(User.full_name)
    result = await session.execute(stmt)
    return result.scalars().all()

# ĞĞĞ’ĞĞ•: Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
async def delete_user_by_id(session: AsyncSession, user_id: int) -> bool:
    """ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ ÑƒĞ´Ğ°Ğ»ÑĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ Ğ½Ğ¸Ğ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ."""
    user = await session.get(User, user_id)
    if not user:
        return False
    await session.delete(user)
    # SQLAlchemy Ğ±Ğ»Ğ°Ğ³Ğ¾Ğ´Ğ°Ñ€Ñ `cascade` Ğ² Ğ¼Ğ¾Ğ´ĞµĞ»ÑÑ… ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸, Ğ·Ğ°ĞºĞ°Ğ·Ñ‹ Ğ¸ Ñ‚.Ğ´.
    await session.commit()
    return True

async def change_user_role(session: AsyncSession, user_id: int, new_role: str):
    stmt = update(User).where(User.id == user_id).values(role=new_role)
    await session.execute(stmt)
    await session.commit()

async def add_points_to_user(session: AsyncSession, user_id: int, points: int, reason: str):
    user = await session.get(User, user_id)
    user.points += points
    # log: # Ğ—Ğ´ĞµÑÑŒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑÑ‚Ğ¾Ğ¹ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½ÑƒÑ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ
    await session.commit()

async def block_user(session: AsyncSession, user_id: int, admin_id: int, reason: str):
    user = await session.get(User, user_id)
    user.is_blocked = True
    block_record = UserBlock(user_id=user_id, admin_id=admin_id, reason=reason, is_active=True)
    session.add(block_record)
    # log: # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
    await session.commit()

async def unblock_user(session: AsyncSession, user_id: int):
    user = await session.get(User, user_id)
    user.is_blocked = False
    stmt = update(UserBlock).where(UserBlock.user_id == user_id, UserBlock.is_active == True).values(is_active=False)
    await session.execute(stmt)
    # log: # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
    await session.commit()

# --- (ĞÑÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ĞºĞ¾Ğ´ Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹) ---

# --- Event Management ---
async def create_event(session: AsyncSession, data: dict) -> Event:
    event = Event(**data)
    session.add(event)
    await session.commit()
    return event

async def update_event_field(session: AsyncSession, event_id: int, field_name: str, new_value: any):
    if not hasattr(Event, field_name):
        return
    stmt = update(Event).where(Event.id == event_id).values({field_name: new_value})
    await session.execute(stmt)
    await session.commit()


async def get_all_blood_centers(session: AsyncSession) -> list[BloodCenter]:
    stmt = select(BloodCenter).order_by(BloodCenter.name)
    result = await session.execute(stmt)
    return result.scalars().all()


async def create_blood_center(session: AsyncSession, name: str) -> BloodCenter:
    blood_center = BloodCenter(name=name)
    session.add(blood_center)
    await session.commit()
    return blood_center


async def get_blood_center_by_id(session: AsyncSession, blood_center_id: int) -> BloodCenter | None:
    return await session.get(BloodCenter, blood_center_id)

# --- Merch Management ---
async def create_merch_item(session: AsyncSession, data: dict) -> MerchItem:
    item = MerchItem(**data)
    session.add(item)
    await session.commit()
    return item

# --- Order Processing ---
async def get_pending_orders(session: AsyncSession) -> list[MerchOrder]:
    stmt = select(MerchOrder).options(joinedload(MerchOrder.user), joinedload(MerchOrder.item)).where(MerchOrder.status == 'pending_pickup').order_by(MerchOrder.order_date)
    result = await session.execute(stmt)
    return result.scalars().all()

async def complete_order(session: AsyncSession, order_id: int, admin_id: int):
    order = await session.get(MerchOrder, order_id)
    if order:
        order.status = 'completed'
        order.completed_by_admin_id = admin_id
        order.completion_date = datetime.datetime.now()
        # log: # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
        await session.commit()

# --- Manual Waiver ---
async def create_manual_waiver(session: AsyncSession, user_id: int, end_date: datetime.date, reason: str, admin_id: int):
    waiver = MedicalWaiver(
        user_id=user_id,
        start_date=datetime.date.today(),
        end_date=end_date,
        reason=reason,
        created_by=str(admin_id)
    )
    session.add(waiver)
    # log: # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°
    await session.commit()

# --- Export Functions ---
async def get_all_donations(session: AsyncSession) -> list:
    stmt = select(Donation).options(
        joinedload(Donation.user),
        joinedload(Donation.event)
    ).order_by(Donation.donation_date.desc())
    result = await session.execute(stmt)
    return result.scalars().all()

# --- Main Admin Setup ---
async def create_main_admin(session: AsyncSession, tg_id: int, tg_username: str, full_name: str):
    new_admin = User(
        phone_number=f"admin_{tg_id}",
        telegram_id=tg_id,
        telegram_username=tg_username,
        full_name=full_name,
        role='main_admin',
        university="ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ"  # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
    )
    session.add(new_admin)

async def update_main_admin_data(session: AsyncSession, tg_id: int, tg_username: str, full_name: str):
    stmt = (
        update(User)
        .where(User.telegram_id == tg_id)
        .values(
            role='main_admin',
            telegram_username=tg_username,
            full_name=full_name
        )
    )
    await session.execute(stmt)
    await session.commit()

async def get_event_registrations_count(session: AsyncSession, event_id: int) -> int:
    stmt = select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event_id)
    result = await session.execute(stmt)
    return result.scalar_one()

async def get_event_with_participants(session: AsyncSession, event_id: int):
    stmt = select(Event).options(selectinload(Event.registrations).joinedload(EventRegistration.user)).where(Event.id == event_id)
    result = await session.execute(stmt)
    event = result.scalar_one_or_none()
    if not event:
        return None, []
    return event, event.registrations

async def deactivate_event(session: AsyncSession, event_id: int):
    stmt = update(Event).where(Event.id == event_id).values(is_active=False)
    await session.execute(stmt)
    await session.commit()

async def get_all_merch_items(session: AsyncSession) -> list[MerchItem]:
    stmt = select(MerchItem).order_by(MerchItem.id)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_merch_item_by_id(session: AsyncSession, item_id: int) -> MerchItem | None:
    return await session.get(MerchItem, item_id)

async def update_merch_item_field(session: AsyncSession, item_id: int, field_name: str, new_value: any):
    if not hasattr(MerchItem, field_name):
        return
    stmt = update(MerchItem).where(MerchItem.id == item_id).values({field_name: new_value})
    await session.execute(stmt)
    await session.commit()

async def toggle_merch_item_availability(session: AsyncSession, item_id: int) -> bool:
    item = await session.get(MerchItem, item_id)
    if not item:
        return False
    item.is_available = not item.is_available
    await session.commit()
    return item.is_available

async def delete_merch_item_by_id(session: AsyncSession, item_id: int):
    item = await session.get(MerchItem, item_id)
    if item:
        await session.delete(item)
        await session.commit()

# --- Export Functions ---
async def get_all_data_for_export(session: AsyncSession) -> dict:
    data_to_export = {
        "users": (await session.execute(select(User))).scalars().all(),
        "events": (await session.execute(select(Event))).scalars().all(),
        "event_registrations": (await session.execute(select(EventRegistration))).scalars().all(),
        "donations": (await session.execute(select(Donation))).scalars().all(),
        "medical_waivers": (await session.execute(select(MedicalWaiver))).scalars().all(),
        "merch_items": (await session.execute(select(MerchItem))).scalars().all(),
        "merch_orders": (await session.execute(select(MerchOrder))).scalars().all(),
        "user_blocks": (await session.execute(select(UserBlock))).scalars().all(),
    }
    return data_to_export



async def toggle_event_registration_status(session: AsyncSession, event_id: int) -> bool:
    """ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ (Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°/Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°)."""
    event = await session.get(Event, event_id)
    if not event:
        return False
    event.registration_is_open = not event.registration_is_open
    await session.commit()
    return event.registration_is_open



async def get_user_registrations(session: AsyncSession, user_id: int) -> list[EventRegistration]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ²ÑĞµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ½Ğ° Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ."""
    stmt = (
        select(EventRegistration)
        .join(EventRegistration.event)
        .where(
            EventRegistration.user_id == user_id,
            Event.event_date >= datetime.date.today(),
            EventRegistration.status == 'registered'
        )
        .options(joinedload(EventRegistration.event))
        .order_by(Event.event_date)
    )
    result = await session.execute(stmt)
    return result.scalars().all()


async def manually_register_user(session: AsyncSession, user: User, event: Event) -> tuple[bool, str]:
    """
    Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ Ğ¾Ñ‚ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°.
    ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ²ÑĞµ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ, ĞºÑ€Ğ¾Ğ¼Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¾Ğ¹ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸.
    """
    # 1. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºÑƒ
    if user.is_blocked:
        return False, "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½."

    # 2. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ÑƒÑ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ
    existing_reg = await find_specific_registration(session, user.id, event.id)
    if existing_reg:
        return False, "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒĞ¶Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ğ½Ğ° ÑÑ‚Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ."

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹ (Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ¸Ğ· check_registration_eligibility)
    waiver_stmt = select(MedicalWaiver).where(MedicalWaiver.user_id == user.id, MedicalWaiver.end_date >= event.event_date)
    active_waiver = (await session.execute(waiver_stmt)).scalar_one_or_none()
    if active_waiver:
        return False, f"Ğ£ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ´ĞµĞ¹ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ´Ğ¾ {active_waiver.end_date.strftime('%d.%m.%Y')}."

    # Ğ•ÑĞ»Ğ¸ Ğ²ÑĞµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ñ‹, Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼
    await add_event_registration(session, user.id, event.id)
    return True, f"ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user.full_name} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½ Ğ½Ğ° {event.name}."


async def get_all_user_active_waivers(session: AsyncSession, user_id: int) -> list[MedicalWaiver]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ’Ğ¡Ğ• Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (Ğ¸ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğµ, Ğ¸ Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ)."""
    stmt = select(MedicalWaiver).where(
        MedicalWaiver.user_id == user_id,
        MedicalWaiver.end_date >= datetime.date.today()
    ).order_by(MedicalWaiver.end_date)
    result = await session.execute(stmt)
    return result.scalars().all()


async def force_delete_waiver(session: AsyncSession, waiver_id: int) -> bool:
    """ĞŸÑ€Ğ¸Ğ½ÑƒĞ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»ÑĞµÑ‚ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ¿Ğ¾ ĞµĞ³Ğ¾ ID. Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ True Ğ² ÑĞ»ÑƒÑ‡Ğ°Ğµ ÑƒÑĞ¿ĞµÑ…Ğ°."""
    stmt = delete(MedicalWaiver).where(MedicalWaiver.id == waiver_id)
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0


async def get_feedback_for_event(session: AsyncSession, event_id: int) -> list[Feedback]:
    stmt = (
        select(Feedback)
        .options(joinedload(Feedback.user))
        .where(Feedback.event_id == event_id)
        .order_by(Feedback.created_at.desc())
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_distinct_universities(session: AsyncSession) -> list[str]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğ¹ ÑƒĞ½Ğ¸Ğ²ĞµÑ€ÑĞ¸Ñ‚ĞµÑ‚Ğ¾Ğ² Ğ¸Ğ· Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ users."""
    stmt = select(distinct(User.university)).order_by(User.university)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_distinct_faculties(session: AsyncSession) -> list[str]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ğ¾Ğ² Ğ¸Ğ· Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ users, Ğ¸ÑĞºĞ»ÑÑ‡Ğ°Ñ NULL."""
    stmt = (
        select(distinct(User.faculty))
        .where(User.faculty.is_not(None)) 
        .order_by(User.faculty)
    )
    result = await session.execute(stmt)
    return result.scalars().all()


async def manually_confirm_donation(session: AsyncSession, user_id: int, event_id: int, became_dkm_donor: bool) -> tuple[bool, str]:
    """
    Ğ’Ñ€ÑƒÑ‡Ğ½ÑƒÑ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´Ğ°ĞµÑ‚ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¸.
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ (ÑƒÑĞ¿ĞµÑ…, ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ).
    """
    user = await session.get(User, user_id)
    event = await session.get(Event, event_id)
    if not user or not event:
        return False, "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¸Ğ»Ğ¸ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹."

    registration = await find_specific_registration(session, user_id, event_id)
    if not registration:    
        registration = EventRegistration(user_id=user_id, event_id=event_id)
        session.add(registration)
        await session.flush()

    if registration.status == 'attended':
        return False, f"Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ {user.full_name} ÑƒĞ¶Ğµ Ğ±Ñ‹Ğ»Ğ° Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ°."

    try:
        await confirm_donation_transaction(session, user, registration)
        if became_dkm_donor and not user.is_dkm_donor:
            user.is_dkm_donor = True
            
        await session.commit()
        return True, f"Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ {user.full_name} Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ°."
    except Exception as e:
        await session.rollback()
        logger.error(f"Error in manually_confirm_donation for user {user_id}: {e}")
        return False, f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğ¸ Ğ´Ğ»Ñ {user.full_name}: {e}"


async def get_min_user_id(session: AsyncSession) -> int:
    """
    Gets the minimum user ID from the database.
    """
    result = await session.execute(select(func.min(User.telegram_id)))
    min_id = result.scalar_one_or_none()
    return min_id if min_id is not None else 0

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/admin_requests.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/analytics_requests.py ---

import datetime
from sqlalchemy import select, func, and_, distinct, text
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload, selectinload

from .models import User, Event, Donation, EventRegistration, Survey, MedicalWaiver

async def get_main_kpi(session: AsyncSession) -> dict:
    """Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµÑ‚ ĞºĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ´Ğ»Ñ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ°ÑˆĞ±Ğ¾Ñ€Ğ´Ğ°."""
    
    thirty_days_ago = datetime.datetime.now() - datetime.timedelta(days=30)
    new_users_stmt = select(func.count(User.id)).where(User.created_at >= thirty_days_ago)
    new_users_count = (await session.execute(new_users_stmt)).scalar_one()

    ninety_days_ago = datetime.date.today() - datetime.timedelta(days=90)
    active_donors_stmt = select(func.count(distinct(Donation.user_id))).where(Donation.donation_date >= ninety_days_ago)
    active_donors_count = (await session.execute(active_donors_stmt)).scalar_one()
    
    waiver_stmt = select(func.count(distinct(User.id))).join(User.waivers).where(MedicalWaiver.end_date >= datetime.date.today())
    on_waiver_count = (await session.execute(waiver_stmt)).scalar_one()

    next_event_stmt = select(Event).where(Event.is_active == True, Event.event_datetime >= datetime.datetime.now()).order_by(Event.event_datetime).limit(1)
    next_event = (await session.execute(next_event_stmt)).scalar_one_or_none()
    
    next_event_info = None
    if next_event:
        regs_count = (await session.execute(select(func.count(EventRegistration.id)).where(EventRegistration.event_id == next_event.id))).scalar_one()
        next_event_info = {
            "name": next_event.name,
            "registered": regs_count,
            "limit": next_event.participant_limit,
            "date": next_event.event_datetime
        }
        
    return {
        "new_users_30d": new_users_count,
        "active_donors_90d": active_donors_count,
        "on_waiver_now": on_waiver_count,
        "next_event": next_event_info
    }

async def get_donations_by_month(session: AsyncSession, months: int = 6) -> list[tuple]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹ Ğ¿Ğ¾ Ğ¼ĞµÑÑÑ†Ğ°Ğ¼ Ğ·Ğ° Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ N Ğ¼ĞµÑÑÑ†ĞµĞ².
    Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ•Ğ¢ date_trunc Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ñ PostgreSQL.
    """
    today = datetime.date.today()
    start_date = (today.replace(day=1) - datetime.timedelta(days=1)).replace(day=1)
    for _ in range(months - 1):
        start_date = (start_date - datetime.timedelta(days=1)).replace(day=1)

    stmt = text("""
        SELECT
            date_trunc('month', donation_date)::DATE as month_date,
            count(id) as count
        FROM donations
        WHERE donation_date >= :start_date
        GROUP BY month_date
        ORDER BY month_date
    """)
    
    result = await session.execute(stmt, {"start_date": start_date})
    
    return [(row.month_date, row.count) for row in result]

async def get_past_events_for_analysis(session: AsyncSession) -> list[Event]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞ¸Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°."""
    stmt = select(Event).where(Event.event_datetime < datetime.datetime.now()).order_by(Event.event_datetime.desc()).limit(15)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_event_analysis_data(session: AsyncSession, event_id: int) -> dict:
    """Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµÑ‚ Ğ²ÑÑ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºÑƒ Ğ¿Ğ¾ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞµĞ¼Ñƒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ."""
    event = await session.get(Event, event_id)
    if not event:
        return None

    stmt_registrations = select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event_id)
    registered_count = (await session.execute(stmt_registrations)).scalar_one()
    
    stmt_donations = select(func.count(Donation.id)).where(Donation.event_id == event_id)
    attended_count = (await session.execute(stmt_donations)).scalar_one()
    
    stmt_attended_users = (
        select(User)
        .join(Donation)
        .where(Donation.event_id == event_id)
    )
    # Ğ—Ğ”Ğ•Ğ¡Ğ¬ Ğ‘Ğ«Ğ›Ğ ĞĞ¨Ğ˜Ğ‘ĞšĞ, Ğ¢Ğ•ĞŸĞ•Ğ Ğ¬ ĞĞĞ Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ Ğ‘Ğ›ĞĞ“ĞĞ”ĞĞ Ğ¯ Ğ˜ĞœĞŸĞĞ Ğ¢Ğ£
    attended_users_result = await session.execute(stmt_attended_users.options(selectinload(User.donations)))
    attended_users = attended_users_result.scalars().unique().all()
    
    newcomers_count = sum(1 for user in attended_users if len(user.donations) == 1)
    
    faculties_dist = {}
    for user in attended_users:
        faculty = user.faculty or "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
        faculties_dist[faculty] = faculties_dist.get(faculty, 0) + 1

    return {
        "event_name": event.name,
        "registered_count": registered_count,
        "attended_count": attended_count,
        "conversion_rate": (attended_count / registered_count * 100) if registered_count > 0 else 0,
        "newcomers_count": newcomers_count,
        "veterans_count": attended_count - newcomers_count,
        "faculties_distribution": faculties_dist
    }

async def get_one_time_donors(session: AsyncSession) -> list[dict]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ÑĞ´Ğ°Ğ»Ğ¸ ĞºÑ€Ğ¾Ğ²ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ´Ğ¸Ğ½ Ñ€Ğ°Ğ·."""
    stmt = (
        select(User, func.count(Donation.id).label("donation_count"))
        .join(Donation)
        .group_by(User)
        .having(func.count(Donation.id) == 1)
    )
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_no_show_donors(session: AsyncSession) -> list[dict]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ»Ğ¸ÑÑŒ, Ğ½Ğ¾ Ğ½Ğµ Ğ¿Ñ€Ğ¸ÑˆĞ»Ğ¸."""
    stmt = (
        select(User)
        .join(EventRegistration)
        .where(EventRegistration.status == "no_show_survey_sent")
    )
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_dkm_donors(session: AsyncSession) -> list[dict]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ÑĞ²Ğ»ÑÑÑ‚ÑÑ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ°Ğ¼Ğ¸ ĞºĞ¾ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ·Ğ³Ğ°."""
    stmt = select(User).where(User.is_dkm_donor == True)
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_students(session: AsyncSession) -> list[dict]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ÑĞ²Ğ»ÑÑÑ‚ÑÑ ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚Ğ°Ğ¼Ğ¸."""
    stmt = select(User).where(User.category == "student")
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_employees(session: AsyncSession) -> list[dict]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ÑĞ²Ğ»ÑÑÑ‚ÑÑ ÑĞ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸ĞºĞ°Ğ¼Ğ¸."""
    stmt = select(User).where(User.category == "employee")
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_external_donors(session: AsyncSession) -> list[dict]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ÑĞ²Ğ»ÑÑÑ‚ÑÑ Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ğ¼Ğ¸ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ°Ğ¼Ğ¸."""
    stmt = select(User).where(User.category == "external")
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_graduated_donors(session: AsyncSession) -> list[dict]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ²Ñ‹Ğ¿ÑƒÑÑ‚Ğ¸Ğ»Ğ¸ÑÑŒ Ğ¸Ğ· ÑƒĞ½Ğ¸Ğ²ĞµÑ€ÑĞ¸Ñ‚ĞµÑ‚Ğ°."""
    # This is a placeholder. The actual implementation will depend on how graduation is determined.
    return []

async def get_churn_donors(session: AsyncSession) -> list[dict]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²-Ğ¾Ğ´Ğ½Ğ¾Ğ´Ğ½ĞµĞ²Ğ¾Ğº.
    Ğ›Ğ¾Ğ³Ğ¸ĞºĞ°: ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸, Ñƒ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ñ€Ğ¾Ğ²Ğ½Ğ¾ 1 Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ, Ğ¸ Ğ¾Ğ½Ğ° Ğ±Ñ‹Ğ»Ğ° Ğ±Ğ¾Ğ»ĞµĞµ 6 Ğ¼ĞµÑÑÑ†ĞµĞ² Ğ½Ğ°Ğ·Ğ°Ğ´.
    """
    six_months_ago = datetime.datetime.now() - datetime.timedelta(days=180)

    # ĞŸĞ¾Ğ´Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ĞµĞ¹
    subquery = (
        select(Donation.user_id)
        .group_by(Donation.user_id)
        .having(func.count(Donation.id) == 1)
    ).alias("one_donation_users")

    # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ
    stmt = (
        select(User.full_name, User.telegram_username, Donation.donation_date)
        .join(subquery, User.id == subquery.c.user_id)
        .join(Donation, User.id == Donation.user_id)
        .where(Donation.donation_date < six_months_ago)
    )

    result = await session.execute(stmt)
    return [
        {"full_name": row.full_name, "username": row.telegram_username, "donation_date": row.donation_date}
        for row in result
    ]

async def get_lapsed_donors(session: AsyncSession) -> list[dict]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑƒĞ³Ğ°ÑĞ°ÑÑ‰Ğ¸Ñ… Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ².
    Ğ›Ğ¾Ğ³Ğ¸ĞºĞ°: 2+ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸, Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ > 9 Ğ¼ĞµÑ. Ğ½Ğ°Ğ·Ğ°Ğ´, Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ².
    """
    nine_months_ago = datetime.datetime.now() - datetime.timedelta(days=270)
    today = datetime.date.today()

    # ĞŸĞ¾Ğ´Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ: Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ Ñ 2+ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸ Ğ¸ Ğ´Ğ°Ñ‚Ğ¾Ğ¹ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¹ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸
    subquery = (
        select(
            Donation.user_id,
            func.count(Donation.id).label("donations_count"),
            func.max(Donation.donation_date).label("last_donation_date")
        )
        .group_by(Donation.user_id)
        .having(func.count(Donation.id) >= 2)
        .alias("lapsed_candidates")
    )

    # ĞŸĞ¾Ğ´Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ: Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ Ñ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼Ğ¸ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°Ğ¼Ğ¸
    active_waiver_subquery = (
        select(MedicalWaiver.user_id)
        .where(MedicalWaiver.end_date >= today)
    ).alias("active_waivers")

    # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ
    stmt = (
        select(
            User.full_name,
            User.telegram_username,
            subquery.c.donations_count,
            subquery.c.last_donation_date
        )
        .join(subquery, User.id == subquery.c.user_id)
        .outerjoin(active_waiver_subquery, User.id == active_waiver_subquery.c.user_id)
        .where(
            subquery.c.last_donation_date < nine_months_ago,
            active_waiver_subquery.c.user_id == None # Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ğµ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²Ğ¸Ñ Ğ² Ğ¿Ğ¾Ğ´Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞµ Ñ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°Ğ¼Ğ¸
        )
    )

    result = await session.execute(stmt)
    return [
        {
            "full_name": row.full_name,
            "username": row.telegram_username,
            "donation_count": row.donations_count,
            "last_donation_date": row.last_donation_date
        }
        for row in result
    ]

async def get_top_donors(session: AsyncSession) -> list[dict]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ¿-20 Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ² Ğ¿Ğ¾ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ñƒ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹.
    """
    # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ¾ĞºĞ¾Ğ½Ğ½ÑƒÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ñ€Ğ°Ğ½Ğ¶Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
    stmt = (
        select(
            User.full_name,
            User.telegram_username,
            func.count(Donation.id).label("donation_count"),
            func.rank().over(order_by=func.count(Donation.id).desc()).label("rank")
        )
        .join(Donation, User.id == Donation.user_id)
        .group_by(User.id)
        .order_by(text("rank")) # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ñ€Ğ°Ğ½Ğ³Ñƒ
        .limit(20)
    )

    result = await session.execute(stmt)
    return [
        {
            "rank": row.rank,
            "full_name": row.full_name,
            "username": row.telegram_username,
            "donation_count": row.donation_count
        }
        for row in result
    ]

async def get_rare_blood_donors(session: AsyncSession) -> list[dict]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ² Ñ Ñ€ĞµĞ´ĞºĞ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ¾Ğ¹ ĞºÑ€Ğ¾Ğ²Ğ¸.
    Ğ›Ğ¾Ğ³Ğ¸ĞºĞ°: rh_factor = '-' Ğ˜Ğ›Ğ˜ blood_type = 'AB(IV)'.
    """
    stmt = (
        select(User.full_name, User.telegram_username, User.blood_type, User.rh_factor)
        .where(
            (User.rh_factor == '-') |
            (User.blood_type == 'AB(IV)')
        )
        .order_by(User.full_name)
    )

    result = await session.execute(stmt)
    return [
        {
            "full_name": row.full_name,
            "username": row.telegram_username,
            "blood_group": f"{row.blood_type}{row.rh_factor}"
        }
        for row in result
    ]

async def get_top_faculties(session: AsyncSession) -> list[dict]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ°Ğ¼Ñ‹Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ñ‹ Ğ¿Ğ¾ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ñƒ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹.
    Ğ›Ğ¾Ğ³Ğ¸ĞºĞ°: Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹ Ğ¿Ğ¾ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ğ°Ğ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ¸Ğ· ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜.
    """
    stmt = (
        select(User.faculty, func.count(Donation.id).label("donation_count"))
        .join(Donation, User.id == Donation.user_id)
        .where(User.university == "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", User.faculty != None)
        .group_by(User.faculty)
        .order_by(func.count(Donation.id).desc())
    )

    result = await session.execute(stmt)
    return [
        {"faculty_name": row.faculty, "donation_count": row.donation_count}
        for row in result
    ]

async def get_dkm_candidates(session: AsyncSession) -> list[dict]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ĞºĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ğ² Ğ² Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ğ”ĞšĞœ.
    Ğ›Ğ¾Ğ³Ğ¸ĞºĞ°: ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ Ñ 2+ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸, Ğ½Ğ¾ is_dkm_donor = False.
    """
    subquery = (
        select(Donation.user_id, func.count(Donation.id).label("donation_count"))
        .group_by(Donation.user_id)
        .having(func.count(Donation.id) >= 2)
    ).alias("two_plus_donations")

    stmt = (
        select(User.full_name, User.telegram_username, two_plus_donations.c.donation_count)
        .join(two_plus_donations, User.id == two_plus_donations.c.user_id)
        .where(User.is_dkm_donor == False)
        .order_by(User.full_name)
    )

    result = await session.execute(stmt)
    return [
        {
            "full_name": row.full_name,
            "username": row.telegram_username,
            "donation_count": row.donation_count
        }
        for row in result
    ]

async def get_survey_dropoff(session: AsyncSession) -> list[dict]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹, "Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ½Ğ½Ñ‹Ñ…" Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ°.
    Ğ›Ğ¾Ğ³Ğ¸ĞºĞ°: Ğ•ÑÑ‚ÑŒ ÑƒÑĞ¿ĞµÑˆĞ½Ñ‹Ğ¹ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸Ğº, Ğ½Ğ¾ Ğ½ĞµÑ‚ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ½ĞµĞ³Ğ¾.
    """
    # ĞŸĞ¾Ğ´Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ: Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    last_reg_subquery = (
        select(
            EventRegistration.user_id,
            func.max(EventRegistration.registration_date).label("last_reg_date")
        )
        .group_by(EventRegistration.user_id)
    ).alias("last_regs")

    # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ
    stmt = (
        select(User.full_name, User.telegram_username, Survey.created_at)
        .join(Survey, User.id == Survey.user_id)
        .outerjoin(last_reg_subquery, User.id == last_reg_subquery.c.user_id)
        .where(
            (Survey.passed == True) &
            (
                (last_reg_subquery.c.last_reg_date == None) |
                (Survey.created_at > last_reg_subquery.c.last_reg_date)
            )
        )
        # Ğ£Ğ±ĞµĞ´Ğ¸Ğ¼ÑÑ, Ñ‡Ñ‚Ğ¾ Ğ±ĞµÑ€ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğ¸ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ° Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        .distinct(User.id)
        .order_by(User.id, Survey.created_at.desc())
    )

    result = await session.execute(stmt)
    return [
        {
            "full_name": row.full_name,
            "username": row.telegram_username,
            "survey_date": row.created_at
        }
        for row in result
    ]

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/analytics_requests.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/engine.py ---

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from bot.config_reader import config
from bot.db.models import Base

engine = create_async_engine(
    url=config.database_url,
    echo=False 
)

async_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def create_db_and_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/engine.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/event_requests.py ---

import datetime
from sqlalchemy import select, func, delete, or_
from sqlalchemy.ext.asyncio import AsyncSession
from .models import User, Event, EventRegistration, Donation, MedicalWaiver
from sqlalchemy.orm import joinedload
from bot.utils.text_messages import Text

async def get_active_events(session: AsyncSession) -> list[Event]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ."""
    stmt = (
        select(Event)
        .where(Event.is_active == True)
        .order_by(Event.event_datetime.desc())
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_active_events_for_user(session: AsyncSession, user_id: int) -> list[Event]:
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ, Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Ñ‚Ğµ, Ğ½Ğ° ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¾Ğ½ ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½,
    Ğ´Ğ°Ğ¶Ğµ ĞµÑĞ»Ğ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° Ğ½Ğ¸Ñ… Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°.
    """
    user_registrations_subquery = select(EventRegistration.event_id).where(EventRegistration.user_id == user_id)
    stmt = (
        select(Event)
        .where(
            Event.is_active == True,
            Event.event_datetime >= datetime.datetime.now(),
            or_(
                Event.registration_is_open == True,
                Event.id.in_(user_registrations_subquery)
            )
        )
        .order_by(Event.event_datetime)
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_upcoming_events(session: AsyncSession) -> list[Event]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ²ÑĞµ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ (Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½ĞºĞ¸)."""
    stmt = (
        select(Event)
        .where(
            Event.is_active == True,
            Event.event_datetime >= datetime.datetime.now()
        )
        .order_by(Event.event_datetime)
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_event_by_id(session: AsyncSession, event_id: int) -> Event | None:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ¿Ğ¾ ĞµĞ³Ğ¾ ID."""
    stmt = select(Event).options(joinedload(Event.blood_center)).where(Event.id == event_id)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def get_today_event(session: AsyncSession) -> Event | None:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ."""
    today = datetime.date.today()
    stmt = (
        select(Event)
        .where(
            Event.is_active == True,
            func.date(Event.event_datetime) == today
        )
    )
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def check_registration_eligibility(session: AsyncSession, user: User, event: Event) -> tuple[bool, str]:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ."""
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ°Ñ‚Ñƒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ´Ğ»Ñ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ Ñ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°Ğ¼Ğ¸
    event_date = event.event_datetime.date()

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° 1: Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ
    if not event.registration_is_open:
        return False, "Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° ÑÑ‚Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°."

    existing_registration = await find_specific_registration(session, user.id, event.id)
    if existing_registration:
        return False, f"Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ½Ğ° ÑÑ‚Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ ({event.name})."

    reg_count = await session.scalar(select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event.id))
    if reg_count >= event.participant_limit:
        return False, f"Ğ”Ğ¾ÑÑ‚Ğ¸Ğ³Ğ½ÑƒÑ‚ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² ({event.participant_limit})."

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° 2: Ğ¡ÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹ Ğ¸Ğ· Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ MedicalWaiver
    active_waiver_stmt = select(MedicalWaiver).where(
        MedicalWaiver.user_id == user.id,
        MedicalWaiver.end_date >= event_date
    ).order_by(MedicalWaiver.end_date.desc()).limit(1)
    active_waiver = (await session.execute(active_waiver_stmt)).scalar_one_or_none()
    if active_waiver:
        return False, f"Ğ£ Ğ²Ğ°Ñ Ğ´ĞµĞ¹ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ´Ğ¾ {active_waiver.end_date.strftime('%d.%m.%Y')}. ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: {active_waiver.reason}."

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° 3: ĞŸĞ¾Ñ‚ĞµĞ½Ñ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹ Ğ¾Ñ‚ Ğ”Ğ Ğ£Ğ“Ğ˜Ğ¥ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ñ… Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¹
    future_registrations_stmt = (
        select(EventRegistration)
        .join(EventRegistration.event)
        .where(
            EventRegistration.user_id == user.id,
            EventRegistration.status == 'registered',
            Event.event_datetime < event.event_datetime
        )
        .options(joinedload(EventRegistration.event))
        .order_by(Event.event_datetime)
    )
    future_registrations = (await session.execute(future_registrations_stmt)).scalars().all()

    for reg in future_registrations:
        registered_event = reg.event
        if registered_event.donation_type == 'whole_blood':
            interval = 90 if user.gender == 'female' else 60
        else:
            interval = 14

        potential_waiver_end_date = registered_event.event_datetime.date() + datetime.timedelta(days=interval)

        if event_date <= potential_waiver_end_date:
            return False, (f"Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ½ĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ°. Ğ£ Ğ²Ğ°Ñ Ğ·Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ "
                           f"Â«{registered_event.name}Â» Ğ½Ğ° {registered_event.event_datetime.strftime('%d.%m.%Y')}, "
                           f"Ğ¿Ğ¾ÑĞ»Ğµ ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ Ğ±ÑƒĞ´ĞµÑ‚ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´.")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° 4: Ğ“Ğ¾Ğ´Ğ¾Ğ²Ğ¾Ğ¹ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹ (Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ñ… Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¹)
    donation_type = event.donation_type
    
    # Ğ¡Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ ĞŸĞ ĞĞ¨Ğ•Ğ”Ğ¨Ğ˜Ğ• Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸
    past_donations_stmt = select(func.count(Donation.id)).where(
        Donation.user_id == user.id,
        Donation.donation_type == donation_type
    )
    past_donations_count = (await session.execute(past_donations_stmt)).scalar_one()

    # Ğ¡Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ‘Ğ£Ğ”Ğ£Ğ©Ğ˜Ğ• Ğ·Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ñ‚Ğ°ĞºĞ¾Ğ³Ğ¾ Ğ¶Ğµ Ñ‚Ğ¸Ğ¿Ğ°
    future_registrations_stmt = (
        select(func.count(EventRegistration.id))
        .join(Event)
        .where(
            EventRegistration.user_id == user.id,
            EventRegistration.status == 'registered',
            Event.donation_type == donation_type
        )
    )
    future_registrations_count = (await session.execute(future_registrations_stmt)).scalar_one()

    total_committed_donations = past_donations_count + future_registrations_count
    limit = 0
    limit_reason = ""

    if donation_type == 'whole_blood':
        limit = 4 if user.gender == 'female' else 5
        limit_reason = (f"Ğ’Ñ‹ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ»Ğ¸ Ğ³Ğ¾Ğ´Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ° ({limit}) Ğ½Ğ° ÑĞ´Ğ°Ñ‡Ñƒ Ñ†ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ ĞºÑ€Ğ¾Ğ²Ğ¸, "
                        f"ÑƒÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ñ Ğ¿Ñ€Ğ¾ÑˆĞ»Ñ‹Ğµ Ğ¸ Ğ·Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸.")
    elif donation_type in ['plasma', 'platelets', 'erythrocytes']:
        limit = 12
        limit_reason = (f"Ğ’Ñ‹ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ»Ğ¸ Ğ³Ğ¾Ğ´Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ° ({limit}) Ğ½Ğ° ÑĞ´Ğ°Ñ‡Ñƒ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ², "
                        f"ÑƒÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ñ Ğ¿Ñ€Ğ¾ÑˆĞ»Ñ‹Ğµ Ğ¸ Ğ·Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸.")

    if limit > 0 and total_committed_donations >= limit:
        return False, limit_reason

    return True, "Ğ’ÑĞµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ñ‹."


async def add_event_registration(session: AsyncSession, user_id: int, event_id: int) -> EventRegistration:
    """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµÑ‚ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ."""
    registration = EventRegistration(user_id=user_id, event_id=event_id)
    session.add(registration)
    await session.flush()

    event = await session.get(Event, event_id)
    if event:
        reg_count_stmt = select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event_id)
        reg_count = (await session.execute(reg_count_stmt)).scalar_one()
        if reg_count >= event.participant_limit:
            event.registration_is_open = False
            
    await session.commit()
    return registration

async def find_specific_registration(session: AsyncSession, user_id: int, event_id: int) -> EventRegistration | None:
    """ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½ÑƒÑ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ."""
    stmt = select(EventRegistration).options(
        joinedload(EventRegistration.event)
    ).where(
        EventRegistration.user_id == user_id,
        EventRegistration.event_id == event_id,
        EventRegistration.status == 'registered'
    )
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def confirm_donation_transaction(session: AsyncSession, user: User, registration: EventRegistration) -> tuple[int, datetime.date]:
    """ĞŸÑ€Ğ¾Ğ²Ğ¾Ğ´Ğ¸Ñ‚ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸: Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ÑĞµÑ‚ Ğ±Ğ°Ğ»Ğ»Ñ‹, ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´."""
    event = await session.get(Event, registration.event_id)
    event_date = event.event_datetime.date() # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ°Ñ‚Ñƒ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ¸ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°
            
    points_to_award = event.points_per_donation

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸
    donation = Donation(
        user_id=user.id,
        event_id=event.id,
        donation_date=event_date,
        donation_type=event.donation_type,
        points_awarded=points_to_award
    )
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğ¹ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´
    days_waiver = (90 if user.gender == 'female' else 60) if event.donation_type == 'whole_blood' else 14
    end_date = event_date + datetime.timedelta(days=days_waiver)
    russian_donation_type = Text.DONATION_TYPE_RU.get(event.donation_type, event.donation_type)
    waiver = MedicalWaiver(
        user_id=user.id,
        start_date=event_date,
        end_date=end_date,
        reason=f"Ğ¡Ğ´Ğ°Ñ‡Ğ° Â«{russian_donation_type}Â»",
        created_by='system'
    )

    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ
    user.points += points_to_award
    registration.status = 'attended'

    session.add_all([donation, waiver])
    await session.commit()
    return points_to_award, end_date

async def cancel_registration(session: AsyncSession, user_id: int, event_id: int) -> bool:
    """ĞÑ‚Ğ¼ĞµĞ½ÑĞµÑ‚ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ."""
    stmt = delete(EventRegistration).where(
        EventRegistration.user_id == user_id,
        EventRegistration.event_id == event_id
    )
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/event_requests.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/info_requests.py ---

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from .models import InfoText

async def get_info_text(session: AsyncSession, section_key: str) -> str | None:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ñ‚ĞµĞºÑÑ‚ Ğ¸Ğ½Ñ„Ğ¾-Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ° Ğ¿Ğ¾ ĞºĞ»ÑÑ‡Ñƒ."""
    text_obj = await session.get(InfoText, section_key)
    return text_obj.section_text if text_obj else "Ğ Ğ°Ğ·Ğ´ĞµĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½."

async def get_all_info_sections(session: AsyncSession) -> list[InfoText]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ²ÑĞµ Ğ¸Ğ½Ñ„Ğ¾-Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ñ‹ Ğ´Ğ»Ñ Ğ¼ĞµĞ½Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ."""
    result = await session.execute(select(InfoText).order_by(InfoText.section_key))
    return result.scalars().all()

async def update_info_text(session: AsyncSession, section_key: str, new_text: str):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ Ñ‚ĞµĞºÑÑ‚ Ğ¸Ğ½Ñ„Ğ¾-Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ°."""
    stmt = (
        update(InfoText)
        .where(InfoText.section_key == section_key)
        .values(section_text=new_text)
    )
    await session.execute(stmt)
    await session.commit()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/info_requests.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/merch_requests.py ---

import math
from sqlalchemy import select, func
from sqlalchemy.orm import joinedload
from sqlalchemy.ext.asyncio import AsyncSession
from .models import User, MerchItem, MerchOrder

async def get_merch_page(session: AsyncSession, page: int = 1) -> tuple[MerchItem | None, int]:
    page_size = 1
    offset = (page - 1) * page_size
    total_count_stmt = select(func.count(MerchItem.id)).where(MerchItem.is_available == True)
    total_items = (await session.execute(total_count_stmt)).scalar_one()
    
    if total_items == 0:
        return None, 0
    item_stmt = select(MerchItem).where(MerchItem.is_available == True).order_by(MerchItem.id).offset(offset).limit(page_size)
    item_result = await session.execute(item_stmt)
    item = item_result.scalar_one_or_none()
    
    return item, total_items

async def get_merch_item_by_id(session: AsyncSession, item_id: int) -> MerchItem | None:
    return await session.get(MerchItem, item_id)

async def create_merch_order(session: AsyncSession, user: User, item: MerchItem) -> tuple[bool, str]:
    if user.points < item.price:
        return False, "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²."

    user.points -= item.price
    order = MerchOrder(user_id=user.id, item_id=item.id)
    session.add(order)
    return True, f"ĞŸĞ¾ĞºÑƒĞ¿ĞºĞ° ÑĞ¾Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°! Ğ’Ğ°Ñˆ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ: {user.points} Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²."

async def get_user_orders(session: AsyncSession, user_id: int) -> list[MerchOrder]:
    stmt = select(MerchOrder).options(joinedload(MerchOrder.item)).where(MerchOrder.user_id == user_id).order_by(MerchOrder.order_date.desc())
    result = await session.execute(stmt)
    return result.scalars().all()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/merch_requests.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/models.py ---

import datetime
from typing import List
from sqlalchemy import (
    String, BigInteger, ForeignKey,
    Integer, Boolean, DateTime, Date, Text, func, Float, JSON
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship

class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = 'users'
    id: Mapped[int] = mapped_column(primary_key=True)
    phone_number: Mapped[str] = mapped_column(String(20), unique=True, nullable=False, index=True)
    telegram_id: Mapped[int] = mapped_column(BigInteger, unique=True, nullable=False, index=True)
    telegram_username: Mapped[str] = mapped_column(String(255), nullable=True, index=True)
    full_name: Mapped[str] = mapped_column(String(255), index=True)
    university: Mapped[str] = mapped_column(String(100), nullable=True, index=True)
    faculty: Mapped[str] = mapped_column(String(100), nullable=True)
    study_group: Mapped[str] = mapped_column(String(50), nullable=True)
    gender: Mapped[str] = mapped_column(String(10), nullable=True)
    points: Mapped[int] = mapped_column(Integer, default=0)
    role: Mapped[str] = mapped_column(String(50), default='student', index=True)
    is_blocked: Mapped[bool] = mapped_column(Boolean, default=False)
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    category: Mapped[str] = mapped_column(String(50), default='student', server_default='student')
    is_dkm_donor: Mapped[bool] = mapped_column(Boolean, default=False, server_default='f')
    consent_given: Mapped[bool] = mapped_column(Boolean, default=False, server_default='f')
    graduation_year: Mapped[int] = mapped_column(Integer, nullable=True)

    donations: Mapped[List["Donation"]] = relationship(back_populates="user")
    registrations: Mapped[List["EventRegistration"]] = relationship(back_populates="user", cascade="all, delete-orphan")
    waivers: Mapped[List["MedicalWaiver"]] = relationship(back_populates="user")
    orders: Mapped[List["MerchOrder"]] = relationship(foreign_keys="MerchOrder.user_id", back_populates="user", cascade="all, delete-orphan")
    blocks_given: Mapped[List["UserBlock"]] = relationship(foreign_keys="UserBlock.admin_id", back_populates="admin")
    blocks_received: Mapped[List["UserBlock"]] = relationship(foreign_keys="UserBlock.user_id", back_populates="blocked_user")



class Event(Base):
    __tablename__ = 'events'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255))
    event_datetime: Mapped[datetime.datetime] = mapped_column(DateTime)
    location: Mapped[str] = mapped_column(Text)
    blood_center_id: Mapped[int] = mapped_column(ForeignKey('blood_centers.id'), nullable=True)
    
    latitude: Mapped[float] = mapped_column(Float, nullable=True)
    longitude: Mapped[float] = mapped_column(Float, nullable=True)
    donation_type: Mapped[str] = mapped_column(String(50))
    points_per_donation: Mapped[int] = mapped_column(Integer)
    participant_limit: Mapped[int] = mapped_column(Integer)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    registration_is_open: Mapped[bool] = mapped_column(Boolean, default=True, server_default='t')

    blood_center: Mapped["BloodCenter"] = relationship(back_populates="events")
    registrations: Mapped[List["EventRegistration"]] = relationship(back_populates="event")
    feedbacks: Mapped[List["Feedback"]] = relationship(back_populates="event")


class EventRegistration(Base):
    __tablename__ = 'event_registrations'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'), index=True)
    status: Mapped[str] = mapped_column(String(50), default='registered')
    registration_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

    user: Mapped["User"] = relationship(back_populates="registrations")
    event: Mapped["Event"] = relationship(back_populates="registrations")

class Donation(Base):
    __tablename__ = 'donations'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'), nullable=True, index=True)
    donation_date: Mapped[datetime.date] = mapped_column(Date)
    donation_type: Mapped[str] = mapped_column(String(50))
    points_awarded: Mapped[int] = mapped_column(Integer)
    feedback_requested: Mapped[bool] = mapped_column(Boolean, default=False, server_default='f', nullable=False)

    user: Mapped["User"] = relationship(back_populates="donations")
    event: Mapped["Event"] = relationship()
    
class Feedback(Base):
    __tablename__ = 'feedbacks'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'))
    
    well_being_score: Mapped[int] = mapped_column(Integer, nullable=True) # 1-5
    well_being_comment: Mapped[str] = mapped_column(Text, nullable=True)
    
    organization_score: Mapped[int] = mapped_column(Integer, nullable=True) # 1-10
    what_liked: Mapped[str] = mapped_column(Text, nullable=True)
    what_disliked: Mapped[str] = mapped_column(Text, nullable=True)
    other_suggestions: Mapped[str] = mapped_column(Text, nullable=True)
    
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

    user: Mapped["User"] = relationship()
    event: Mapped["Event"] = relationship(back_populates="feedbacks")

class MedicalWaiver(Base):
    __tablename__ = 'medical_waivers'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    start_date: Mapped[datetime.date] = mapped_column(Date)
    end_date: Mapped[datetime.date] = mapped_column(Date)
    reason: Mapped[str] = mapped_column(Text)
    created_by: Mapped[str] = mapped_column(String(50))

    user: Mapped["User"] = relationship(back_populates="waivers")

class MerchItem(Base):
    __tablename__ = 'merch_items'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255))
    description: Mapped[str] = mapped_column(Text)
    price: Mapped[int] = mapped_column(Integer)
    photo_file_id: Mapped[str] = mapped_column(String(255))
    is_available: Mapped[bool] = mapped_column(Boolean, default=True)

    orders: Mapped[List["MerchOrder"]] = relationship(back_populates="item")

class MerchOrder(Base):
    __tablename__ = 'merch_orders'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    item_id: Mapped[int] = mapped_column(ForeignKey('merch_items.id'))
    order_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    status: Mapped[str] = mapped_column(String(50), default='pending_pickup')
    completed_by_admin_id: Mapped[int] = mapped_column(ForeignKey('users.id'), nullable=True)
    completion_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), nullable=True)

    user: Mapped["User"] = relationship(foreign_keys=[user_id], back_populates="orders")
    item: Mapped["MerchItem"] = relationship(back_populates="orders")
    completed_by_admin: Mapped["User"] = relationship(foreign_keys=[completed_by_admin_id])


class UserBlock(Base):
    __tablename__ = 'user_blocks'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    admin_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    block_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    reason: Mapped[str] = mapped_column(Text)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    
    blocked_user: Mapped["User"] = relationship(foreign_keys=[user_id], back_populates="blocks_received")
    admin: Mapped["User"] = relationship(foreign_keys=[admin_id], back_populates="blocks_given")
    
class Survey(Base):
    __tablename__ = 'surveys'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    passed: Mapped[bool] = mapped_column(Boolean, nullable=False)

    # ĞĞ±Ñ‰Ğ¸Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹
    age: Mapped[str] = mapped_column(String(50), nullable=True)
    weight: Mapped[str] = mapped_column(String(50), nullable=True)
    health_issues_last_month: Mapped[str] = mapped_column(String(50), nullable=True)

    # ĞĞ¾Ğ²Ñ‹Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¸Ğ· Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹
    symptoms: Mapped[str] = mapped_column(String(50), nullable=True) # ĞĞ Ğ’Ğ˜, Ğ°Ğ½Ğ³Ğ¸Ğ½Ğ°, Ğ³Ñ€Ğ¸Ğ¿Ğ¿
    pressure: Mapped[str] = mapped_column(String(50), nullable=True)
    hemoglobin_level: Mapped[str] = mapped_column(String(50), nullable=True)

    # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğº Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸
    diet_followed: Mapped[str] = mapped_column(String(50), nullable=True)
    alcohol_last_48h: Mapped[str] = mapped_column(String(50), nullable=True)
    medication_last_72h: Mapped[str] = mapped_column(String(50), nullable=True)
    sleep_last_night: Mapped[str] = mapped_column(String(50), nullable=True)
    smoking_last_hour: Mapped[str] = mapped_column(String(50), nullable=True)

    # ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ
    tattoo_or_piercing: Mapped[str] = mapped_column(String(50), nullable=True)
    tooth_removal_last_10_days: Mapped[str] = mapped_column(String(50), nullable=True)
    antibiotics_last_2_weeks: Mapped[str] = mapped_column(String(50), nullable=True)
    analgesics_last_3_days: Mapped[str] = mapped_column(String(50), nullable=True)

    # ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ
    has_hiv_or_hepatitis: Mapped[str] = mapped_column(String(50), nullable=True)
    has_cancer_or_blood_disease: Mapped[str] = mapped_column(String(50), nullable=True)
    has_chronic_disease: Mapped[str] = mapped_column(String(50), nullable=True)

    # Ğ¡Ñ‚Ğ°Ñ€Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ¹ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ (ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ñ‹)
    answers_json: Mapped[dict] = mapped_column(JSON, nullable=True)
    verdict_text: Mapped[str] = mapped_column(Text, nullable=True)
    
    user: Mapped["User"] = relationship()
    
    
class InfoText(Base):
    __tablename__ = 'info_texts'
    section_key: Mapped[str] = mapped_column(String(50), primary_key=True)
    section_title: Mapped[str] = mapped_column(String(100))
    section_text: Mapped[str] = mapped_column(Text)
    
class Question(Base):
    __tablename__ = 'questions'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    
    question_text: Mapped[str] = mapped_column(Text)
    answer_text: Mapped[str] = mapped_column(Text, nullable=True)
    
    status: Mapped[str] = mapped_column(String(50), default='unanswered', index=True) # unanswered, answered
    
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    answered_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), nullable=True)
    answered_by_admin_id: Mapped[int] = mapped_column(ForeignKey('users.id'), nullable=True)

    user: Mapped["User"] = relationship(foreign_keys=[user_id])
    answered_by_admin: Mapped["User"] = relationship(foreign_keys=[answered_by_admin_id])
    
    
    
class NoShowReport(Base):
    __tablename__ = 'no_show_reports'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'), index=True)
    reason: Mapped[str] = mapped_column(String(100))
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    user: Mapped["User"] = relationship()
    event: Mapped["Event"] = relationship()
    
class BloodCenter(Base):
    __tablename__ = 'blood_centers'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)

    events: Mapped[List["Event"]] = relationship(back_populates="blood_center")


class Report(Base):
    __tablename__ = 'reports'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255))
    data: Mapped[dict] = mapped_column(JSON)
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/models.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/qa_management.py ---

from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import question_requests, user_requests
from bot.filters.role import RoleFilter
from bot.states.states import AnswerQuestion
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router(name="admin_qa_management")

@router.callback_query(F.data == "admin_answer_questions", RoleFilter('admin'))
async def show_unanswered_questions(callback: types.CallbackQuery, session: AsyncSession):
    questions = await question_requests.get_unanswered_questions(session)
    if not questions:
        await callback.answer("ĞĞ¾Ğ²Ñ‹Ñ… Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ½ĞµÑ‚.", show_alert=True)
        return

    builder = types.InlineKeyboardBuilder()
    for q in questions:
        builder.row(types.InlineKeyboardButton(
            text=f"ĞÑ‚ {q.user.full_name}: {q.question_text[:30]}...",
            callback_data=f"answer_q_{q.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_panel"))
    
    await callback.message.edit_text(
        "<b>ĞĞµĞ¾Ñ‚Ğ²ĞµÑ‡ĞµĞ½Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹:</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¸Ñ‚ÑŒ:",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data.startswith("answer_q_"), RoleFilter('admin'))
async def start_answering_question(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    question_id = int(callback.data.split("_")[-1])
    question = await session.get(question_requests.Question, question_id)
    if not question:
        await callback.answer("Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.", show_alert=True)
        return
        
    await state.set_state(AnswerQuestion.awaiting_answer)
    await state.update_data(question_id=question.id, user_to_answer_id=question.user.telegram_id)
    
    await callback.message.edit_text(
        f"<b>Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¾Ñ‚:</b> {question.user.full_name}\n"
        f"<b>Ğ¢ĞµĞºÑÑ‚ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°:</b>\n<i>{Text.escape_html(question.question_text)}</i>\n\n"
        f"<b>Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ¾Ñ‚Ğ²ĞµÑ‚:</b>"
    )
    await callback.answer()

@router.message(AnswerQuestion.awaiting_answer)
async def process_answer(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    question_id = data.get("question_id")
    user_to_answer_id = data.get("user_to_answer_id")
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    
    await question_requests.answer_question(session, question_id, message.text, admin_user.id)
    
    question = await session.get(question_requests.Question, question_id)

    try:
        await bot.send_message(
            chat_id=user_to_answer_id,
            text=(
                f"ğŸ“¨ <b>ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ½Ğ° Ğ²Ğ°Ñˆ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ!</b>\n\n"
                f"<b>Ğ’Ğ°Ñˆ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ:</b>\n<i>{Text.escape_html(question.question_text)}</i>\n\n"
                f"<b>ĞÑ‚Ğ²ĞµÑ‚ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²:</b>\n{Text.escape_html(message.text)}"
            )
        )
    except Exception as e:
        await message.answer(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ. ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")

    await state.clear()
    await message.answer("âœ… ĞÑ‚Ğ²ĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.", reply_markup=inline.get_back_to_admin_panel_keyboard())

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/qa_management.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/question_requests.py ---

import datetime
from sqlalchemy import select, update
from sqlalchemy.orm import joinedload
from sqlalchemy.ext.asyncio import AsyncSession
from .models import Question, User

async def create_question(session: AsyncSession, user_id: int, question_text: str):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
    new_question = Question(user_id=user_id, question_text=question_text)
    session.add(new_question)
    await session.commit()

async def get_unanswered_questions(session: AsyncSession) -> list[Question]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ½ĞµĞ¾Ñ‚Ğ²ĞµÑ‡ĞµĞ½Ğ½Ñ‹Ñ… Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸ĞµĞ¹ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ."""
    stmt = (
        select(Question)
        .options(joinedload(Question.user))
        .where(Question.status == 'unanswered')
        .order_by(Question.created_at)
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def answer_question(session: AsyncSession, question_id: int, answer_text: str, admin_id: int):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ½Ğ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ ĞµĞ³Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑ."""
    stmt = (
        update(Question)
        .where(Question.id == question_id)
        .values(
            answer_text=answer_text,
            status='answered',
            answered_at=datetime.datetime.now(),
            answered_by_admin_id=admin_id
        )
    )
    await session.execute(stmt)
    await session.commit()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/question_requests.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/db/user_requests.py ---

import datetime
from sqlalchemy import select, func, update, delete 
from sqlalchemy.ext.asyncio import AsyncSession
from .models import User, Donation, MedicalWaiver
from sqlalchemy import and_, or_, not_
from sqlalchemy.orm import aliased, joinedload 
from .models import User, Donation, MedicalWaiver, Event, Survey
import logging
logger = logging.getLogger(__name__)


async def update_user_credentials(session: AsyncSession, user_id: int, new_tg_id: int, new_username: str | None):
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Telegram ID Ğ¸ username
    stmt = update(User).where(User.id == user_id).values(
        telegram_id=new_tg_id,
        telegram_username=new_username
    )
    await session.execute(stmt)
    await session.commit()


async def get_user_by_phone(session: AsyncSession, phone: str) -> User | None:
    # ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ñƒ
    stmt = select(User).where(User.phone_number == phone)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def get_user_by_tg_id(session: AsyncSession, tg_id: int) -> User | None:
    # ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ Telegram ID
    stmt = select(User).where(User.telegram_id == tg_id)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

# --- Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ•: Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ commit Ğ¸Ğ· ÑÑ‚Ğ¾Ğ¹ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ ---
async def add_user(session: AsyncSession, data: dict) -> User:
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user = User(**data)
    session.add(user)
    # await session.commit()  # <-- Ğ£Ğ‘Ğ˜Ğ ĞĞ•Ğœ Ğ­Ğ¢Ğ£ Ğ¡Ğ¢Ğ ĞĞšĞ£
    return user
# --- ĞšĞĞĞ•Ğ¦ Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ¯ ---

async def update_user_tg_id(session: AsyncSession, user_id: int, new_tg_id: int):
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Telegram ID
    stmt = update(User).where(User.id == user_id).values(telegram_id=new_tg_id)
    await session.execute(stmt)
    await session.commit()
    
async def update_user_profile(session: AsyncSession, user_id: int, data: dict):
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    stmt = update(User).where(User.id == user_id).values(**data)
    await session.execute(stmt)
    await session.commit()

async def get_user_profile_info(session: AsyncSession, user_id: int) -> dict | None:
    user = await session.get(User, user_id)
    if not user:
        return None

    stmt_last_donation = (
        select(Donation)
        .options(joinedload(Donation.event))
        .where(Donation.user_id == user.id)
        .order_by(Donation.donation_date.desc())
        .limit(1)
    )
    last_donation_obj = (await session.execute(stmt_last_donation)).scalar_one_or_none()

    today = datetime.date.today()
    stmt_waiver = select(MedicalWaiver.end_date).where(MedicalWaiver.user_id == user.id, MedicalWaiver.end_date >= today).order_by(MedicalWaiver.end_date.desc()).limit(1)
    active_waiver_end_date = (await session.execute(stmt_waiver)).scalar_one_or_none()
    
    next_possible_donation = today
    if active_waiver_end_date:
        next_possible_donation = active_waiver_end_date + datetime.timedelta(days=1)
    
    if last_donation_obj:
        last_date = last_donation_obj.donation_date
        last_type = last_donation_obj.donation_type
        if last_type == 'whole_blood':
            interval = 90 if user.gender == 'female' else 60
            possible_date = last_date + datetime.timedelta(days=interval)
        else:
            interval = 14
            possible_date = last_date + datetime.timedelta(days=interval)
        next_possible_donation = max(next_possible_donation, possible_date)

    total_donations = await session.scalar(select(func.count(Donation.id)).where(Donation.user_id == user.id))

    return {
        "user": user,
        "total_donations": total_donations,
        "next_possible_donation": next_possible_donation,
        "last_donation": last_donation_obj 
    }

async def get_user_donation_history(session: AsyncSession, user_id: int) -> list[Donation]:
    # Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    stmt = select(Donation).where(Donation.user_id == user_id).order_by(Donation.donation_date.desc())
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_user_active_waivers(session: AsyncSession, user_id: int) -> list[MedicalWaiver]:
    # ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    stmt = select(MedicalWaiver).where(
        MedicalWaiver.user_id == user_id,
        MedicalWaiver.end_date >= datetime.date.today()
    ).order_by(MedicalWaiver.end_date)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_user_by_id(session: AsyncSession, user_id: int) -> User | None:
    # ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ ID
    return await session.get(User, user_id)

async def get_all_users(session: AsyncSession) -> list[User]:
    # Ğ’ÑĞµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸
    stmt = select(User).order_by(User.full_name)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_users_for_event_notification(session: AsyncSession, event: Event) -> list[User]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ±Ñ‹Ñ‚ÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ñ‹ Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¸.
    Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°Ğ¼, Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ°Ğ¼ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸ Ğ¸ Ğ³Ğ¾Ğ´Ğ¾Ğ²Ñ‹Ğ¼ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ°Ğ¼.
    """
    event_date_only = event.event_datetime.date()

    # 1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹, Ñƒ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ² Ğ½Ğ° Ğ´Ğ°Ñ‚Ñƒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ
    active_waiver_subquery = select(MedicalWaiver.user_id).where(MedicalWaiver.end_date >= event_date_only).distinct()
    query = select(User).where(not_(User.id.in_(active_waiver_subquery)))
    initial_users = (await session.execute(query)).scalars().all()
    
    final_users_to_notify = []
    one_year_ago = event_date_only - datetime.timedelta(days=365)
    
    for user in initial_users:
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ·Ğ° Ğ³Ğ¾Ğ´
        donations_stmt = select(Donation).where(
            Donation.user_id == user.id,
            Donation.donation_date >= one_year_ago
        ).order_by(Donation.donation_date.desc())
        user_donations = (await session.execute(donations_stmt)).scalars().all()

        # --- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° 1: Ğ“Ğ¾Ğ´Ğ¾Ğ²Ñ‹Ğµ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹ ---
        donations_of_event_type = [d for d in user_donations if d.donation_type == event.donation_type]
        
        if event.donation_type == 'whole_blood':
            limit = 4 if user.gender == 'female' else 5
            if len(donations_of_event_type) >= limit:
                continue
        else: # Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ²
            limit = 12
            if len(donations_of_event_type) >= limit:
                continue

        # --- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° 2: Ğ˜Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ñ‹ ---
        if not user_donations:
            final_users_to_notify.append(user)
            continue
            
        # ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ 2.1: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ¾Ñ‚ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¹ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ›Ğ®Ğ‘ĞĞ“Ğ Ñ‚Ğ¸Ğ¿Ğ°
        last_donation = user_donations[0]
        
        if last_donation.donation_type == 'whole_blood':
            interval = 90 if user.gender == 'female' else 60
        else:
            interval = 14
        
        # Ğ”Ğ°Ñ‚Ğ°, ĞºĞ¾Ğ³Ğ´Ğ° Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ¾Ñ‚ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¹ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ·Ğ°ĞºĞ°Ğ½Ñ‡Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ.
        waiver_end_date_from_last = last_donation.donation_date + datetime.timedelta(days=interval)
        
        # Ğ•ÑĞ»Ğ¸ Ğ´Ğ°Ñ‚Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ¼ĞµĞ½ÑŒÑˆĞµ Ğ¸Ğ»Ğ¸ Ñ€Ğ°Ğ²Ğ½Ğ° Ğ´Ğ°Ñ‚Ğµ Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ñ Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°, Ñ‚Ğ¾ ÑĞ´Ğ°Ğ²Ğ°Ñ‚ÑŒ Ğ½ĞµĞ»ÑŒĞ·Ñ.
        if event_date_only <= waiver_end_date_from_last:
            continue

        # ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ 2.2: Ğ•ÑĞ»Ğ¸ Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ¾Ğ¸Ñ‚ ÑĞ´Ğ°Ñ‡Ğ° Ğ¦Ğ•Ğ›Ğ¬ĞĞĞ™ ĞšĞ ĞĞ’Ğ˜, Ğ½ÑƒĞ¶Ğ½Ğ° Ğ´Ğ¾Ğ¿. Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
        if event.donation_type == 'whole_blood':
            donations_whole_blood = [d for d in user_donations if d.donation_type == 'whole_blood']
            if donations_whole_blood:
                last_whole_blood_donation = donations_whole_blood[0]
                interval_whole = 90 if user.gender == 'female' else 60
                
                waiver_end_date_from_last_whole = last_whole_blood_donation.donation_date + datetime.timedelta(days=interval_whole)
                
                if event_date_only <= waiver_end_date_from_last_whole:
                    continue
        
        final_users_to_notify.append(user)
            
    return final_users_to_notify

async def get_users_for_mailing(session: AsyncSession, filters: dict) -> list[User]:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ Ğ½Ğ°Ğ±Ğ¾Ñ€Ğ° Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ¾Ğ².
    """
    stmt = select(User)
    
    # ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ¸Ñ…
    filters_to_apply = filters.copy()
    
    # Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ Ñ€Ğ¾Ğ»ÑĞ¼
    if 'role' in filters_to_apply:
        role_filter = filters_to_apply.pop('role') # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ¸ ÑƒĞ´Ğ°Ğ»ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ¿Ğ¾Ğ¿Ğ°ÑÑ‚ÑŒ Ğ² Ñ†Ğ¸ĞºĞ» Ğ½Ğ¸Ğ¶Ğµ
        if role_filter == 'volunteers':
            stmt = stmt.where(User.role.in_(['volunteer', 'admin', 'main_admin']))
        elif role_filter == 'admins':
            stmt = stmt.where(User.role.in_(['admin', 'main_admin']))
        # Ğ•ÑĞ»Ğ¸ role_filter == 'all', Ñ‚Ğ¾ Ğ½Ğ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ´ĞµĞ»Ğ°ĞµĞ¼, ÑÑ‚Ğ¾ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ

    # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹ Ğ¿Ğ¾ Ğ°Ñ‚Ñ€Ğ¸Ğ±ÑƒÑ‚Ğ°Ğ¼
    for key, value in filters_to_apply.items():
        if hasattr(User, key):
            stmt = stmt.where(getattr(User, key) == value)

    result = await session.execute(stmt.order_by(User.id))
    return result.scalars().all()


async def add_user_waiver(session: AsyncSession, user_id: int, end_date: datetime.date, reason: str):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ¾Ñ‚ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
    waiver = MedicalWaiver(
        user_id=user_id,
        start_date=datetime.date.today(),
        end_date=end_date,
        reason=reason,
        created_by='user' 
    )
    session.add(waiver)
    await session.commit()

async def delete_user_waiver(session: AsyncSession, waiver_id: int, user_id: int) -> bool:
    """
    Ğ£Ğ´Ğ°Ğ»ÑĞµÑ‚ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´, ĞµÑĞ»Ğ¸ Ğ¾Ğ½ Ğ±Ñ‹Ğ» ÑĞ¾Ğ·Ğ´Ğ°Ğ½ ÑÑ‚Ğ¸Ğ¼ Ğ¶Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼.
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ True Ğ² ÑĞ»ÑƒÑ‡Ğ°Ğµ ÑƒÑĞ¿ĞµÑ…Ğ°.
    """
    stmt = (
        delete(MedicalWaiver)
        .where(
            MedicalWaiver.id == waiver_id,
            MedicalWaiver.user_id == user_id,
            MedicalWaiver.created_by == 'user'
        )
    )
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0

async def check_recent_survey(session: AsyncSession, user_id: int) -> bool:
    """
    ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ» Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸Ğº Ğ·Ğ° Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 24 Ñ‡Ğ°ÑĞ°.
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ True, ĞµÑĞ»Ğ¸ Ğ´Ğ°, Ğ¸Ğ½Ğ°Ñ‡Ğµ False.
    """
    twenty_four_hours_ago = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(hours=24)
    
    stmt = (
        select(Survey)
        .where(
            Survey.user_id == user_id,
            Survey.passed == True,
            Survey.created_at >= twenty_four_hours_ago
        )
        .order_by(Survey.created_at.desc())
        .limit(1)
    )
    
    result = await session.execute(stmt)
    recent_survey = result.scalar_one_or_none()
    
    return recent_survey is not None


async def get_unlinked_user_by_fio(session: AsyncSession, full_name: str) -> User | None:
    """
    Ğ˜Ñ‰ĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ Ğ¤Ğ˜Ğ ÑÑ€ĞµĞ´Ğ¸ Ñ‚ĞµÑ…, Ñƒ ĞºĞ¾Ğ³Ğ¾ telegram_id <= 0.
    """
    stmt = select(User).where(
        User.full_name == full_name,
        User.telegram_id <= 0
    )
    result = await session.execute(stmt)
    return result.scalar_one_or_none()


async def is_profile_complete(session: AsyncSession, user_id: int) -> bool:
    """
    ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ²ÑĞµ Ğ»Ğ¸ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ² Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ñ‹.
    """
    user = await session.get(User, user_id)
    if not user:
        return False

    required_fields = ['full_name', 'phone_number', 'university', 'faculty', 'study_group', 'gender']
    for field in required_fields:
        if not getattr(user, field):
            return False
    return True

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/db/user_requests.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/filters/role.py ---

from typing import Union
from aiogram.filters import BaseFilter
from aiogram.types import Message, CallbackQuery
from bot.db import user_requests
from sqlalchemy.ext.asyncio import AsyncSession

ROLE_HIERARCHY = {
    'student': 0,
    'volunteer': 1,
    'admin': 2,
    'main_admin': 3
}

class RoleFilter(BaseFilter):
    def __init__(self, required_role: str):
        self.required_level = ROLE_HIERARCHY.get(required_role, 0)

    async def __call__(self, event: Union[Message, CallbackQuery], session: AsyncSession) -> bool:
        user = await user_requests.get_user_by_tg_id(session, event.from_user.id)
        if not user:
            return False
        
        if user.is_blocked:
            return False
            
        user_level = ROLE_HIERARCHY.get(user.role, 0)
        return user_level >= self.required_level

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/filters/role.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/__init__.py ---



--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/__init__.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/common.py ---

from aiogram import Router, F, types
from aiogram.filters import CommandStart, Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import any_state
from aiogram.types import ReplyKeyboardRemove
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.exceptions import TelegramBadRequest

from bot.db import user_requests
from bot.states.states import Registration
from bot.keyboards import reply, inline
from bot.utils.text_messages import Text
from bot.utils.graduation import calculate_graduation_year
from bot.filters.role import RoleFilter

ROLE_MENU_MAP = {
    'student': inline.get_student_main_menu,
    'volunteer': inline.get_volunteer_main_menu,
    'admin': inline.get_admin_main_menu,
    'main_admin': inline.get_main_admin_main_menu
}

router = Router()

# =============================================================================
# --- Ğ£ĞĞ˜Ğ’Ğ•Ğ Ğ¡ĞĞ›Ğ¬ĞĞĞ¯ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯ ĞĞ¢ĞŸĞ ĞĞ’ĞšĞ˜/Ğ Ğ•Ğ”ĞĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ ĞœĞ•ĞĞ® ---
# =============================================================================

async def send_or_edit_main_menu(
    event: types.Message | types.CallbackQuery, 
    session: AsyncSession, 
    welcome_text: str = None, 
    force_role: str = None
):
    """
    Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ¸Ğ»Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµĞ½Ñ ĞĞ”ĞĞ˜Ğœ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸ĞµĞ¼.
    """
    user = await user_requests.get_user_by_tg_id(session, event.from_user.id)
    message_to_handle = getattr(event, 'message', event)
    
    
    if not user:
        if isinstance(event, types.CallbackQuery):
            await event.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        else:
            await message_to_handle.answer(Text.WELCOME, reply_markup=reply.get_contact_keyboard())
        return

    if user.is_blocked:
        await message_to_handle.answer(Text.USER_BLOCKED_MESSAGE, reply_markup=ReplyKeyboardRemove())
        return

    if welcome_text:
        greeting = welcome_text
    elif force_role == 'student':
        greeting = Text.SWITCH_TO_DONOR_VIEW
    else:
        greeting = Text.WELCOME_BACK.format(name=user.full_name)

    combined_text = f"{greeting}\n\n{Text.MAIN_MENU_PROMPT}"
    effective_role = force_role if force_role else user.role
    menu_func = ROLE_MENU_MAP.get(effective_role, inline.get_student_main_menu)
    inline_kbd = menu_func(viewer_role=user.role)

    if isinstance(event, types.Message):
        await message_to_handle.answer(
            combined_text,
            reply_markup=inline_kbd,
            parse_mode="HTML"
        )
    elif isinstance(event, types.CallbackQuery):
        try:
            await message_to_handle.edit_text(combined_text, reply_markup=inline_kbd, parse_mode="HTML")
        except TelegramBadRequest as e:
            if "message is not modified" in str(e):
                await event.answer()
            else:
                await message_to_handle.delete()
                await message_to_handle.answer(combined_text, reply_markup=inline_kbd, parse_mode="HTML")
        await event.answer()


@router.message(F.text == "ğŸ  Ğ”Ğ¾Ğ¼Ğ¾Ğ¹")
@router.message(CommandStart())
async def cmd_start_or_home(message: types.Message, session: AsyncSession):
    await send_or_edit_main_menu(message, session)


@router.callback_query(F.data == "back_to_main_menu")
async def handle_back_to_main_menu(callback: types.CallbackQuery, session: AsyncSession):
    await send_or_edit_main_menu(callback, session)


@router.callback_query(F.data == "switch_to_donor_view")
async def handle_switch_to_donor_view(callback: types.CallbackQuery, session: AsyncSession):
    await send_or_edit_main_menu(callback, session, force_role='student')


# =============================================================================
# --- Ğ›ĞĞ“Ğ˜ĞšĞ Ğ Ğ•Ğ“Ğ˜Ğ¡Ğ¢Ğ ĞĞ¦Ğ˜Ğ˜ (Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯) ---
# =============================================================================

@router.message(F.contact)
async def handle_contact(message: types.Message, session: AsyncSession, state: FSMContext):
    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    if user:
        await send_or_edit_main_menu(message, session, welcome_text=Text.ALREADY_REGISTERED.format(name=user.full_name))
        return

    contact = message.contact
    phone_number = contact.phone_number
    if not phone_number.startswith('+'):
        phone_number = '+' + phone_number

    user_by_phone = await user_requests.get_user_by_phone(session, phone_number)
    if user_by_phone:
        if user_by_phone.is_blocked:
            await message.answer(Text.USER_BLOCKED_ON_AUTH, reply_markup=ReplyKeyboardRemove())
            return

        await user_requests.update_user_credentials(session, user_by_phone.id, message.from_user.id, message.from_user.username)
        await session.commit()

        if not await user_requests.is_profile_complete(session, user_by_phone.id):
            await message.answer("Ğ’Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ±Ñ‹Ğ» Ğ½Ğ°Ğ¹Ğ´ĞµĞ½, Ğ½Ğ¾ Ğ¾Ğ½ Ğ½Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ½. Ğ”Ğ°Ğ²Ğ°Ğ¹Ñ‚Ğµ ĞµĞ³Ğ¾ Ğ´Ğ¾Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ğ¼.")
            await state.update_data(
                phone_number=user_by_phone.phone_number,
                telegram_id=message.from_user.id,
                telegram_username=message.from_user.username
            )
            await state.set_state(Registration.awaiting_full_name)
            await message.answer(Text.GET_FULL_NAME)
        else:
            await send_or_edit_main_menu(message, session, welcome_text=Text.AUTH_SUCCESS.format(name=user_by_phone.full_name))
    else:
        await state.update_data(
            phone_number=phone_number,
            telegram_id=message.from_user.id,
            telegram_username=message.from_user.username
        )
        await message.answer(Text.START_REGISTRATION, reply_markup=ReplyKeyboardRemove())
        await message.answer(Text.GET_FULL_NAME)
        await state.set_state(Registration.awaiting_full_name)


@router.message(Registration.awaiting_full_name)
async def process_full_name(message: types.Message, state: FSMContext, session: AsyncSession):
    full_name = message.text.strip()

    allowed_chars = "Ğ°Ğ±Ğ²Ğ³Ğ´ĞµÑ‘Ğ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑ-"
    if not all(c.lower() in allowed_chars or c.isspace() for c in full_name):
        await message.answer(Text.FIO_VALIDATION_ERROR)
        return

    name_parts = full_name.split()
    if len(name_parts) < 2:
        await message.answer("ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ°Ğº Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ Ğ¤Ğ°Ğ¼Ğ¸Ğ»Ğ¸Ñ Ğ¸ Ğ˜Ğ¼Ñ.")
        return

    corrected_name = " ".join([part.strip().capitalize() for part in name_parts])

    user_by_fio = await user_requests.get_unlinked_user_by_fio(session, corrected_name)
    if user_by_fio:
        user_data = await state.get_data()
        await user_requests.update_user_credentials(session, user_by_fio.id, user_data['telegram_id'], user_data['telegram_username'])
        await session.commit()

        if not await user_requests.is_profile_complete(session, user_by_fio.id):
            await message.answer("Ğ’Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ±Ñ‹Ğ» Ğ½Ğ°Ğ¹Ğ´ĞµĞ½, Ğ½Ğ¾ Ğ¾Ğ½ Ğ½Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ½. Ğ”Ğ°Ğ²Ğ°Ğ¹Ñ‚Ğµ ĞµĞ³Ğ¾ Ğ´Ğ¾Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ğ¼.")
            await state.update_data(full_name=corrected_name)
            await message.answer(Text.GET_CATEGORY, reply_markup=inline.get_category_keyboard())
            await state.set_state(Registration.awaiting_category)
        else:
            await state.clear()
            await send_or_edit_main_menu(message, session,
                                           welcome_text=Text.AUTH_SUCCESS.format(name=user_by_fio.full_name))
        return

    await state.update_data(full_name=corrected_name)

    await message.answer(Text.GET_CATEGORY, reply_markup=inline.get_category_keyboard())
    await state.set_state(Registration.awaiting_category)


# --- ĞĞĞ’Ğ«Ğ™ Ğ¥Ğ•ĞĞ”Ğ›Ğ•Ğ : ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ ---
@router.callback_query(Registration.awaiting_category, F.data.startswith('category_'))
async def process_category(callback: types.CallbackQuery, state: FSMContext):
    category = callback.data.split('_', 1)[1]
    await state.update_data(category=category)

    if category == 'external':
        await state.update_data(university="Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğ¹ Ğ´Ğ¾Ğ½Ğ¾Ñ€", faculty="ĞĞµ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ğ¼Ğ¾", study_group="-")
        await callback.message.edit_text(Text.GET_GENDER, reply_markup=inline.get_gender_inline_keyboard())
        await state.set_state(Registration.awaiting_gender)
    elif category == 'student':
        await state.update_data(university="ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜")
        await callback.message.edit_text(Text.GET_FACULTY, reply_markup=inline.get_faculties_keyboard())
        await state.set_state(Registration.awaiting_faculty)
    elif category == 'employee':
        await state.update_data(university="ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", faculty="Ğ¡Ğ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸Ğº", study_group="-")
        await callback.message.edit_text(Text.GET_GENDER, reply_markup=inline.get_gender_inline_keyboard())
        await state.set_state(Registration.awaiting_gender)

    await callback.answer()




@router.callback_query(Registration.awaiting_faculty, F.data.startswith('faculty_'))
async def process_faculty(callback: types.CallbackQuery, state: FSMContext):
    faculty_name = callback.data.split('_', 1)[1]
    
    if faculty_name == 'Other':
        await callback.message.edit_text(Text.GET_CUSTOM_FACULTY)
        await state.set_state(Registration.awaiting_custom_faculty_name)
    else:
        await state.update_data(faculty=faculty_name)
        user_data = await state.get_data()
        if user_data.get("category") == "employee":
            await state.update_data(study_group="-")
            await callback.message.edit_text(Text.GET_GENDER, reply_markup=inline.get_gender_inline_keyboard())
            await state.set_state(Registration.awaiting_gender)
        else:
            await callback.message.edit_text(Text.FACULTY_SELECTED.format(faculty=faculty_name))
            await callback.message.answer(Text.GET_GROUP)
            await state.set_state(Registration.awaiting_study_group)
    
    await callback.answer()


@router.message(Registration.awaiting_custom_faculty_name)
async def process_custom_faculty_name(message: types.Message, state: FSMContext):
    await state.update_data(faculty=message.text)
    await message.answer(Text.GET_GROUP)
    await state.set_state(Registration.awaiting_study_group)


@router.message(Registration.awaiting_study_group)
async def process_study_group(message: types.Message, state: FSMContext):
    group_name = message.text.strip().lower()
    if group_name and group_name[0] not in ['Ğ±', 'Ñ', 'Ğ¼', 'Ğ°']:
        await message.answer(
            "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ÑƒÑ‡ĞµĞ±Ğ½Ğ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾.\n"
            "ĞŸĞµÑ€Ğ²Ğ°Ñ Ğ±ÑƒĞºĞ²Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ¸Ğ· ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ñ…: "
            "Ğ± - Ğ±Ğ°ĞºĞ°Ğ»Ğ°Ğ²Ñ€Ğ¸Ğ°Ñ‚, Ñ - ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ñ‚ĞµÑ‚, Ğ¼ - Ğ¼Ğ°Ğ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚ÑƒÑ€Ğ°, Ğ° - Ğ°ÑĞ¿Ğ¸Ñ€Ğ°Ğ½Ñ‚ÑƒÑ€Ğ°."
        )
        return

    await state.update_data(study_group=message.text)
    await message.answer(Text.GET_GENDER, reply_markup=inline.get_gender_inline_keyboard())
    await state.set_state(Registration.awaiting_gender)


@router.callback_query(Registration.awaiting_gender, F.data.startswith("gender_"))
async def process_gender(callback: types.CallbackQuery, state: FSMContext):
    gender = callback.data.split('_', 1)[1]
    gender_text = "ĞœÑƒĞ¶ÑĞºĞ¾Ğ¹" if gender == "male" else "Ğ–ĞµĞ½ÑĞºĞ¸Ğ¹"
    
    await callback.message.edit_text(Text.GENDER_SELECTED.format(gender=gender_text))
    await state.update_data(gender=gender)
    
    await callback.message.answer(
        Text.CONSENT_TEXT, 
        reply_markup=inline.get_consent_keyboard(),
        parse_mode="HTML"
    )
    await state.set_state(Registration.awaiting_consent)
    await callback.answer()



@router.callback_query(Registration.awaiting_consent, F.data == "consent_given")
async def process_consent(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    user_data = await state.get_data()
    telegram_id = user_data.get('telegram_id')

    existing_user = await user_requests.get_user_by_tg_id(session, telegram_id)

    if existing_user:
        update_data = {
            'full_name': user_data.get('full_name'),
            'university': user_data.get('university'),
            'faculty': user_data.get('faculty'),
            'study_group': user_data.get('study_group'),
            'gender': user_data.get('gender'),
            'graduation_year': calculate_graduation_year(user_data.get('study_group')),
        }
        await user_requests.update_user_profile(session, existing_user.id, update_data)
        user_to_greet = await user_requests.get_user_by_id(session, existing_user.id)
    else:
        user_data['consent_given'] = True
        user_data['graduation_year'] = calculate_graduation_year(user_data.get('study_group'))
        user_to_greet = await user_requests.add_user(session, user_data)

    await session.commit()
    await state.clear()

    await callback.message.delete()

    await callback.message.answer(
        text=f"{Text.REGISTRATION_COMPLETE.format(name=user_to_greet.full_name)}\n\n{Text.MAIN_MENU_PROMPT}",
        reply_markup=ROLE_MENU_MAP.get(user_to_greet.role, inline.get_student_main_menu)(
            viewer_role=user_to_greet.role)
    )

    await callback.message.answer(
        # text="Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ğ°Ğ¼ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ.",
        reply_markup=reply.get_home_keyboard()
    )

    await callback.answer()


# =============================================================================
# ĞŸĞ ĞĞ§Ğ˜Ğ• ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜
# =============================================================================

@router.message(Command("cancel"), StateFilter(any_state))
@router.callback_query(F.data == "cancel_fsm", StateFilter(any_state))
async def cancel_fsm_handler(event: types.Message | types.CallbackQuery, state: FSMContext, session: AsyncSession):
    current_state = await state.get_state()
    if current_state is None:
        if isinstance(event, types.CallbackQuery): await event.answer()
        return

    await state.clear()
    
    message_to_use = event.message if isinstance(event, types.CallbackQuery) else event
    
    if isinstance(event, types.CallbackQuery):
        await event.message.edit_text(Text.ACTION_CANCELLED)
    else:
        await event.answer(Text.ACTION_CANCELLED)
    
    await send_or_edit_main_menu(message_to_use, session)
    if isinstance(event, types.CallbackQuery):
        await event.answer()


@router.message(Command("secret_admin_123"), RoleFilter('admin'))
async def secret_admin_panel(message: types.Message, session: AsyncSession):
    fake_callback = types.CallbackQuery(
        id=str(message.message_id),
        from_user=message.from_user,
        chat_instance="instance",
        message=message,
        data="admin_panel"
    )
    
    from .admin import show_admin_panel
    await show_admin_panel(fake_callback, session)
    await message.delete()


@router.callback_query(F.data == "switch_to_volunteer_view", RoleFilter('admin'))
async def switch_to_volunteer_view_handler(callback: types.CallbackQuery):
    from aiogram.utils.keyboard import InlineKeyboardBuilder
    builder = InlineKeyboardBuilder()
    builder.row(types.InlineKeyboardButton(text="ğŸ“· ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ (QR)", callback_data="confirm_donation_qr"))
    builder.row(types.InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ¼ĞµĞ½Ñ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ°", callback_data="switch_to_donor_view"))
    await callback.message.edit_text(
        Text.ADMIN_SWITCH_TO_VOLUNTEER_VIEW,
        reply_markup=builder.as_markup(),
        parse_mode="HTML"
    )
    await callback.answer()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/common.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/main_admin.py ---

import io
import csv
import logging
import zipfile 
import datetime
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests, user_requests
from bot.states.states import AdminManagement, BlockUser
from bot.keyboards import inline
from bot.filters.role import RoleFilter
from .admin import show_admin_panel as show_admin_panel_logic

# logging.basicConfig(level=logging.INFO)  # Ğ›Ğ¾Ğ³Ğ¸ Ğ·Ğ°ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹

router = Router()

@router.callback_query(F.data == "main_admin_panel", RoleFilter('main_admin'))
async def show_unified_admin_panel(callback: types.CallbackQuery, session: AsyncSession):
    # Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ñ Ğ´Ğ¾Ğ¿. ĞºĞ½Ğ¾Ğ¿ĞºĞ°Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer: 
        await callback.answer("ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ²Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ.", show_alert=True)
        return

    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: parse_mode="HTML" Ğ¸ Ñ‚ĞµĞºÑÑ‚ Ñ HTML Ñ‚ĞµĞ³Ğ°Ğ¼Ğ¸
    await callback.message.edit_text(
        text="âš™ï¸ <b>ĞŸĞ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°</b>",
        reply_markup=inline.get_admin_panel_keyboard(viewer.role),
        parse_mode="HTML"
    )
    await callback.answer()


# @router.callback_query(F.data == "main_admin_panel", RoleFilter('main_admin'))
# async def show_main_admin_panel(callback: types.CallbackQuery):
#     await callback.message.edit_text(
#         text="ğŸ‘‘ *ĞŸĞ°Ğ½ĞµĞ»ÑŒ Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°*",
#         reply_markup=inline.get_main_admin_panel_keyboard(),
#         parse_mode="Markdown"
#     )
#     await callback.answer()

# @router.callback_query(F.data == "admin_panel", RoleFilter('main_admin'))
# async def show_admin_panel_for_main_admin(callback: types.CallbackQuery):
#     await show_admin_panel_logic(callback)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/main_admin.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/other.py ---

from aiogram import Router, types
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db import user_requests
from bot.keyboards import reply
from bot.utils.text_messages import Text

router = Router()

@router.message()
async def handle_unknown_message(message: types.Message, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    if not user:
        await message.answer(Text.WELCOME, reply_markup=reply.get_contact_keyboard())
    else:
        await message.answer(Text.UNKNOWN_COMMAND)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/other.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/student.py ---

import datetime
import math
import logging
import time
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State 
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db import user_requests, event_requests, merch_requests
from bot.config_reader import config
from bot.keyboards import inline
from bot.utils.qr_service import generate_qr
from bot.utils.text_messages import Text
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.exceptions import TelegramBadRequest
from bot.db.models import MerchItem, Feedback, NoShowReport
from bot.states.states import UserWaiver, FeedbackSurvey
from aiogram.types import BufferedInputFile, WebAppInfo
from bot.utils.calendar_service import generate_ics_file
from bot.db import info_requests

from bot.states.states import UserWaiver, FeedbackSurvey, AskQuestion
from bot.db import user_requests, event_requests, merch_requests, question_requests 


router = Router()
logger = logging.getLogger(__name__)

# --- ĞĞĞ’ĞĞ¯ Ğ£ĞĞ˜Ğ’Ğ•Ğ Ğ¡ĞĞ›Ğ¬ĞĞĞ¯ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯ ---
async def show_events_for_registration(message: types.Message, session: AsyncSession, user_id: int):
    """
    ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸.
    Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ±ÑƒĞ´ĞµÑ‚ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ² Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ğ¼ĞµÑÑ‚Ğ°Ñ….
    """
    events = await event_requests.get_active_events_for_user(session, user_id)
    text = ""
    reply_markup = None

    if not events:
        text = "âœ… ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.\n\nĞš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ ÑĞµĞ¹Ñ‡Ğ°Ñ Ğ½ĞµÑ‚."
        builder = InlineKeyboardBuilder()
        builder.row(types.InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main_menu"))
        reply_markup = builder.as_markup()
    else:
        text = "âœ… ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.\n\nĞ’Ğ¾Ñ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹:"
        builder = InlineKeyboardBuilder()
        for event in events:
            builder.row(types.InlineKeyboardButton(
                text=f"{event.event_datetime.strftime('%d.%m.%Y')} - {event.name}",
                callback_data=f"reg_event_{event.id}"
            ))
        builder.row(types.InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main_menu"))
        reply_markup = builder.as_markup()
    
    # Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ, ĞµÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾, Ğ¸Ğ½Ğ°Ñ‡Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ğ¾Ğµ
    try:
        await message.edit_text(text, reply_markup=reply_markup)
    except TelegramBadRequest:
        try:
            await message.delete()
        except TelegramBadRequest:
            pass # Ğ•ÑĞ»Ğ¸ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ - Ğ½Ğµ ÑÑ‚Ñ€Ğ°ÑˆĞ½Ğ¾
        await message.answer(text, reply_markup=reply_markup)


# --- ğŸ‘¤ ĞœĞĞ™ ĞŸĞ ĞĞ¤Ğ˜Ğ›Ğ¬ ---

@router.callback_query(F.data == "my_profile")
async def show_profile_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        text=Text.PROFILE_MENU_HEADER,
        reply_markup=inline.get_profile_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data == "profile_data")
async def show_profile_data(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    profile_data = await user_requests.get_user_profile_info(session, user.id)
    if not profile_data:
        await callback.answer(Text.PROFILE_LOAD_ERROR, show_alert=True)
        return
    
    user_obj = profile_data['user']
    last_donation = profile_data['last_donation']
    
    if last_donation:
        blood_center = last_donation.event.blood_center_name if last_donation.event else "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
        last_donation_info = f"{last_donation.donation_date.strftime('%d.%m.%Y')} ({Text.escape_html(blood_center)})"
    else:
        last_donation_info = "Ğ•Ñ‰Ğµ Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ¾"

    dkm_status = "Ğ”Ğ°" if user_obj.is_dkm_donor else "ĞĞµÑ‚"

    text = Text.PROFILE_DATA_TEMPLATE.format(
        full_name=Text.escape_html(user_obj.full_name),
        university=Text.escape_html(user_obj.university),
        faculty=Text.escape_html(user_obj.faculty or 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½'),
        study_group=Text.escape_html(user_obj.study_group or 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°'),
        points=user_obj.points,
        total_donations=profile_data['total_donations'],
        next_date=profile_data['next_possible_donation'].strftime('%d.%m.%Y'),
        last_donation_info=last_donation_info,
        dkm_status=dkm_status
    )
    
    await callback.message.edit_text(text, reply_markup=inline.get_back_to_profile_menu_keyboard(), parse_mode="HTML")
    await callback.answer()

@router.callback_query(F.data == "profile_history")
async def show_donation_history(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    donations = await user_requests.get_user_donation_history(session, user.id)
    if not donations:
        await callback.message.edit_text(Text.NO_DONATION_HISTORY, reply_markup=inline.get_back_to_profile_menu_keyboard())
        return
    history_text = Text.DONATION_HISTORY_HEADER
    for donation in donations:
        donation_type_ru = Text.DONATION_TYPE_RU.get(donation.donation_type, donation.donation_type)
        history_text += Text.DONATION_HISTORY_ITEM.format(
            date=donation.donation_date.strftime('%d.%m.%Y'),
            type=Text.escape_html(donation_type_ru), 
            points=donation.points_awarded
        )
    await callback.message.edit_text(history_text, reply_markup=inline.get_back_to_profile_menu_keyboard(), parse_mode="HTML")
    await callback.answer()

# --- ğŸ“… Ğ—ĞĞŸĞ˜Ğ¡Ğ¬ ĞĞ Ğ”ĞĞĞĞ¦Ğ˜Ğ® ---

@router.callback_query(F.data == "register_donation")
async def show_survey_or_events(callback: types.CallbackQuery, session: AsyncSession, ngrok_url: str):
    """
    Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ñ…ĞµĞ½Ğ´Ğ»ĞµÑ€ Ğ´Ğ»Ñ "Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ".
    ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ÑĞ²ĞµĞ¶ĞµĞ¹ Ğ°Ğ½ĞºĞµÑ‚Ñ‹. Ğ•ÑĞ»Ğ¸ Ğ¾Ğ½Ğ° ĞµÑÑ‚ÑŒ - Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ.
    Ğ•ÑĞ»Ğ¸ Ğ½ĞµÑ‚ - Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ WebApp Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°.
    """
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not user:
        await callback.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, ĞµÑÑ‚ÑŒ Ğ»Ğ¸ ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ
    events = await event_requests.get_active_events_for_user(session, user.id)
    today = datetime.date.today()
    is_today_event_available = any(event.event_datetime.date() == today for event in events)

    if is_today_event_available:
        await show_events_for_registration(callback.message, session, user.id)
        return

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ½ĞµĞ´Ğ°Ğ²Ğ½ĞµĞ³Ğ¾ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ³Ğ¾ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ°
    has_recent_survey = await user_requests.check_recent_survey(session, user.id)

    if has_recent_survey:
        # Ğ•ÑĞ»Ğ¸ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸Ğº Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½, ÑÑ€Ğ°Ğ·Ñƒ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ
        await callback.answer("Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ»Ğ¸ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸Ğº. ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ.")
        await show_events_for_registration(callback.message, session, user.id)
    else:
        # Ğ•ÑĞ»Ğ¸ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ° Ğ½ĞµÑ‚, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² WebApp
        if not ngrok_url:
            await callback.answer("ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.", show_alert=True)
            return

        cache_buster = int(time.time())
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ» Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² URL
        webapp_url = f"{ngrok_url}/webapp/index.html?v={cache_buster}&gender={user.gender}"
        
        keyboard = types.InlineKeyboardMarkup(
            inline_keyboard=[[
                types.InlineKeyboardButton(
                    text="ğŸ“ ĞŸÑ€Ğ¾Ğ¹Ñ‚Ğ¸ Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¿ĞµÑ€ĞµĞ´ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ĞµĞ¹",
                    web_app=WebAppInfo(url=webapp_url)
                )
            ],[
                types.InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main_menu")
            ]]
        )
        
        try:
            await callback.message.edit_text(
                "ĞŸĞµÑ€ĞµĞ´ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒÑ Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸ Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ´Ğ»Ñ Ğ²Ñ‹ÑĞ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹. "
                "Ğ­Ñ‚Ğ¾ Ğ·Ğ°Ğ¹Ğ¼ĞµÑ‚ Ğ½Ğµ Ğ±Ğ¾Ğ»ĞµĞµ Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñ‹. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ğ¹Ñ‚Ğµ Ñ‡ĞµÑÑ‚Ğ½Ğ¾.",
                reply_markup=keyboard
            )
        except TelegramBadRequest:
            try:
                await callback.message.delete()
            except TelegramBadRequest:
                pass
            await callback.message.answer(
                "ĞŸĞµÑ€ĞµĞ´ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒÑ Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸ Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ´Ğ»Ñ Ğ²Ñ‹ÑĞ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹. "
                "Ğ­Ñ‚Ğ¾ Ğ·Ğ°Ğ¹Ğ¼ĞµÑ‚ Ğ½Ğµ Ğ±Ğ¾Ğ»ĞµĞµ Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñ‹. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ğ¹Ñ‚Ğµ Ñ‡ĞµÑÑ‚Ğ½Ğ¾.",
                reply_markup=keyboard
            )
        await callback.answer()


@router.callback_query(F.data.startswith("reg_event_"))
async def process_event_registration(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    event = await event_requests.get_event_by_id(session, event_id)
    if not user or not event:
        await callback.answer(Text.ERROR_GENERIC_ALERT, show_alert=True)
        return

    safe_event_name = Text.escape_html(event.name)
    
    # ĞŸĞµÑ€ĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ¿Ñ€ÑĞ¼Ğ¾ Ğ·Ğ´ĞµÑÑŒ Ğ´Ğ»Ñ Ğ½Ğ°Ğ´ĞµĞ¶Ğ½Ğ¾ÑÑ‚Ğ¸
    def get_reg_success_kbd(ev_id: int):
        builder = InlineKeyboardBuilder()
        builder.row(types.InlineKeyboardButton(text="ğŸ”² ĞœĞ¾Ğ¹ QR-ĞºĞ¾Ğ´ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ", callback_data=f"get_event_qr_{ev_id}"))
        builder.row(types.InlineKeyboardButton(text="ğŸ—“ï¸ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² ĞºĞ°Ğ»ĞµĞ½Ğ´Ğ°Ñ€ÑŒ", callback_data=f"add_to_calendar_{ev_id}"))
        builder.row(types.InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ", callback_data=f"cancel_reg_{ev_id}"))
        builder.row(types.InlineKeyboardButton(text="â†©ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹", callback_data="register_donation"))
        return builder.as_markup()

    existing_registration = await event_requests.find_specific_registration(session, user.id, event.id)
    if existing_registration:
        location_link = Text.format_location_link(event.location, event.latitude, event.longitude)
        await callback.message.edit_text(
            text=Text.ALREADY_REGISTERED_FOR_EVENT.format(
                event_name=safe_event_name,
                event_location=location_link,
                blood_center_name=event.blood_center.name if event.blood_center else "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
            ),
            reply_markup=get_reg_success_kbd(event.id),
            parse_mode="HTML",
            disable_web_page_preview=True
        )
        await callback.answer()
        return

    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    if is_eligible:
        await event_requests.add_event_registration(session, user.id, event_id)
        location_link = Text.format_location_link(event.location, event.latitude, event.longitude)
        
        await callback.message.edit_text(
            text=Text.REGISTRATION_SUCCESSFUL.format(
                event_name=safe_event_name,
                event_location=location_link,
                blood_center_name=event.blood_center.name if event.blood_center else "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
            ),
            reply_markup=get_reg_success_kbd(event.id),
            parse_mode="HTML",
            disable_web_page_preview=True 
        )
    else:
        await callback.answer(Text.REGISTRATION_FAILED.format(reason=reason), show_alert=True)


@router.callback_query(F.data.startswith("cancel_reg_"))
async def cancel_my_registration(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    telegram_id = callback.from_user.id
    user = await user_requests.get_user_by_tg_id(session, telegram_id)
    if not user:
        await callback.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        return
    success = await event_requests.cancel_registration(session, user.id, event_id)
    if success:
        await callback.message.edit_text(
            Text.REGISTRATION_CANCELLED_SUCCESS,
            reply_markup=inline.get_back_to_main_menu_keyboard()
        )
    else:
        await callback.message.edit_text(
            Text.REGISTRATION_CANCELLED_FAIL,
            reply_markup=inline.get_back_to_main_menu_keyboard()
        )
    await callback.answer()

# --- ğŸ ĞœĞĞ“ĞĞ—Ğ˜Ğ ĞœĞ•Ğ Ğ§Ğ ---

@router.callback_query(F.data == "merch_store")
@router.callback_query(F.data.startswith("merch_page_"))
async def show_merch_store(callback: types.CallbackQuery, session: AsyncSession):
    page = 1
    if callback.data.startswith("merch_page_"):
        page = int(callback.data.split('_')[-1])
    item, total_items = await merch_requests.get_merch_page(session, page=page)
    if not item:
        await callback.answer(Text.MERCH_NO_ITEMS, show_alert=True)
        return
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    caption = Text.MERCH_ITEM_CAPTION.format(
        item_name=item.name,
        item_description=item.description,
        item_price=item.price,
        user_points=user.points
    )
    keyboard = inline.get_merch_store_keyboard(item, page, total_items)
    try:
        await callback.message.edit_media(
            media=types.InputMediaPhoto(media=item.photo_file_id, caption=caption, parse_mode="HTML"),
            reply_markup=keyboard
        )
    except TelegramBadRequest as e:
        if "message is not modified" in str(e):
             await callback.answer()
             return
        await callback.message.delete()
        await callback.message.answer_photo(
            photo=item.photo_file_id,
            caption=caption,
            reply_markup=keyboard,
            parse_mode="HTML"
        )
    await callback.answer()

@router.callback_query(F.data.startswith("buy_merch_"))
async def confirm_purchase(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await merch_requests.get_merch_item_by_id(session, item_id)
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not item:
        await callback.answer(Text.MERCH_ITEM_NOT_FOUND, show_alert=True)
        return
    if user.points < item.price:
        await callback.answer(Text.MERCH_PURCHASE_INSUFFICIENT_FUNDS.format(price=item.price, points=user.points), show_alert=True)
        return
    text = Text.MERCH_PURCHASE_CONFIRMATION.format(
        item_name=item.name,
        item_price=item.price,
        new_balance=user.points - item.price
    )
    await callback.message.edit_caption(
        caption=text,
        reply_markup=inline.get_purchase_confirmation_keyboard(item_id),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("confirm_buy_"))
async def process_purchase(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await merch_requests.get_merch_item_by_id(session, item_id)
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    success, message = await merch_requests.create_merch_order(session, user, item)
    if success:
        await session.commit() 
        await callback.message.edit_caption(
            caption=Text.MERCH_PURCHASE_SUCCESS.format(message=message),
            reply_markup=inline.get_back_to_merch_keyboard()
        )
    else:
        await session.rollback() 
        await callback.answer(Text.MERCH_PURCHASE_ERROR.format(message=message), show_alert=True)
    await callback.answer()

@router.callback_query(F.data == "my_orders")
async def show_my_orders(callback: types.CallbackQuery, session: AsyncSession):
    user_id = callback.from_user.id
    user = await user_requests.get_user_by_tg_id(session, user_id)
    orders = await merch_requests.get_user_orders(session, user.id)
    if not orders:
        text = Text.MERCH_NO_ORDERS
    else:
        text = Text.MERCH_ORDERS_HEADER
        for order in orders:
            text += Text.MERCH_ORDER_ITEM.format(
                item_name=Text.escape_html(order.item.name),
                date=order.order_date.strftime('%d.%m.%Y'),
                status=Text.escape_html(Text.MERCH_STATUS_MAP.get(order.status, 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚ĞµĞ½'))
            )
    try:
        await callback.message.edit_text(
            text,
            reply_markup=inline.get_back_to_merch_keyboard(),
            parse_mode="HTML"
        )
    except TelegramBadRequest:
        await callback.answer(Text.MERCH_UPDATE_ERROR, show_alert=True)
    await callback.answer()


# --- âš•ï¸ ĞœĞĞ˜ ĞœĞ•Ğ”ĞĞ¢Ğ’ĞĞ”Ğ« ---

async def send_waivers_menu(message_to_answer: types.Message, user_tg_id: int, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, user_tg_id)
    
    if not user:
        await message_to_answer.answer(Text.ERROR_PROFILE_NOT_FOUND)
        return

    all_waivers = await user_requests.get_user_active_waivers(session, user.id)
    
    user_created_waivers = [w for w in all_waivers if w.created_by == 'user']
    system_waivers = [w for w in all_waivers if w.created_by != 'user']

    text_parts = [Text.WAIVERS_MENU_HEADER]

    if not all_waivers:
        text_parts.append(Text.NO_ACTIVE_WAIVERS)
    else:
        if system_waivers:
            text_parts.append(Text.SYSTEM_WAIVERS_HEADER)
            for waiver in system_waivers:
                text_parts.append(Text.WAIVER_ITEM_FORMAT.format(
                    end_date=waiver.end_date.strftime('%d.%m.%Y'),
                    reason=Text.escape_html(waiver.reason)
                ))
        
        if user_created_waivers:
            text_parts.append(Text.USER_WAIVERS_HEADER)
            for waiver in user_created_waivers:
                text_parts.append(Text.WAIVER_ITEM_FORMAT.format(
                    end_date=waiver.end_date.strftime('%d.%m.%Y'),
                    reason=Text.escape_html(waiver.reason)
                ))

    text = "\n".join(text_parts)
    keyboard = inline.get_my_waivers_keyboard(user_waivers_exist=bool(user_created_waivers))

    await message_to_answer.answer(text, reply_markup=keyboard, parse_mode="HTML")


@router.callback_query(F.data == "my_waivers")
async def show_my_waivers(callback: types.CallbackQuery, session: AsyncSession):
    try:
        await callback.message.delete()
    except TelegramBadRequest:
        logger.warning("Could not delete message in show_my_waivers, it might have been deleted already.")
    
    await send_waivers_menu(callback.message, callback.from_user.id, session)
    await callback.answer()


@router.callback_query(F.data == "set_user_waiver")
async def set_user_waiver_start(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(UserWaiver.awaiting_end_date)
    await callback.message.edit_text(Text.WAIVER_SET_PROMPT, parse_mode="HTML")
    await callback.answer()

@router.message(UserWaiver.awaiting_end_date)
async def process_user_waiver_date(message: types.Message, state: FSMContext):
    try:
        end_date = datetime.datetime.strptime(message.text, "%d.%m.%Y").date()
        if end_date <= datetime.date.today():
            await message.answer(Text.WAIVER_DATE_IN_PAST_ERROR)
            return
            
        await state.update_data(end_date=end_date)
        await state.set_state(UserWaiver.awaiting_reason)
        await message.answer(Text.WAIVER_REASON_PROMPT)
    except ValueError:
        await message.answer(Text.DATE_FORMAT_ERROR, parse_mode="HTML")

@router.message(UserWaiver.awaiting_reason)
async def process_user_waiver_reason(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    end_date = data['end_date']
    reason = message.text

    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    await user_requests.add_user_waiver(session, user.id, end_date, reason)
    
    await state.clear()
    
    await message.answer(Text.WAIVER_SET_SUCCESS.format(end_date=end_date.strftime('%d.%m.%Y')))
    
    await send_waivers_menu(message, message.from_user.id, session)

@router.callback_query(F.data == "cancel_user_waiver")
async def cancel_user_waiver_start(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    all_waivers = await user_requests.get_user_active_waivers(session, user.id)
    user_created_waivers = [w for w in all_waivers if w.created_by == 'user']
    
    if not user_created_waivers:
        await callback.answer(Text.WAIVER_NOTHING_TO_CANCEL, show_alert=True)
        return

    await callback.message.edit_text(
        Text.WAIVER_CANCELLATION_PROMPT,
        reply_markup=inline.get_waiver_cancellation_keyboard(user_created_waivers)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("delete_waiver_"))
async def process_waiver_deletion(callback: types.CallbackQuery, session: AsyncSession):
    waiver_id = int(callback.data.split('_')[-1])
    
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not user:
        await callback.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        return

    user_internal_id = user.id
    success = await user_requests.delete_user_waiver(session, waiver_id, user_internal_id)
    
    if success:
        await callback.answer(Text.WAIVER_CANCEL_SUCCESS, show_alert=True)
    else:
        await callback.answer(Text.WAIVER_CANCEL_FAIL, show_alert=True)
    
    try:
        await callback.message.delete()
    except TelegramBadRequest:
        logger.warning("Could not delete message in process_waiver_deletion.")

    await send_waivers_menu(callback.message, callback.from_user.id, session)


# --- â„¹ï¸ ĞŸĞĞ›Ğ•Ğ—ĞĞĞ¯ Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ---

@router.callback_query(F.data == "info")
async def show_info_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        text=Text.INFO_MENU_HEADER,
        reply_markup=inline.get_info_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()


@router.callback_query(F.data.startswith("info_"))
async def show_info_text(callback: types.CallbackQuery, session: AsyncSession):
    section = callback.data.split('_', 1)[1]
    text_to_show = await info_requests.get_info_text(session, section)

    await callback.message.edit_text(text_to_show, reply_markup=inline.get_back_to_info_menu_keyboard(), parse_mode="HTML", disable_web_page_preview=True)
    await callback.answer()

# --- ğŸ”² ĞœĞĞ™ QR-ĞšĞĞ” ---

@router.callback_query(F.data == "my_qr_code")
async def send_qr_code(callback: types.CallbackQuery):
    await callback.answer(Text.QR_GENERATING)
    qr_data = {"user_id": callback.from_user.id} 
    qr_image_bytes = await generate_qr(qr_data)
    await callback.message.answer_photo(
        photo=types.BufferedInputFile(qr_image_bytes, filename="my_qr.png"),
        caption=Text.QR_GENERAL_CAPTION
    )

@router.callback_query(F.data.startswith("get_event_qr_"))
async def send_event_qr_code(callback: types.CallbackQuery):
    event_id = int(callback.data.split('_')[-1])
    user_id = callback.from_user.id
    qr_data = {
        "user_id": user_id,
        "event_id": event_id
    }
    await callback.answer(Text.QR_GENERATING)
    qr_image_bytes = await generate_qr(qr_data)
    await callback.message.answer_photo(
        photo=types.BufferedInputFile(qr_image_bytes, filename="event_qr.png"),
        caption=Text.QR_EVENT_CAPTION
    )

# --- ĞĞĞ’Ğ«Ğ™ Ğ¥Ğ•ĞĞ”Ğ›Ğ•Ğ : Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ² ĞºĞ°Ğ»ĞµĞ½Ğ´Ğ°Ñ€ÑŒ ---
@router.callback_query(F.data.startswith("add_to_calendar_"))
async def send_calendar_file(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event:
        await callback.answer("ĞœĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.", show_alert=True)
        return

    ics_content = generate_ics_file(event)
    file_to_send = BufferedInputFile(
        file=ics_content.encode('utf-8'),
        filename=f"event_{event.id}.ics"
    )
    
    await callback.message.answer_document(
        document=file_to_send,
        caption=f"ğŸ—“ï¸ ĞšĞ°Ğ»ĞµĞ½Ğ´Ğ°Ñ€Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ğ´Ğ»Ñ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Â«{event.name}Â».\nĞÑ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ ĞµĞ³Ğ¾, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ Ğ² Ğ²Ğ°Ñˆ ĞºĞ°Ğ»ĞµĞ½Ğ´Ğ°Ñ€ÑŒ."
    )
    await callback.answer()

# --- FSM Ğ”Ğ›Ğ¯ ĞĞ‘Ğ ĞĞ¢ĞĞĞ™ Ğ¡Ğ’Ğ¯Ğ—Ğ˜ ---

feedback_router = Router()

@feedback_router.callback_query(FeedbackSurvey.awaiting_well_being, F.data.startswith("fb_wb_"))
async def process_well_being(callback: types.CallbackQuery, state: FSMContext):
    score = int(callback.data.split('_')[-1])
    await state.update_data(well_being_score=score)
    
    if score <= 3: 
        await callback.message.edit_text(Text.FEEDBACK_WELL_BEING_BAD)
        await state.set_state(FeedbackSurvey.awaiting_well_being_comment)
    else:
        await callback.message.edit_text(Text.FEEDBACK_GET_ORGANIZATION_SCORE, reply_markup=inline.get_feedback_organization_keyboard())
        await state.set_state(FeedbackSurvey.awaiting_organization_score)
    await callback.answer()

@feedback_router.message(FeedbackSurvey.awaiting_well_being_comment)
async def process_well_being_comment(message: types.Message, state: FSMContext):
    await state.update_data(well_being_comment=message.text)
    await message.answer(Text.FEEDBACK_GET_ORGANIZATION_SCORE, reply_markup=inline.get_feedback_organization_keyboard())
    await state.set_state(FeedbackSurvey.awaiting_organization_score)

@feedback_router.callback_query(FeedbackSurvey.awaiting_organization_score, F.data.startswith("fb_org_"))
async def process_org_score(callback: types.CallbackQuery, state: FSMContext):
    score = int(callback.data.split('_')[-1])
    await state.update_data(organization_score=score)
    await callback.message.edit_text(Text.FEEDBACK_GET_WHAT_LIKED, reply_markup=inline.get_feedback_skip_keyboard())
    await state.set_state(FeedbackSurvey.awaiting_what_liked)
    await callback.answer()

async def skip_or_process_text(event: types.Message | types.CallbackQuery, state: FSMContext, field_name: str, next_state: State, next_text: str, next_keyboard=None):
    is_callback = hasattr(event, 'message')
    message_to_edit = event.message if is_callback else event
    
    if not is_callback: 
        await state.update_data(**{field_name: event.text})
        try:
            await event.delete()
        except TelegramBadRequest:
            pass
    else:
        await state.update_data(**{field_name: "ĞŸÑ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ¾"})
        await event.answer()

    try:
        await message_to_edit.edit_text(next_text, reply_markup=next_keyboard)
    except TelegramBadRequest:
        await message_to_edit.delete()
        await message_to_edit.answer(next_text, reply_markup=next_keyboard)
        
    await state.set_state(next_state)

@feedback_router.message(FeedbackSurvey.awaiting_what_liked)
@feedback_router.callback_query(FeedbackSurvey.awaiting_what_liked, F.data == "fb_skip_step")
async def process_what_liked(event: types.Message | types.CallbackQuery, state: FSMContext):
    await skip_or_process_text(event, state, 'what_liked', FeedbackSurvey.awaiting_what_disliked, Text.FEEDBACK_GET_WHAT_DISLIKED, inline.get_feedback_skip_keyboard())

@feedback_router.message(FeedbackSurvey.awaiting_what_disliked)
@feedback_router.callback_query(FeedbackSurvey.awaiting_what_disliked, F.data == "fb_skip_step")
async def process_what_disliked(event: types.Message | types.CallbackQuery, state: FSMContext):
    await skip_or_process_text(event, state, 'what_disliked', FeedbackSurvey.awaiting_other_suggestions, Text.FEEDBACK_GET_OTHER_SUGGESTIONS, inline.get_feedback_skip_keyboard())

@feedback_router.message(FeedbackSurvey.awaiting_other_suggestions)
@feedback_router.callback_query(FeedbackSurvey.awaiting_other_suggestions, F.data == "fb_skip_step")
async def process_other_suggestions(event: types.Message | types.CallbackQuery, state: FSMContext, session: AsyncSession):
    is_callback = hasattr(event, 'message')
    message_to_use = event.message if is_callback else event
    data = await state.get_data()

    if not is_callback:
        final_suggestion = event.text
    else:  
        final_suggestion = "ĞŸÑ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ¾"
        await event.answer()

    user = await user_requests.get_user_by_tg_id(session, event.from_user.id)
    
    feedback = Feedback(
        user_id=user.id,
        event_id=data.get('event_id'),
        well_being_score=data.get('well_being_score'),
        well_being_comment=data.get('well_being_comment'),
        organization_score=data.get('organization_score'),
        what_liked=data.get('what_liked'),
        what_disliked=data.get('what_disliked'),
        other_suggestions=final_suggestion
    )
    session.add(feedback)
    await session.commit()
    
    await state.clear()
    
    try:
        await message_to_use.edit_text(Text.FEEDBACK_FINISH)
    except TelegramBadRequest:
        await message_to_use.answer(Text.FEEDBACK_FINISH)
        
        
@router.callback_query(F.data == "ask_question")
async def start_asking_question(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(AskQuestion.awaiting_question)
    await callback.message.edit_text("ĞĞ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ, Ğ¸ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ñ‹ ÑĞºĞ¾Ñ€Ğ¾ Ğ½Ğ° Ğ½ĞµĞ³Ğ¾ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚.")
    await callback.answer()

@router.message(AskQuestion.awaiting_question)
async def process_question(message: types.Message, state: FSMContext, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    await question_requests.create_question(session, user.id, message.text)
    await state.clear()
    await message.answer(
        "Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾! Ğ’Ğ°Ñˆ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼. ĞÑ‚Ğ²ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ´ĞµÑ‚ ÑÑĞ´Ğ° Ğ¶Ğµ, Ğ² ÑÑ‚Ğ¾Ñ‚ Ñ‡Ğ°Ñ‚.",
        reply_markup=inline.get_back_to_main_menu_keyboard()
    )
    
    
@router.callback_query(F.data.startswith("no_show_"))
async def process_no_show_reason(callback: types.CallbackQuery, session: AsyncSession):
    _, event_id_str, reason = callback.data.split("_")
    event_id = int(event_id_str)
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)

    report = NoShowReport(user_id=user.id, event_id=event_id, reason=reason)
    session.add(report)
    await session.commit()
    
    await callback.message.edit_text("Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ²Ğ°Ñˆ Ğ¾Ñ‚Ğ²ĞµÑ‚! Ğ­Ñ‚Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ½Ğ°Ğ¼ Ğ² Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹.")
    await callback.answer()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/student.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/volunteer.py ---

import datetime
import logging
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.utils.keyboard import InlineKeyboardBuilder

from bot.db import user_requests, event_requests
from bot.filters.role import RoleFilter
from bot.states.states import VolunteerActions
from bot.utils.qr_service import read_qr
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router()
logger = logging.getLogger(__name__)

@router.callback_query(F.data == "volunteer_panel", RoleFilter('volunteer'))
async def show_volunteer_panel(callback: types.CallbackQuery):
    await callback.message.edit_text(
        Text.VOLUNTEER_MENU_HEADER,
        reply_markup=inline.get_volunteer_panel_keyboard(),
        parse_mode="HTML"  # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
    )
    await callback.answer()

@router.callback_query(F.data == "confirm_donation_qr", RoleFilter('volunteer'))
async def start_qr_confirmation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(VolunteerActions.awaiting_qr_photo)
    await callback.message.edit_text(Text.VOLUNTEER_SEND_QR_PROMPT)
    await callback.answer()

@router.message(VolunteerActions.awaiting_qr_photo, F.photo)
async def process_qr_photo(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    photo_bytes = (await bot.download(message.photo[-1].file_id)).read()
    qr_data = await read_qr(photo_bytes)

    if not qr_data or "user_id" not in qr_data or "event_id" not in qr_data:
        await message.answer(Text.QR_READ_ERROR)
        await state.clear()
        return

    try:
        donor_tg_id = int(qr_data["user_id"])
        event_id_from_qr = int(qr_data["event_id"])
    except (ValueError, TypeError):
        await message.answer(Text.QR_INVALID_DATA_ERROR)
        await state.clear()
        return

    donor = await user_requests.get_user_by_tg_id(session, donor_tg_id)
    event = await event_requests.get_event_by_id(session, event_id_from_qr)
    
    if not donor or not event:
        await message.answer(Text.QR_DB_LOOKUP_ERROR)
        await state.clear()
        return

    registration = await event_requests.find_specific_registration(session, donor.id, event.id)
    if not registration:
        # Ğ”Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ parse_mode Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½, Ñ‚.Ğº. Ğ² Ñ‚ĞµĞºÑÑ‚Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ½ĞµÑ‚ Ñ‚ĞµĞ³Ğ¾Ğ², Ğ½Ğ¾ Ğ»ÑƒÑ‡ÑˆĞµ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼
        await message.answer(Text.QR_DONOR_NOT_REGISTERED_ERROR.format(donor_name=donor.full_name), parse_mode="HTML")
        await state.clear()
        return

    if event.event_datetime.date() != datetime.date.today():
        await message.answer(Text.QR_WRONG_DAY_ERROR) # Ğ—Ğ´ĞµÑÑŒ Ğ½ĞµÑ‚ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ, parse_mode Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½
        await state.clear()
        return

    await state.update_data(
        donor_id=donor.id,
        event_id=event.id,
        donor_tg_id=donor.telegram_id,
        donor_name=donor.full_name,
        event_name=event.name
    )
    await state.set_state(VolunteerActions.awaiting_confirmation)

    await message.answer(
        Text.VOLUNTEER_CONFIRMATION_PROMPT.format(donor_name=donor.full_name, event_name=event.name),
        reply_markup=inline.get_donation_confirmation_keyboard(donor.id, event.id),
        parse_mode="HTML"  # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
    )

@router.callback_query(VolunteerActions.awaiting_confirmation, F.data.startswith("confirm_donation_"))
async def process_donation_confirmation(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    donor_id_from_state = data.get("donor_id")
    event_id_from_state = data.get("event_id")
    
    parts = callback.data.split('_')
    donor_id_from_cb = parts[2]
    event_id_from_cb = parts[3]
    
    if not (donor_id_from_state == int(donor_id_from_cb) and event_id_from_state == int(event_id_from_cb)):
        await callback.message.edit_text(Text.VOLUNTEER_CONFIRMATION_ERROR)
        await state.clear()
        return

    await state.clear()
    await callback.message.edit_text(Text.DONATION_CONFIRMING)
    
    donor = await user_requests.get_user_by_id(session, donor_id_from_state)
    registration = await event_requests.find_specific_registration(session, donor_id_from_state, event_id_from_state)

    if not donor or not registration:
        await callback.message.edit_text(Text.DONATION_CONFIRM_ERROR_NO_REG)
        return

    try:
        points_awarded, waiver_end_date = await event_requests.confirm_donation_transaction(session, donor, registration)
        
        success_text = Text.DONATION_CONFIRM_SUCCESS.format(
            donor_name=donor.full_name,
            event_name=registration.event.name,
            points=points_awarded
        )
        await callback.message.edit_text(
            success_text,
            reply_markup=inline.get_volunteer_panel_keyboard(),
            parse_mode="HTML"  # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        )
    except Exception as e:
        logger.error(f"Critical error during donation confirmation for user {donor.id}: {e}", exc_info=True)
        await callback.message.edit_text(Text.DONATION_CONFIRM_CRITICAL_ERROR.format(error=e))

    await callback.answer()

@router.message(VolunteerActions.awaiting_qr_photo)
async def process_qr_invalid_input(message: types.Message):
    await message.answer(Text.VOLUNTEER_INVALID_INPUT_QR)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/volunteer.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/__init__.py ---

from aiogram import Router, F, types
from sqlalchemy.ext.asyncio import AsyncSession

from bot.filters.role import RoleFilter
from bot.db import user_requests
from bot.keyboards import inline
from bot.utils.text_messages import Text

from .user_management import router as user_management_router
from .event_management import router as event_management_router
from .merch_management import router as merch_management_router
from .mailing import router as mailing_router
from .system import router as system_router
from .analytics import router as analytics_router
from .info_management import router as info_management_router
from .qa_management import router as qa_management_router

admin_router = Router(name="admin")

admin_router.include_routers(
    user_management_router,
    event_management_router,
    merch_management_router,
    mailing_router,
    system_router,
    analytics_router,
    info_management_router,
    qa_management_router,
)

@admin_router.callback_query(F.data == "admin_panel", RoleFilter('admin'))
async def show_admin_panel(callback: types.CallbackQuery, session: AsyncSession):
    """
    ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°ĞµÑ‚ Ğ³Ğ»Ğ°Ğ²Ğ½ÑƒÑ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°.
    ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ğ¾Ğ´ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ´ Ñ€Ğ¾Ğ»ÑŒ (admin Ğ¸Ğ»Ğ¸ main_admin).
    """
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer:
        await callback.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        return

    await callback.message.edit_text(
        text=Text.ADMIN_PANEL_HEADER,
        reply_markup=inline.get_admin_panel_keyboard(viewer.role),
        parse_mode="HTML"
    )
    await callback.answer()
    

@admin_router.callback_query(F.data == "admin_manage_events")
async def manage_events_panel_test(callback: types.CallbackQuery):

    await callback.message.edit_text(Text.ADMIN_EVENTS_HEADER, reply_markup=inline.get_events_management_keyboard(), parse_mode="HTML")
    await callback.answer()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/__init__.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/analytics.py ---

import datetime
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import analytics_requests 
from bot.filters.role import RoleFilter
from bot.keyboards import inline
from bot.utils import analytics_service 
from bot.states.states import AdminAnalytics

router = Router(name="admin_analytics")

@router.callback_query(F.data == "admin_analytics", RoleFilter('admin'))
async def show_analytics_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        "ğŸ“Š <b>ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ´Ğ°ÑˆĞ±Ğ¾Ñ€Ğ´</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑÑƒÑÑ‰Ğ¸Ğ¹ Ñ€Ğ°Ğ·Ğ´ĞµĞ»:",
        reply_markup=inline.get_analytics_main_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data == "analytics_kpi", RoleFilter('admin'))
async def show_main_kpi(callback: types.CallbackQuery, session: AsyncSession):
    await callback.answer("â³ Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ...")
    kpi_data = await analytics_requests.get_main_kpi(session)

    text_parts = ["ğŸ“ˆ <b>ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ (KPI)</b>\n"]
    text_parts.append(f"<b>ĞĞ¾Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ (30Ğ´):</b> {kpi_data['new_users_30d']}")
    text_parts.append(f"<b>ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ñ‹ (90Ğ´):</b> {kpi_data['active_donors_90d']}")
    text_parts.append(f"<b>Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ Ğ½Ğ° Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğµ:</b> {kpi_data['on_waiver_now']}")

    if kpi_data['next_event']:
        event = kpi_data['next_event']
        days_left = (event['date'] - datetime.datetime.now()).days
        text_parts.append(f"\nğŸ”œ <b>Ğ‘Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞµĞµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ:</b> Â«{event['name']}Â»")
        text_parts.append(f"   - <b>Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¾:</b> {event['registered']}/{event['limit']}")
        text_parts.append(f"   - <b>ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ Ğ´Ğ½ĞµĞ¹:</b> {days_left}")
    else:
        text_parts.append("\nâŒ ĞĞµÑ‚ Ğ·Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹.")
        
    # Ğ—Ğ°Ğ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ°
    plot_data = await analytics_requests.get_donations_by_month(session)
    plot_image = analytics_service.plot_donations_by_month(plot_data)

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²ÑƒÑ Ñ‡Ğ°ÑÑ‚ÑŒ
    await callback.message.edit_text(
        "\n".join(text_parts), 
        reply_markup=inline.get_analytics_main_menu_keyboard(),
        parse_mode="HTML"
    )
    # Ğ•ÑĞ»Ğ¸ Ğ³Ñ€Ğ°Ñ„Ğ¸Ğº ÑĞ¾Ğ·Ğ´Ğ°Ğ»ÑÑ, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞµĞ³Ğ¾ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸ĞµĞ¼
    if plot_image:
        await callback.message.answer_photo(
            photo=types.BufferedInputFile(plot_image.read(), filename="donations_plot.png")
        )

@router.callback_query(F.data == "analytics_events_select", RoleFilter('admin'))
async def select_event_for_analysis(callback: types.CallbackQuery, session: AsyncSession, state: FSMContext):
    past_events = await analytics_requests.get_past_events_for_analysis(session)
    if not past_events:
        await callback.answer("Ğ•Ñ‰Ğµ Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ¾ Ğ½Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞµĞ³Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ.", show_alert=True)
        return

    await callback.message.edit_text(
        "ğŸ“… <b>ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°:",
        reply_markup=inline.get_events_for_analysis_keyboard(past_events)
    )
    await state.set_state(AdminAnalytics.choosing_event_for_analysis)
    await callback.answer()

@router.callback_query(AdminAnalytics.choosing_event_for_analysis, F.data.startswith("analyze_event_"))
async def show_event_analysis(callback: types.CallbackQuery, session: AsyncSession, state: FSMContext):
    await state.clear()
    event_id = int(callback.data.split("_")[-1])
    
    await callback.answer("â³ Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºÑƒ Ğ¿Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ...")
    data = await analytics_requests.get_event_analysis_data(session, event_id)

    if not data:
        await callback.message.edit_text("ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ.")
        return

    text = [
        f"ğŸ“Š <b>ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Â«{data['event_name']}Â»</b>\n",
        "<b>Ğ’Ğ¾Ñ€Ğ¾Ğ½ĞºĞ° Ğ¿Ñ€Ğ¸Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ñ:</b>",
        f"  - Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ğ»Ğ¾ÑÑŒ: {data['registered_count']}",
        f"  - ĞŸÑ€Ğ¸ÑˆĞ»Ğ¾: {data['attended_count']}",
        f"  - ĞšĞ¾Ğ½Ğ²ĞµÑ€ÑĞ¸Ñ Ğ² ÑĞ²ĞºÑƒ: {data['conversion_rate']:.1f}%\n",
        "<b>ĞŸĞ¾Ñ€Ñ‚Ñ€ĞµÑ‚ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¸:</b>",
        f"  - ĞĞ¾Ğ²Ğ¸Ñ‡ĞºĞ¸: {data['newcomers_count']}",
        f"  - 'Ğ’ĞµÑ‚ĞµÑ€Ğ°Ğ½Ñ‹': {data['veterans_count']}\n",
        "<b>Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ğ°Ğ¼ (Ğ¿Ñ€Ğ¸ÑˆĞµĞ´ÑˆĞ¸Ğµ):</b>"
    ]
    
    # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ñ‹ Ğ¿Ğ¾ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ñƒ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²
    sorted_faculties = sorted(data['faculties_distribution'].items(), key=lambda item: item[1], reverse=True)
    for faculty, count in sorted_faculties:
        text.append(f"  - {faculty}: {count} Ñ‡ĞµĞ».")

    await callback.message.edit_text(
        "\n".join(text),
        parse_mode="HTML",
        reply_markup=inline.get_analytics_main_menu_keyboard()
    )

@router.callback_query(F.data == "analytics_reports", RoleFilter('admin'))
async def show_reports_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        "ğŸ“„ <b>ĞÑ‚Ñ‡ĞµÑ‚Ñ‹</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ°:",
        reply_markup=inline.get_reports_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("report_"), RoleFilter('admin'))
async def generate_report(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    report_type = callback.data.split("_", 1)[1]
    report_titles = {
        "churn_donors": "Ğ”Ğ¾Ğ½Ğ¾Ñ€Ñ‹-Ğ¾Ğ´Ğ½Ğ¾Ğ´Ğ½ĞµĞ²ĞºĞ¸",
        "lapsed_donors": "Ğ£Ğ³Ğ°ÑĞ°ÑÑ‰Ğ¸Ğµ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ñ‹",
        "top_donors": "Ğ”Ğ¾Ğ½Ğ¾Ñ€Ñ‹-Ñ‡ĞµĞ¼Ğ¿Ğ¸Ğ¾Ğ½Ñ‹",
        "rare_blood_donors": "Ğ”Ğ¾Ğ½Ğ¾Ñ€Ñ‹ Ñ€ĞµĞ´ĞºĞ¾Ğ¹ ĞºÑ€Ğ¾Ğ²Ğ¸",
        "top_faculties": "Ğ¡Ğ°Ğ¼Ñ‹Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ñ‹",
        "dkm_candidates": "ĞšĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚Ñ‹ Ğ² Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ğ”ĞšĞœ",
        "survey_dropoff": "ĞŸĞ¾Ñ‚ĞµÑ€ÑĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ°"
    }
    report_title = report_titles.get(report_type, "ĞÑ‚Ñ‡ĞµÑ‚")

    await callback.answer("â³ Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒÑ Ğ¾Ñ‚Ñ‡ĞµÑ‚...")

    report_data = await analytics_service.create_report(session, report_type)

    if not report_data:
        await callback.message.answer("ĞĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ°.")
        return

    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ° Ğ² Ğ²Ğ¸Ğ´Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹
    headers = list(report_data[0].keys())
    # Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸ Ğ´Ğ»Ñ ĞºÑ€Ğ°ÑĞ¾Ñ‚Ñ‹
    header_map = {
        "full_name": "Ğ¤Ğ˜Ğ", "username": "Username", "donation_date": "Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸",
        "donation_count": "Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹", "last_donation_date": "ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ", "rank": "Ğ Ğ°Ğ½Ğ³",
        "blood_group": "Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° ĞºÑ€Ğ¾Ğ²Ğ¸", "faculty_name": "Ğ¤Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚", "survey_date": "Ğ”Ğ°Ñ‚Ğ° Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ°"
    }
    pretty_headers = [header_map.get(h, h) for h in headers]

    # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ ÑˆĞ¸Ñ€Ğ¸Ğ½Ñƒ ĞºĞ¾Ğ»Ğ¾Ğ½Ğ¾Ğº
    col_widths = {h: len(pretty_headers[i]) for i, h in enumerate(headers)}
    for row in report_data:
        for key, value in row.items():
            col_widths[key] = max(col_widths[key], len(str(value)))

    # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»
    report_lines = []
    report_lines.append(f"ĞÑ‚Ñ‡ĞµÑ‚: {report_title}")
    report_lines.append("=" * (sum(col_widths.values()) + len(col_widths) * 3 -1))

    header_line = "  ".join(h.ljust(col_widths[headers[i]]) for i, h in enumerate(pretty_headers))
    report_lines.append(header_line)
    report_lines.append("-" * len(header_line))

    for row in report_data:
        row_list = []
        for header in headers:
            value = row.get(header, "")
            if isinstance(value, datetime.datetime) or isinstance(value, datetime.date):
                value = value.strftime('%Y-%m-%d')
            row_list.append(str(value).ljust(col_widths[header]))
        report_lines.append("  ".join(row_list))

    report_text = "\n".join(report_lines)

    await bot.send_document(
        chat_id=callback.from_user.id,
        document=types.BufferedInputFile(
            report_text.encode("utf-8"),
            filename=f"report_{report_type}.txt"
        ),
        caption=f"ĞÑ‚Ñ‡ĞµÑ‚: {report_title}"
    )

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/analytics.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/event_management.py ---

import logging
import datetime
import asyncio
import io
import csv
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.markdown import hbold
from aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from bot.db import admin_requests, event_requests, user_requests
from bot.db.engine import async_session_maker
from bot.filters.role import RoleFilter
from bot.states.states import EventCreation, EventEditing, PostEventProcessing
from bot.keyboards import inline
from bot.db.models import Event, User
from bot.utils.text_messages import Text
from bot.db import analytics_requests


router = Router(name="admin_event_management")
logger = logging.getLogger(__name__)


# =============================================================================
# --- ğŸ—“ï¸ Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• ĞœĞ•Ğ ĞĞŸĞ Ğ˜Ğ¯Ğ¢Ğ˜Ğ¯ĞœĞ˜ ---
# =============================================================================

@router.callback_query(F.data == "admin_create_event", RoleFilter('admin'))
async def start_event_creation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(EventCreation.awaiting_name)
    await callback.message.edit_text(Text.EVENT_CREATE_STEP_1_NAME)
    await callback.answer()

@router.message(EventCreation.awaiting_name)
async def process_event_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(EventCreation.awaiting_datetime)
    await message.answer(Text.EVENT_CREATE_STEP_2_DATE, parse_mode="HTML")

@router.message(EventCreation.awaiting_datetime)
async def process_event_datetime(message: types.Message, state: FSMContext):
    try:
        event_dt = datetime.datetime.strptime(message.text, "%d.%m.%Y %H:%M")
        await state.update_data(event_datetime=event_dt.isoformat())
        await state.set_state(EventCreation.awaiting_location_text)
        await message.answer(Text.EVENT_CREATE_STEP_3_LOCATION_TEXT)
    except ValueError:
        await message.answer(Text.DATE_FORMAT_ERROR, parse_mode="HTML")

@router.message(EventCreation.awaiting_location_text)
async def process_event_location_text(message: types.Message, state: FSMContext):
    await state.update_data(location=message.text)
    await state.set_state(EventCreation.awaiting_location_point)
    await message.answer(Text.EVENT_CREATE_STEP_4_LOCATION_POINT)

@router.message(EventCreation.awaiting_location_point, F.location)
async def process_event_location_point(message: types.Message, state: FSMContext, session: AsyncSession):
    await state.update_data(
        latitude=message.location.latitude,
        longitude=message.location.longitude
    )
    await state.set_state(EventCreation.awaiting_blood_center)

    blood_centers = await admin_requests.get_all_blood_centers(session)
    await message.answer(
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸ Ğ¸Ğ»Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹:",
        reply_markup=inline.get_blood_centers_keyboard(blood_centers)
    )


@router.callback_query(EventCreation.awaiting_blood_center, F.data.startswith("select_blood_center_"))
async def process_blood_center_selection(callback: types.CallbackQuery, state: FSMContext):
    blood_center_id = int(callback.data.split("_")[-1])
    await state.update_data(blood_center_id=blood_center_id)
    await state.set_state(EventCreation.awaiting_donation_type)
    await callback.message.edit_text(
        Text.EVENT_CREATE_STEP_5_TYPE,
        reply_markup=inline.get_donation_type_keyboard()
    )


@router.callback_query(EventCreation.awaiting_blood_center, F.data == "add_new_blood_center")
async def add_new_blood_center(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(EventCreation.awaiting_new_blood_center_name)
    await callback.message.edit_text("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€Ğ° ĞºÑ€Ğ¾Ğ²Ğ¸:")


@router.message(EventCreation.awaiting_new_blood_center_name)
async def process_new_blood_center_name(message: types.Message, state: FSMContext, session: AsyncSession):
    new_blood_center = await admin_requests.create_blood_center(session, message.text)
    await state.update_data(blood_center_id=new_blood_center.id)
    await state.set_state(EventCreation.awaiting_donation_type)
    await message.answer(
        Text.EVENT_CREATE_STEP_5_TYPE,
        reply_markup=inline.get_donation_type_keyboard()
    )

@router.callback_query(EventCreation.awaiting_donation_type, F.data.startswith("settype_"))
async def process_event_donation_type(callback: types.CallbackQuery, state: FSMContext):
    donation_type = callback.data.split('_', 1)[1]
    await state.update_data(donation_type=donation_type)
    await state.set_state(EventCreation.awaiting_points)
    await callback.message.edit_text(Text.EVENT_CREATE_STEP_6_POINTS.format(donation_type=donation_type))
    await callback.answer()

@router.message(EventCreation.awaiting_points)
async def process_event_points(message: types.Message, state: FSMContext):
    try:
        points = int(message.text)
        await state.update_data(points_per_donation=points)
        await state.set_state(EventCreation.awaiting_limit)
        await message.answer(Text.EVENT_CREATE_STEP_7_LIMIT)
    except ValueError:
        await message.answer(Text.EVENT_POINTS_NAN_ERROR)


@router.message(EventCreation.awaiting_limit)
async def process_event_limit(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        limit = int(message.text)
        await state.update_data(participant_limit=limit)
        await state.set_state(EventCreation.awaiting_confirmation)
        
        event_data = await state.get_data()

        blood_center = await admin_requests.get_blood_center_by_id(session, event_data['blood_center_id'])

        text = Text.EVENT_CREATE_CONFIRMATION.format(
            name=event_data['name'],
            datetime=datetime.datetime.fromisoformat(event_data['event_datetime']).strftime('%d.%m.%Y Ğ² %H:%M'),
            location=event_data['location'],
            blood_center_name=blood_center.name,
            location_set="Ğ£ĞºĞ°Ğ·Ğ°Ğ½Ğ°" if event_data.get('latitude') else "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°",
            type=event_data['donation_type'],
            points=event_data['points_per_donation'],
            limit=event_data['participant_limit']
        )
        
        await message.answer(text, reply_markup=inline.get_event_creation_confirmation_keyboard())
    except ValueError:
        await message.answer(Text.EVENT_LIMIT_NAN_ERROR)

@router.callback_query(EventCreation.awaiting_confirmation, F.data == "confirm_create_event")
async def confirm_event_creation_and_notify(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    await callback.message.edit_text(Text.EVENT_CREATING_IN_PROGRESS)
    
    event_data = await state.get_data()
    await state.clear()
    
    event_data['event_datetime'] = datetime.datetime.fromisoformat(event_data['event_datetime'])
    new_event = await admin_requests.create_event(session, event_data)
    await session.commit()
    
    await callback.message.answer(Text.EVENT_CREATE_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())
    
    msg = await callback.message.answer(Text.MAILING_STARTED_NOTIFICATION)
    
    asyncio.create_task(send_new_event_notifications(new_event, bot, msg))
    
    await callback.answer()

async def _send_notification_safe(bot: Bot, user: User, text: str, **kwargs):
    """Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ, Ğ»Ğ¾Ğ²Ğ¸Ñ‚ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸."""
    try:
        await bot.send_message(chat_id=user.telegram_id, text=text, **kwargs)
        return True
    except TelegramForbiddenError:
        logger.warning(f"Failed to send notification to user {user.id}. Bot was blocked.")
    except TelegramBadRequest as e:
        if "chat not found" in str(e):
            logger.warning(f"Failed to send notification to user {user.id}. Chat not found.")
        else:
            logger.error(f"Failed to send new event notification to user {user.id}. Error: {e}")
    except Exception as e:
        logger.error(f"Failed to send new event notification to user {user.id}. Unexpected error: {e}")
    return False

async def send_new_event_notifications(event: Event, bot: Bot, status_message: types.Message):
    """
    Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºÑƒ Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ asyncio.gather Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»Ğ¸Ğ·Ğ¼Ğ°.
    """
    async with async_session_maker() as session:
        try:
            users_to_notify = await user_requests.get_users_for_event_notification(session, event)
            total_users = len(users_to_notify)
            logger.info(f"Starting mailing for event '{event.name}'. Found {total_users} users.")

            if total_users == 0:
                await status_message.edit_text("âœ… Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°. ĞŸĞ¾Ğ´Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ´Ğ»Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.")
                return

            tasks = []
            for user in users_to_notify:
                location_link = Text.format_location_link(event.location, event.latitude, event.longitude)
                safe_event_name = Text.escape_html(event.name)
                
                text = Text.NEW_EVENT_NOTIFICATION.format(
                    event_name=safe_event_name,
                    event_date=event.event_datetime.strftime('%d.%m.%Y'),
                    event_time=event.event_datetime.strftime('%H:%M'),
                    event_location=location_link 
                )
                tasks.append(
                    _send_notification_safe(
                        bot,
                        user, # ĞŸĞµÑ€ĞµĞ´Ğ°ĞµĞ¼ Ğ²ĞµÑÑŒ Ğ¾Ğ±ÑŠĞµĞºÑ‚ user
                        text,
                        parse_mode="HTML",
                        disable_web_page_preview=True
                    )
                )
            
            # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ²ÑĞµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ¾
            results = await asyncio.gather(*tasks)
            
            success_count = sum(1 for r in results if r)
            fail_count = total_users - success_count
            
            await status_message.edit_text(Text.MAILING_FINISHED_NOTIFICATION.format(success=success_count, fail=fail_count))
        except Exception as e:
            logger.error(f"Critical error during new event mailing for event {event.id}: {e}", exc_info=True)
            await status_message.edit_text(Text.MAILING_ERROR)


@router.callback_query(F.data == "admin_view_events", RoleFilter('admin'))
async def view_active_events(callback: types.CallbackQuery, session: AsyncSession):
    events = await event_requests.get_active_events(session)
    if not events:
        await callback.message.edit_text(Text.ADMIN_NO_ACTIVE_EVENTS, reply_markup=inline.get_events_management_keyboard())
        await callback.answer()
        return

    builder = InlineKeyboardBuilder()
    for event in events:
        prefix = "âœ…" if event.registration_is_open else "ğŸ”’"
        builder.row(types.InlineKeyboardButton(
            text=f"{prefix} {event.event_datetime.strftime('%d.%m')} - {event.name}", 
            callback_data=f"admin_show_event_{event.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_manage_events"))
    
    await callback.message.edit_text(Text.ADMIN_CHOOSE_EVENT_TO_MANAGE, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("admin_show_event_"), RoleFilter('admin'))
async def show_single_event_card(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event:
        await callback.answer(Text.EVENT_NOT_FOUND, show_alert=True)
        return
    
    reg_count = await admin_requests.get_event_registrations_count(session, event_id)
    donation_type_ru = Text.DONATION_TYPE_RU.get(event.donation_type, event.donation_type)
    
    feedback_count = await session.scalar(select(func.count(admin_requests.Feedback.id)).where(admin_requests.Feedback.event_id == event_id))
        
    text = Text.EVENT_CARD_TEMPLATE.format(
        name=hbold(event.name),
        date_header=hbold('Ğ”Ğ°Ñ‚Ğ°:'),
        datetime=event.event_datetime.strftime('%d.%m.%Y Ğ² %H:%M'),
        location_header=hbold('ĞœĞµÑÑ‚Ğ¾:'),
        location=Text.escape_html(event.location),
        blood_center_name=event.blood_center.name if event.blood_center else "ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½",
        type_header=hbold('Ğ¢Ğ¸Ğ¿ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸:'),
        donation_type=donation_type_ru,
        points_header=hbold('Ğ‘Ğ°Ğ»Ğ»Ñ‹:'),
        points_per_donation=event.points_per_donation,
        limit_header=hbold('Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¾/Ğ›Ğ¸Ğ¼Ğ¸Ñ‚:'),
        reg_count=reg_count,
        participant_limit=event.participant_limit,
        status_header=hbold('Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:'),
        is_active='ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾' if event.is_active else 'ĞÑ€Ñ…Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾',
        reg_status_header=hbold('Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ:'),
        reg_is_open='ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ°' if event.registration_is_open else 'Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°'
    )

    await callback.message.edit_text(
        text, 
        reply_markup=inline.get_single_event_management_keyboard(event.id, event.registration_is_open, has_feedback=(feedback_count > 0)), 
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_toggle_reg_"), RoleFilter('admin'))
async def toggle_event_registration(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    new_status = await admin_requests.toggle_event_registration_status(session, event_id)
    await session.commit()
    alert_text = Text.EVENT_TOGGLE_REG_OPEN if new_status else Text.EVENT_TOGGLE_REG_CLOSED
    await callback.answer(alert_text, show_alert=True)
    await show_single_event_card(callback, session)

@router.callback_query(F.data.startswith("admin_edit_event_"), RoleFilter('admin'))
async def start_event_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event: return
    
    await state.update_data(event_id=event_id)
    await state.set_state(EventEditing.choosing_field)
    
    fields = {"name": "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ", "event_date": "Ğ”Ğ°Ñ‚Ğ°", "location": "ĞœĞµÑÑ‚Ğ¾", "blood_center_id": "Ğ¦ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸", "points_per_donation": "Ğ‘Ğ°Ğ»Ğ»Ñ‹", "participant_limit": "Ğ›Ğ¸Ğ¼Ğ¸Ñ‚"}
    builder = InlineKeyboardBuilder()
    for key, name in fields.items():
        builder.row(types.InlineKeyboardButton(text=f"Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ: {name}", callback_data=f"edit_field_{key}"))
    builder.row(types.InlineKeyboardButton(text="âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ", callback_data=f"admin_show_event_{event_id}"))
    
    await callback.message.edit_text(Text.EVENT_EDIT_PROMPT.format(event_name=event.name), reply_markup=builder.as_markup(), parse_mode="HTML")
    await callback.answer()

@router.callback_query(EventEditing.choosing_field, F.data.startswith("edit_field_"))
async def choose_field_to_edit(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    field_to_edit = callback.data.split('_', 2)[-1]
    await state.update_data(field_to_edit=field_to_edit)

    if field_to_edit == "blood_center_id":
        await state.set_state(EventEditing.awaiting_new_value)
        blood_centers = await admin_requests.get_all_blood_centers(session)
        await callback.message.edit_text(
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ†ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸:",
            reply_markup=inline.get_blood_centers_keyboard(blood_centers, edit_mode=True)
        )
    else:
        await state.set_state(EventEditing.awaiting_new_value)
        prompt = Text.EVENT_EDIT_FIELD_PROMPTS.get(field_to_edit, "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ:")
        await callback.message.edit_text(prompt)

    await callback.answer()

@router.message(EventEditing.awaiting_new_value, F.text)
async def process_new_value_for_event(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    field, event_id, new_value_str = data.get("field_to_edit"), data.get("event_id"), message.text
    
    try:
        if field == "event_date": update_value = datetime.datetime.strptime(new_value_str, "%d.%m.%Y %H:%M")
        elif field in ["points_per_donation", "participant_limit"]: update_value = int(new_value_str)
        else: update_value = new_value_str
    except ValueError:
        await message.answer(Text.EVENT_EDIT_INVALID_FORMAT)
        return
        
    await admin_requests.update_event_field(session, event_id, field, update_value)
    await session.commit()
    await state.clear()
    await message.answer(Text.EVENT_EDIT_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())

@router.callback_query(EventEditing.awaiting_new_value, F.data.startswith("select_blood_center_"))
async def process_new_blood_center_for_event(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    event_id = data.get("event_id")
    new_blood_center_id = int(callback.data.split("_")[-1])

    await admin_requests.update_event_field(session, event_id, "blood_center_id", new_blood_center_id)
    await session.commit()
    await state.clear()
    await callback.message.edit_text(Text.EVENT_EDIT_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())


@router.callback_query(EventEditing.awaiting_new_value, F.data == "add_new_blood_center_edit")
async def add_new_blood_center_for_edit(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(EventEditing.awaiting_new_blood_center_name_for_edit)
    await callback.message.edit_text("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€Ğ° ĞºÑ€Ğ¾Ğ²Ğ¸:")


@router.message(EventEditing.awaiting_new_blood_center_name_for_edit)
async def process_new_blood_center_name_for_edit(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    event_id = data.get("event_id")
    new_blood_center = await admin_requests.create_blood_center(session, message.text)

    await admin_requests.update_event_field(session, event_id, "blood_center_id", new_blood_center.id)
    await session.commit()
    await state.clear()
    await message.answer(Text.EVENT_EDIT_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())

@router.callback_query(F.data.startswith("admin_event_participants_"), RoleFilter('admin'))
async def get_event_participants(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event, participants_regs = await admin_requests.get_event_with_participants(session, event_id)
    if not event: return await callback.answer(Text.EVENT_NOT_FOUND, show_alert=True)
    if not participants_regs: return await callback.answer(Text.EVENT_NO_PARTICIPANTS.format(event_name=event.name), show_alert=True)

    output = io.StringIO()
    writer = csv.writer(output, delimiter=';')
    writer.writerow(['ID', 'Ğ¤Ğ˜Ğ', 'Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½', 'Ğ¤Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚', 'Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ°', 'Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ'])
    for reg in participants_regs:
        writer.writerow([reg.user.id, reg.user.full_name, reg.user.phone_number, reg.user.faculty, reg.user.study_group, reg.status])
    
    output.seek(0)
    file = types.BufferedInputFile(output.getvalue().encode('utf-8-sig'), filename=f"participants_{event.id}.csv")
    await callback.message.answer_document(file, caption=Text.EVENT_PARTICIPANTS_CAPTION.format(event_name=event.name))
    await callback.answer()

@router.callback_query(F.data.startswith("admin_cancel_event_"), RoleFilter('admin'))
async def ask_for_cancellation_confirmation(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event: return await callback.answer(Text.EVENT_NOT_FOUND, show_alert=True)
    reg_count = await admin_requests.get_event_registrations_count(session, event_id)
    await callback.message.edit_text(
        Text.EVENT_CANCEL_CONFIRMATION.format(event_name=event.name, reg_count=reg_count),
        reply_markup=inline.get_event_cancellation_confirmation_keyboard(event_id),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_cancel_"), RoleFilter('admin'))
async def confirm_and_cancel_event(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    await callback.message.edit_text(Text.EVENT_CANCELLING_IN_PROGRESS)
    event_id = int(callback.data.split('_')[-1])
    event, participants_regs = await admin_requests.get_event_with_participants(session, event_id)
    if not event: return

    success_count, fail_count = 0, 0
    for reg in participants_regs:
        try:
            safe_event_name = Text.escape_html(event.name)
            safe_datetime = Text.escape_html(event.event_datetime.strftime('%d.%m.%Y Ğ² %H:%M'))
            text = Text.EVENT_CANCEL_NOTIFICATION_TEXT.format(
                event_name=safe_event_name,
                datetime=safe_datetime
            )
            await bot.send_message(chat_id=reg.user.telegram_id, text=text, parse_mode="HTML")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.error(f"Failed to send cancellation to user {reg.user_id} for event {event.id}. Error: {e}")
        await asyncio.sleep(0.1)

    await admin_requests.deactivate_event(session, event_id)
    await session.commit()
    await callback.message.edit_text(
        Text.EVENT_CANCEL_SUCCESS_REPORT.format(event_name=event.name, success=success_count, fail=fail_count),
        reply_markup=inline.get_back_to_events_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_view_feedback_"), RoleFilter('admin'))
async def view_event_feedback(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    feedbacks = await admin_requests.get_feedback_for_event(session, event_id)

    if not feedbacks:
        await callback.answer(Text.FEEDBACK_ADMIN_NO_FEEDBACK, show_alert=True)
        return

    report = Text.FEEDBACK_ADMIN_HEADER.format(event_name=Text.escape_html(event.name))
    for fb in feedbacks:
        report += Text.FEEDBACK_ADMIN_ITEM.format(
            user_name=Text.escape_html(fb.user.full_name),
            wb_score=fb.well_being_score or "-",
            wb_comment=Text.escape_html(fb.well_being_comment or "-"),
            org_score=fb.organization_score or "-",
            liked=Text.escape_html(fb.what_liked or "-"),
            disliked=Text.escape_html(fb.what_disliked or "-"),
            suggestions=Text.escape_html(fb.other_suggestions or "-")
        )
    
    try:
        await callback.message.delete()
    except Exception:
        logger.warning("Could not delete message in view_event_feedback")

    if len(report) > 4000: # Telegram message limit
        await callback.message.answer("ĞÑ‚Ğ·Ñ‹Ğ²Ğ¾Ğ² ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ¼Ğ½Ğ¾Ğ³Ğ¾, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ¼.")
        file = types.BufferedInputFile(report.encode('utf-8'), filename=f"feedback_{event_id}.txt")
        await callback.message.answer_document(file)
    else:
        try:
            await callback.message.answer(
                report,
                reply_markup=inline.get_back_to_events_menu_keyboard(),
                parse_mode="HTML"
            )
        except TelegramBadRequest:
            await callback.message.delete()
            await callback.message.answer(
                report,
                reply_markup=inline.get_back_to_events_menu_keyboard(),
                parse_mode="HTML"
            )
    
    await callback.answer()
    
    
    
@router.callback_query(F.data == "admin_post_process_dd", RoleFilter('admin'))
async def start_post_processing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ FSM: Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞµĞ³Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ."""
    await state.clear()
    past_events = await analytics_requests.get_past_events_for_analysis(session)
    if not past_events:
        await callback.answer("ĞĞµÑ‚ Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞ¸Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸.", show_alert=True)
        return

    await state.set_state(PostEventProcessing.choosing_event)
    await callback.message.edit_text(
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ, Ğ´Ğ»Ñ ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ³Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ½ĞµÑÑ‚Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ:",
        reply_markup=inline.get_events_for_post_processing_keyboard(past_events)
    )
    await callback.answer()

async def show_participant_marking_menu(message: types.Message, state: FSMContext, session: AsyncSession):
    """Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¼ĞµĞ½Ñ Ğ¾Ñ‚Ğ¼ĞµÑ‚ĞºĞ¸."""
    data = await state.get_data()
    event_id = data.get("event_id")
    marked_donations = data.get("marked_donations", set())
    marked_dkm = data.get("marked_dkm", set())

    _, participants = await admin_requests.get_event_with_participants(session, event_id)
    if not participants:
        await message.edit_text("ĞĞ° ÑÑ‚Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ¾ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ².", reply_markup=inline.get_back_to_events_menu_keyboard())
        await state.clear()
        return

    await message.edit_text(
        "ĞÑ‚Ğ¼ĞµÑ‚ÑŒÑ‚Ğµ, ĞºÑ‚Ğ¾ ÑĞ´Ğ°Ğ» ĞºÑ€Ğ¾Ğ²ÑŒ Ğ¸/Ğ¸Ğ»Ğ¸ Ğ²ÑÑ‚ÑƒĞ¿Ğ¸Ğ» Ğ² Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ğ”ĞšĞœ.\n(ğŸŸ¢ - Ğ¾Ñ‚Ğ¼ĞµÑ‡ĞµĞ½Ğ¾, âšªï¸ - Ğ½ĞµÑ‚)",
        reply_markup=inline.get_participant_marking_keyboard(event_id, participants, marked_donations, marked_dkm)
    )

@router.callback_query(PostEventProcessing.choosing_event, F.data.startswith("post_process_event_"))
async def choose_event_for_processing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Ğ¨Ğ°Ğ³ 2: ĞœĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾, Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²."""
    event_id = int(callback.data.split("_")[-1])
    await state.update_data(event_id=event_id, marked_donations=set(), marked_dkm=set())
    await state.set_state(PostEventProcessing.marking_participants)
    await show_participant_marking_menu(callback.message, state, session)
    await callback.answer()
    
@router.callback_query(PostEventProcessing.marking_participants, F.data.startswith("mark_participant_"))
async def mark_participant(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ½Ğ°Ğ¶Ğ°Ñ‚Ğ¸Ñ Ğ½Ğ° ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ¾Ñ‚Ğ¼ĞµÑ‚ĞºĞ¸ (toggle)."""
    _, _, event_id_str, user_id_str, action = callback.data.split("_")
    user_id = int(user_id_str)

    data = await state.get_data()
    target_set_name = "marked_donations" if action == "donation" else "marked_dkm"
    target_set = data.get(target_set_name, set())

    if user_id in target_set:
        target_set.remove(user_id)
    else:
        target_set.add(user_id)
    
    await state.update_data(**{target_set_name: target_set})
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ
    await show_participant_marking_menu(callback.message, state, session)
    await callback.answer()

@router.callback_query(PostEventProcessing.marking_participants, F.data.startswith("finish_marking_"))
async def finish_marking(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ°: ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ²ÑĞµ Ğ¾Ñ‚Ğ¼ĞµÑ‚ĞºĞ¸ Ğ² Ğ‘Ğ”."""
    data = await state.get_data()
    event_id = data.get("event_id")
    marked_donations = data.get("marked_donations", set())
    marked_dkm = data.get("marked_dkm", set())
    await state.clear()

    if not marked_donations:
        await callback.answer("ĞĞ¸ Ğ¾Ğ´Ğ¸Ğ½ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº Ğ½Ğµ Ğ¾Ñ‚Ğ¼ĞµÑ‡ĞµĞ½ ĞºĞ°Ğº ÑĞ´Ğ°Ğ²ÑˆĞ¸Ğ¹ ĞºÑ€Ğ¾Ğ²ÑŒ.", show_alert=True)
        return
        
    await callback.message.edit_text("â³ Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑÑ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ... Ğ­Ñ‚Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ·Ğ°Ğ½ÑÑ‚ÑŒ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ.")

    report_lines = []
    for user_id in marked_donations:
        is_dkm = user_id in marked_dkm
        success, message = await admin_requests.manually_confirm_donation(session, user_id, event_id, is_dkm)
        report_lines.append(message)
    
    await session.commit()
    
    final_report = "âœ… <b>ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°.</b>\n\n<b>Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹:</b>\n" + "\n".join(report_lines)
    await callback.message.edit_text(final_report, reply_markup=inline.get_back_to_events_menu_keyboard())
    await callback.answer("Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹!", show_alert=True)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/event_management.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/info_management.py ---

import logging
from aiogram import Router, F, types
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import info_requests
from bot.filters.role import RoleFilter
from bot.states.states import EditInfoSection
from bot.keyboards import inline

router = Router(name="admin_info_management")
logger = logging.getLogger(__name__)

@router.callback_query(F.data == "admin_edit_info", RoleFilter('admin'))
async def start_info_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    sections = await info_requests.get_all_info_sections(session)
    if not sections:
        await callback.answer("Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ñ‹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….", show_alert=True)
        return
        
    await state.set_state(EditInfoSection.choosing_section)
    await callback.message.edit_text(
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€Ğ°Ğ·Ğ´ĞµĞ», ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ:",
        reply_markup=inline.get_info_sections_for_editing_keyboard(sections)
    )
    await callback.answer()

@router.callback_query(EditInfoSection.choosing_section, F.data.startswith("edit_info_"))
async def choose_section_to_edit(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    section_key = callback.data.split("_", 2)[-1]
    current_text = await info_requests.get_info_text(session, section_key)
    
    await state.update_data(section_key=section_key)
    await state.set_state(EditInfoSection.awaiting_new_text)
    
    await callback.message.edit_text(
        f"<b>Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ñ‚ĞµĞºÑÑ‚ Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ° (Ğ´Ğ»Ñ ÑĞ¿Ñ€Ğ°Ğ²ĞºĞ¸):</b>\n\n{current_text}\n\n"
        f"<b>ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚. ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ HTML-Ñ‚ĞµĞ³Ğ¸.</b>",
        parse_mode="HTML"
    )
    await callback.answer()

@router.message(EditInfoSection.awaiting_new_text)
async def process_new_info_text(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    section_key = data.get("section_key")
    
    if not section_key:
        await message.answer("ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°.")
        await state.clear()
        return

    await info_requests.update_info_text(session, section_key, message.html_text)
    await state.clear()
    
    await message.answer(
        "âœ… Ğ¢ĞµĞºÑÑ‚ Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½!",
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/info_management.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/mailing.py ---

import logging
import asyncio
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError

from bot.db.engine import async_session_maker
from bot.db import user_requests, admin_requests
from bot.filters.role import RoleFilter
from bot.states.states import Mailing
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router(name="admin_mailing")
logger = logging.getLogger(__name__)


async def show_audience_choice_menu(message: types.Message, state: FSMContext):
    """ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°ĞµÑ‚ Ğ¼ĞµĞ½Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¸ Ñ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¼Ğ¸ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ğ¼Ğ¸."""
    data = await state.get_data()
    current_filters = data.get("filters", {})
    
    text_parts = [Text.MAILING_STEP_3_AUDIENCE_PROMPT]
    if current_filters:
        text_parts.append("\n<b>Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹:</b>")
        for key, value in current_filters.items():
            text_parts.append(f"  - {key.replace('_', ' ').capitalize()}: <code>{value}</code>")
    
    prompt_text = "\n".join(text_parts)

    await message.answer(
        text=prompt_text,
        reply_markup=inline.get_mailing_audience_keyboard(current_filters),
        parse_mode="HTML"
    )

# =============================================================================
# --- ğŸ“£ Ğ ĞĞ¡Ğ¡Ğ«Ğ›ĞšĞ˜ (FSM) ---
# =============================================================================

@router.callback_query(F.data == "admin_mailing", RoleFilter('admin'))
async def start_mailing(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 1: Ğ—Ğ°Ğ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°ĞµÑ‚ Ñ‚ĞµĞºÑÑ‚ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸."""
    await state.clear()
    await state.set_state(Mailing.awaiting_message_text)
    await callback.message.edit_text(Text.MAILING_STEP_1_TEXT_PROMPT, parse_mode="HTML")
    await callback.answer()


@router.message(Mailing.awaiting_message_text)
async def get_mailing_text(message: types.Message, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 2: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ñ‚ĞµĞºÑÑ‚ Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°ĞµÑ‚ Ğ¼ĞµĞ´Ğ¸Ğ°."""
    await state.update_data(
        message_text=message.html_text,
        photo_id=None,
        video_id=None,
        filters={}
    )
    await state.set_state(Mailing.awaiting_media)
    await message.answer(Text.MAILING_STEP_2_MEDIA_PROMPT, reply_markup=inline.get_skip_media_keyboard(), parse_mode="HTML")


@router.message(Mailing.awaiting_media, F.photo)
async def get_mailing_photo(message: types.Message, state: FSMContext):
    await state.update_data(photo_id=message.photo[-1].file_id)
    await state.set_state(Mailing.awaiting_audience_choice)
    await show_audience_choice_menu(message, state)


@router.message(Mailing.awaiting_media, F.video)
async def get_mailing_video(message: types.Message, state: FSMContext):
    await state.update_data(video_id=message.video.file_id)
    await state.set_state(Mailing.awaiting_audience_choice)
    await show_audience_choice_menu(message, state)


@router.callback_query(Mailing.awaiting_media, F.data == "skip_media")
async def skip_media_step(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(Mailing.awaiting_audience_choice)
    await callback.message.delete()
    await show_audience_choice_menu(callback.message, state)
    await callback.answer()


@router.callback_query(Mailing.awaiting_audience_choice, F.data.startswith("mail_audience_type_"))
async def choose_audience_filter_type(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Ğ¨Ğ°Ğ³ 3.1: ĞĞ´Ğ¼Ğ¸Ğ½ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» Ñ‚Ğ¸Ğ¿ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ° (Ğ’Ğ£Ğ—, Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚, Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ° ĞºÑ€Ğ¾Ğ²Ğ¸)."""
    filter_type = callback.data.split('_')[-1]
    
    items = []
    prompt_text = "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°"
    
    if filter_type == "university":
        items = await admin_requests.get_distinct_universities(session)
        prompt_text = "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ’Ğ£Ğ— Ğ´Ğ»Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸:"
    elif filter_type == "faculty":
        items = await admin_requests.get_distinct_faculties(session)
        prompt_text = "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚ Ğ´Ğ»Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸:"

    if not items:
        await callback.answer("ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°.", show_alert=True)
        return

    keyboard = inline.get_dynamic_mailing_filter_keyboard(items, filter_type, "mail_audience_back")
    await callback.message.edit_text(prompt_text, reply_markup=keyboard)
    await callback.answer()


@router.callback_query(Mailing.awaiting_audience_choice, F.data.startswith("mail_filter_"))
async def set_audience_filter(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¨Ğ°Ğ³ 3.2: ĞĞ´Ğ¼Ğ¸Ğ½ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ¼ĞµĞ½Ñ."""
    parts = callback.data.split('_')
    filter_key = parts[2]
    filter_value = '_'.join(parts[3:])

    data = await state.get_data()
    current_filters = data.get("filters", {})
    current_filters[filter_key] = filter_value
    await state.update_data(filters=current_filters)
    
    await callback.message.delete()
    await show_audience_choice_menu(callback.message, state)
    await callback.answer(f"Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ '{filter_value}' Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½!")


@router.callback_query(Mailing.awaiting_audience_choice, F.data == "mail_audience_back")
async def back_to_audience_choice_menu(callback: types.CallbackQuery, state: FSMContext):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğº Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¼Ñƒ Ğ¼ĞµĞ½Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ¸Ğ· Ğ¼ĞµĞ½Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ."""
    await callback.message.delete()
    await show_audience_choice_menu(callback.message, state)
    await callback.answer()


@router.callback_query(Mailing.awaiting_audience_choice, F.data == "mail_audience_reset")
async def reset_audience_filters(callback: types.CallbackQuery, state: FSMContext):
    """Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµÑ‚ Ğ²ÑĞµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹."""
    await state.update_data(filters={})
    await callback.message.delete()
    await show_audience_choice_menu(callback.message, state)
    await callback.answer("Ğ’ÑĞµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹ ÑĞ±Ñ€Ğ¾ÑˆĞµĞ½Ñ‹.", show_alert=True)


@router.callback_query(Mailing.awaiting_audience_choice, F.data == "mail_audience_finish")
async def finish_audience_selection(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Ğ¨Ğ°Ğ³ 4: ĞĞ´Ğ¼Ğ¸Ğ½ Ğ½Ğ°Ğ¶Ğ°Ğ» 'Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾'. ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ Ğº Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ."""
    data = await state.get_data()
    filters = data.get("filters", {})
    
    if not filters:
        await callback.answer("Ğ’Ñ‹ Ğ½Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ»Ğ¸ Ğ½Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°!", show_alert=True)
        return

    audience_text_parts = []
    for key, value in filters.items():
        audience_text_parts.append(f"{key.replace('_', ' ').capitalize()}: {value}")
    audience_text = " Ğ¸ ".join(audience_text_parts)

    users_to_notify = await user_requests.get_users_for_mailing(session, filters)
    recipient_count = len(users_to_notify)

    message_text = data.get("message_text")
    photo_id = data.get("photo_id")
    video_id = data.get("video_id")
    
    preview_text = Text.MAILING_PREVIEW_HEADER.format(audience=audience_text, count=recipient_count)
    if photo_id: preview_text += Text.MAILING_PREVIEW_WITH_PHOTO
    if video_id: preview_text += Text.MAILING_PREVIEW_WITH_VIDEO
    preview_text += Text.MAILING_PREVIEW_TEXT_HEADER.format(text=message_text)
            
    await state.set_state(Mailing.awaiting_confirmation)
    
    await callback.message.delete()
    await callback.message.answer(preview_text, reply_markup=inline.get_mailing_confirmation_keyboard(), parse_mode="HTML")
    await callback.answer()


# --- ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞº ---

@router.callback_query(Mailing.awaiting_confirmation, F.data == "confirm_mailing")
async def confirm_and_start_mailing(callback: types.CallbackQuery, state: FSMContext, bot: Bot):
    """Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµÑ‚ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºÑƒ Ğ² Ñ„Ğ¾Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğµ."""
    data = await state.get_data()
    await state.clear()
    
    await callback.message.edit_text(
        Text.MAILING_CONFIRMED_AND_RUNNING,
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )
    
    asyncio.create_task(do_mailing(
        filters=data.get("filters", {}),
        message_text=data.get("message_text"),
        photo_id=data.get("photo_id"),
        video_id=data.get("video_id"),
        bot=bot
    ))
    await callback.answer()


async def _send_broadcast_safe(bot: Bot, user_id: int, text: str, photo_id: str | None, video_id: str | None):
    """Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑˆĞ¸Ñ€Ğ¾ĞºĞ¾Ğ²ĞµÑ‰Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ."""
    try:
        if photo_id:
            await bot.send_photo(user_id, photo_id, caption=text, parse_mode="HTML")
        elif video_id:
            await bot.send_video(user_id, video_id, caption=text, parse_mode="HTML")
        else:
            await bot.send_message(user_id, text, parse_mode="HTML")
        return True
    except TelegramForbiddenError:
        logger.warning(f"Failed to send broadcast to user {user_id}. Bot was blocked or user deactivated.")
    except TelegramBadRequest as e:
         if "chat not found" in str(e):
             logger.warning(f"Failed to send broadcast to user {user_id}. Chat not found.")
         else:
             logger.error(f"Failed to send broadcast to user {user_id}. Error: {e}")
    except Exception as e:
        logger.error(f"Unexpected error sending broadcast to user {user_id}: {e}")
    return False


async def do_mailing(filters: dict, message_text: str, photo_id: str | None, video_id: str | None, bot: Bot):
    """ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ asyncio.gather."""
    logger.info(f"Starting mailing for filters: {filters}")
    async with async_session_maker() as session:
        try:
            users = await user_requests.get_users_for_mailing(session, filters)
            if not users:
                logger.warning("No users found for this mailing criteria.")
                return

            total_users = len(users)
            logger.info(f"Found {total_users} users for mailing.")

            tasks = [
                _send_broadcast_safe(bot, user.telegram_id, message_text, photo_id, video_id)
                for user in users
            ]

            results = await asyncio.gather(*tasks)

            success_count = sum(1 for r in results if r)
            fail_count = total_users - success_count

            logger.info(f"Mailing finished. Sent: {success_count}, Failed: {fail_count}.")

        except Exception as e:
            logger.error(f"Critical error during mailing: {e}", exc_info=True)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/mailing.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/merch_management.py ---

import logging
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.exceptions import TelegramBadRequest
from aiogram.utils.markdown import hbold, hlink
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload

from bot.db import admin_requests, user_requests
from bot.filters.role import RoleFilter
from bot.states.states import MerchCreation, MerchEditing
from bot.keyboards import inline
from bot.db.models import MerchOrder
from bot.utils.text_messages import Text

router = Router(name="admin_merch_management")
logger = logging.getLogger(__name__)


# =============================================================================
# --- ğŸ›ï¸ Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• ĞœĞĞ“ĞĞ—Ğ˜ĞĞĞœ ---
# =============================================================================
@router.callback_query(F.data == "admin_manage_merch", RoleFilter('admin'))
async def manage_merch_panel(callback: types.CallbackQuery):
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: parse_mode="HTML"
    await callback.message.edit_text(Text.ADMIN_MERCH_HEADER, reply_markup=inline.get_merch_management_keyboard(), parse_mode="HTML")
    await callback.answer()

# --- Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ° ---
@router.callback_query(F.data == "admin_create_merch", RoleFilter('admin'))
async def start_merch_creation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(MerchCreation.awaiting_photo)
    await callback.message.edit_text(Text.MERCH_CREATE_STEP_1_PHOTO)
    await callback.answer()

@router.message(MerchCreation.awaiting_photo, F.photo)
async def process_merch_photo(message: types.Message, state: FSMContext):
    photo_file_id = message.photo[-1].file_id
    await state.update_data(photo_file_id=photo_file_id)
    await state.set_state(MerchCreation.awaiting_name)
    await message.answer(Text.MERCH_PHOTO_RECEIVED)

@router.message(MerchCreation.awaiting_name)
async def process_merch_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(MerchCreation.awaiting_description)
    await message.answer(Text.MERCH_NAME_RECEIVED)

@router.message(MerchCreation.awaiting_description)
async def process_merch_description(message: types.Message, state: FSMContext):
    await state.update_data(description=message.text)
    await state.set_state(MerchCreation.awaiting_price)
    await message.answer(Text.MERCH_DESC_RECEIVED)
    
@router.message(MerchCreation.awaiting_price)
async def process_merch_price(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        price = int(message.text)
        await state.update_data(price=price)
        item_data = await state.get_data()
        
        if 'photo_file_id' not in item_data or not item_data['photo_file_id']:
            logger.error("photo_file_id is missing from FSM data during merch creation!")
            await message.answer(Text.MERCH_CREATE_PHOTO_ID_ERROR)
            await state.clear()
            return

        await admin_requests.create_merch_item(session, item_data)
        await session.commit()
        await state.clear()
        
        await message.answer(Text.MERCH_CREATE_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())
    except ValueError:
        await message.answer(Text.MERCH_PRICE_NAN_ERROR)

# --- ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ² ---
@router.callback_query(F.data == "admin_view_merch", RoleFilter('admin'))
async def view_merch_items(callback: types.CallbackQuery, session: AsyncSession):
    items = await admin_requests.get_all_merch_items(session)
    if not items:
        await callback.message.edit_text(Text.ADMIN_NO_MERCH_ITEMS, reply_markup=inline.get_merch_management_keyboard())
        return

    builder = InlineKeyboardBuilder()
    for item in items:
        status = "âœ…" if item.is_available else "âŒ"
        builder.row(types.InlineKeyboardButton(text=f"{status} {item.name} ({item.price}Ğ‘)", callback_data=f"admin_show_merch_{item.id}"))
    builder.row(types.InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_manage_merch"))

    try:
        await callback.message.edit_text(Text.ADMIN_CHOOSE_MERCH_TO_MANAGE, reply_markup=builder.as_markup())
    except TelegramBadRequest:
        await callback.message.delete()
        await callback.message.answer(Text.ADMIN_CHOOSE_MERCH_TO_MANAGE, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("admin_show_merch_"), RoleFilter('admin'))
async def show_single_merch_card(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer(Text.MERCH_ITEM_NOT_FOUND, show_alert=True)

    status_text = 'âœ… Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½' if item.is_available else 'âŒ ĞĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½'
    caption = Text.MERCH_CARD_CAPTION.format(
        name=item.name,
        description=item.description,
        price=item.price,
        status=status_text
    )
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: parse_mode="HTML"
    await callback.message.edit_media(media=types.InputMediaPhoto(media=item.photo_file_id, caption=caption, parse_mode="HTML"),
        reply_markup=inline.get_single_merch_management_keyboard(item.id, item.is_available))
    await callback.answer()

@router.callback_query(F.data.startswith("admin_edit_merch_"), RoleFilter('admin'))
async def start_merch_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return

    await state.update_data(item_id=item_id)
    await state.set_state(MerchEditing.choosing_field)
    
    fields = {"name": "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ", "description": "ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ", "price": "Ğ¦ĞµĞ½Ğ°"}
    builder = InlineKeyboardBuilder()
    for key, name in fields.items():
        builder.row(types.InlineKeyboardButton(text=f"Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ: {name}", callback_data=f"edit_merch_field_{key}"))
    builder.row(types.InlineKeyboardButton(text="âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ", callback_data=f"admin_show_merch_{item_id}"))
    
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: parse_mode="HTML"
    await callback.message.edit_caption(caption=Text.MERCH_EDIT_PROMPT.format(name=item.name), reply_markup=builder.as_markup(), parse_mode="HTML")

@router.callback_query(MerchEditing.choosing_field, F.data.startswith("edit_merch_field_"))
async def choose_merch_field_to_edit(callback: types.CallbackQuery, state: FSMContext):
    field_to_edit = callback.data.split('_', 3)[-1]
    await state.update_data(field_to_edit=field_to_edit)
    await state.set_state(MerchEditing.awaiting_new_value)
    
    prompt = Text.MERCH_EDIT_FIELD_PROMPTS.get(field_to_edit, Text.MERCH_EDIT_NEW_VALUE_PROMPT)
    await callback.message.delete()
    await callback.message.answer(prompt)
    await callback.answer()

@router.message(MerchEditing.awaiting_new_value)
async def process_new_value_for_merch(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    field, item_id, new_value_str = data.get("field_to_edit"), data.get("item_id"), message.text
    try:
        update_value = int(new_value_str) if field == "price" else new_value_str
    except ValueError:
        return await message.answer(Text.MERCH_PRICE_NAN_ERROR)

    await admin_requests.update_merch_item_field(session, item_id, field, update_value)
    await session.commit()
    await message.answer(Text.MERCH_EDIT_SUCCESS)
    await state.clear()
    
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    status_text = 'âœ… Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½' if item.is_available else 'âŒ ĞĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½'
    caption = Text.MERCH_CARD_CAPTION.format(
        name=item.name,
        description=item.description,
        price=item.price,
        status=status_text
    )
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: parse_mode="HTML"
    await message.answer_photo(photo=item.photo_file_id, caption=caption,
        reply_markup=inline.get_single_merch_management_keyboard(item.id, item.is_available), parse_mode="HTML")

@router.callback_query(F.data.startswith("admin_toggle_merch_"), RoleFilter('admin'))
async def toggle_merch_availability(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    new_status = await admin_requests.toggle_merch_item_availability(session, item_id)
    await session.commit()
    status_text = 'Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½' if new_status else 'Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½'
    await callback.answer(Text.MERCH_TOGGLE_AVAILABILITY.format(status=status_text), show_alert=True)
    await show_single_merch_card(callback, session)

@router.callback_query(F.data.startswith("admin_delete_merch_"), RoleFilter('admin'))
async def ask_for_merch_deletion_confirmation(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer(Text.MERCH_ITEM_NOT_FOUND, show_alert=True)
    
    try: await callback.message.delete()
    except TelegramBadRequest: pass
    
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: parse_mode="HTML"
    await callback.message.answer(
        Text.MERCH_DELETE_CONFIRMATION.format(name=item.name),
        reply_markup=inline.get_merch_deletion_confirmation_keyboard(item_id), parse_mode="HTML")
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_delete_merch_"), RoleFilter('admin'))
async def confirm_and_delete_merch(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer(Text.MERCH_ITEM_ALREADY_DELETED, show_alert=True)
    
    item_name = item.name
    await admin_requests.delete_merch_item_by_id(session, item_id)
    await session.commit()
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: parse_mode="HTML"
    await callback.message.edit_text(Text.MERCH_DELETE_SUCCESS.format(name=item_name), reply_markup=inline.get_back_to_merch_menu_keyboard(), parse_mode="HTML")
    await callback.answer()

# =============================================================================
# --- ğŸ“¦ ĞĞ‘Ğ ĞĞ‘ĞĞ¢ĞšĞ Ğ—ĞĞšĞĞ—ĞĞ’ ---
# =============================================================================
@router.callback_query(F.data == "admin_process_orders", RoleFilter('admin'))
async def process_orders_list(callback: types.CallbackQuery, session: AsyncSession):
    orders = await admin_requests.get_pending_orders(session)
    if not orders:
        await callback.answer(Text.ADMIN_NO_PENDING_ORDERS, show_alert=True)
        return
    
    text_parts = [Text.ADMIN_PENDING_ORDERS_HEADER]
    builder = InlineKeyboardBuilder()
    for order in orders:
        user_link = hlink(order.user.full_name, f"tg://user?id={order.user.telegram_id}")
        
        if order.user.telegram_username:
            order_info = Text.ADMIN_ORDER_ITEM_TEXT.format(
                order_id=order.id,
                date=order.order_date.strftime('%d.%m %H:%M'),
                item_name=order.item.name,
                user_link=user_link,
                username=order.user.telegram_username,
                phone=order.user.phone_number
            )
        else:
            order_info = Text.ADMIN_ORDER_ITEM_TEXT_NO_USERNAME.format(
                order_id=order.id,
                date=order.order_date.strftime('%d.%m %H:%M'),
                item_name=order.item.name,
                user_link=user_link,
                phone=order.user.phone_number
            )

        text_parts.append(order_info)
        text_parts.append("")
        builder.row(types.InlineKeyboardButton(text=f"âœ… Ğ’Ñ‹Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ· â„–{order.id}", callback_data=f"complete_order_{order.id}"))
    
    builder.row(types.InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_panel"))
    
    await callback.message.edit_text(
        text="\n".join(text_parts), 
        reply_markup=builder.as_markup(), 
        parse_mode="HTML",
        disable_web_page_preview=True
    )
    await callback.answer()
    
@router.callback_query(F.data.startswith("complete_order_"), RoleFilter('admin'))
async def complete_order(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    order_id = int(callback.data.split('_')[-1])
    
    admin_user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not admin_user:
        await callback.answer(Text.ADMIN_COMPLETE_ORDER_ADMIN_ID_ERROR, show_alert=True)
        return

    order = await session.get(MerchOrder, order_id, options=[joinedload(MerchOrder.item), joinedload(MerchOrder.user)])
    if not order or order.status != 'pending_pickup':
        await callback.answer(Text.ADMIN_ORDER_NOT_FOUND_OR_PROCESSED, show_alert=True)
        return

    await admin_requests.complete_order(session, order_id, admin_user.id)
    await session.commit()
    await callback.answer(Text.ADMIN_ORDER_COMPLETED_SUCCESS.format(order_id=order_id), show_alert=True)
    
    try:
        await bot.send_message(
            chat_id=order.user.telegram_id,
            text=Text.USER_ORDER_COMPLETED_NOTIFICATION.format(item_name=order.item.name)
        )
    except Exception as e:
        logger.error(f"Failed to notify user {order.user.id} about order completion: {e}")
    
    await process_orders_list(callback, session)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/merch_management.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/qa_management.py ---

from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload

from bot.db import question_requests, user_requests
from bot.filters.role import RoleFilter
from bot.states.states import AnswerQuestion
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router(name="admin_qa_management")

@router.callback_query(F.data == "admin_answer_questions", RoleFilter('admin'))
async def show_unanswered_questions(callback: types.CallbackQuery, session: AsyncSession):
    questions = await question_requests.get_unanswered_questions(session)
    if not questions:
        await callback.answer("ĞĞ¾Ğ²Ñ‹Ñ… Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ½ĞµÑ‚.", show_alert=True)
        return

    builder = InlineKeyboardBuilder()
    for q in questions:
        builder.row(types.InlineKeyboardButton(
            text=f"ĞÑ‚ {q.user.full_name}: {q.question_text[:30]}...",
            callback_data=f"answer_q_{q.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_panel"))
    
    await callback.message.edit_text(
        "<b>ĞĞµĞ¾Ñ‚Ğ²ĞµÑ‡ĞµĞ½Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹:</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¸Ñ‚ÑŒ:",
        reply_markup=builder.as_markup(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("answer_q_"), RoleFilter('admin'))
async def start_answering_question(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    question_id = int(callback.data.split("_")[-1])
    question = await session.get(question_requests.Question, question_id, options=[joinedload(question_requests.Question.user)])
    if not question:
        await callback.answer("Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.", show_alert=True)
        return
        
    await state.set_state(AnswerQuestion.awaiting_answer)
    await state.update_data(question_id=question.id, user_to_answer_id=question.user.telegram_id)
    
    await callback.message.edit_text(
        f"<b>Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¾Ñ‚:</b> {question.user.full_name}\n"
        f"<b>Ğ¢ĞµĞºÑÑ‚ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°:</b>\n<i>{Text.escape_html(question.question_text)}</i>\n\n"
        f"<b>Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ¾Ñ‚Ğ²ĞµÑ‚:</b>",
        parse_mode="HTML"
    )
    await callback.answer()

@router.message(AnswerQuestion.awaiting_answer)
async def process_answer(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    question_id = data.get("question_id")
    user_to_answer_id = data.get("user_to_answer_id")
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    
    await question_requests.answer_question(session, question_id, message.text, admin_user.id)
    
    question = await session.get(question_requests.Question, question_id)

    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    try:
        await bot.send_message(
            chat_id=user_to_answer_id,
            text=(
                f"ğŸ“¨ <b>ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ½Ğ° Ğ²Ğ°Ñˆ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ!</b>\n\n"
                f"<b>Ğ’Ğ°Ñˆ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ:</b>\n<i>{Text.escape_html(question.question_text)}</i>\n\n"
                f"<b>ĞÑ‚Ğ²ĞµÑ‚ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²:</b>\n{Text.escape_html(message.text)}"
            ),
            parse_mode="HTML"
        )
    except Exception as e:
        await message.answer(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ. ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")

    await state.clear()
    await message.answer("âœ… ĞÑ‚Ğ²ĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.", reply_markup=inline.get_back_to_admin_panel_keyboard())

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/qa_management.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/system.py ---

import io
import logging
import zipfile
import datetime
import pandas as pd
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext  # <-- Ğ’ĞĞ¢ ĞĞ£Ğ–ĞĞ«Ğ™ Ğ˜ĞœĞŸĞĞ Ğ¢
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests, user_requests
from bot.db.models import User
from bot.filters.role import RoleFilter
from bot.states.states import DataImport
from bot.utils.text_messages import Text

router = Router(name="admin_system")
logger = logging.getLogger(__name__)


# =============================================================================
# --- ğŸ’¾ Ğ­ĞšĞ¡ĞŸĞĞ Ğ¢ Ğ”ĞĞĞĞ«Ğ¥ (Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ”Ğ›Ğ¯ Ğ“Ğ›ĞĞ’ĞĞĞ“Ğ ĞĞ”ĞœĞ˜ĞĞ) ---
# =============================================================================

async def create_full_backup_xlsx(session: AsyncSession) -> io.BytesIO:
    """
    Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· Ğ²ÑĞµÑ… Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†, ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ XLSX-Ñ„Ğ°Ğ¹Ğ» Ñ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ğ¼Ğ¸ Ğ»Ğ¸ÑÑ‚Ğ°Ğ¼Ğ¸.
    """
    all_data_models = await admin_requests.get_all_data_for_export(session)
    
    output_buffer = io.BytesIO()
    with pd.ExcelWriter(output_buffer, engine='openpyxl') as writer:
        for table_name, records in all_data_models.items():
            if not records:
                continue

            data_list = [
                {c.name: getattr(record, c.name) for c in record.__table__.columns}
                for record in records
            ]
            
            df = pd.DataFrame(data_list)
            for col in df.columns:
                if pd.api.types.is_datetime64_any_dtype(df[col]) and df[col].dt.tz is not None:
                    df[col] = df[col].dt.tz_localize(None)
            for col in df.columns:
                if not df[col].dropna().empty:
                    if isinstance(df[col].dropna().iloc[0], (dict, list)):
                        df[col] = df[col].astype(str)
            
            df.to_excel(writer, sheet_name=table_name.capitalize(), index=False)

    output_buffer.seek(0)
    return output_buffer


@router.callback_query(F.data == "ma_export_data", RoleFilter('main_admin'))
async def export_data_start(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """
    Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµÑ‚ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ Ğ±ÑĞºĞ°Ğ¿Ğ° Ğ² XLSX.
    """
    msg = await callback.message.edit_text(Text.EXPORT_STARTED)
    await callback.answer()

    try:
        xlsx_archive_bytes = await create_full_backup_xlsx(session)
        
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")
        filename = f"donor_bot_backup_{timestamp}.xlsx"
        
        await bot.send_document(
            chat_id=callback.from_user.id,
            document=types.BufferedInputFile(xlsx_archive_bytes.read(), filename=filename),
            caption=Text.EXPORT_SUCCESSFUL
        )
        
        await msg.delete()

    except Exception as e:
        logger.error(f"Failed to create data backup: {e}", exc_info=True)
        await msg.edit_text(Text.EXPORT_FAILED)


# =============================================================================
# --- ğŸ“¥ Ğ˜ĞœĞŸĞĞ Ğ¢ Ğ”ĞĞĞĞ«Ğ¥ (Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ”Ğ›Ğ¯ Ğ“Ğ›ĞĞ’ĞĞĞ“Ğ ĞĞ”ĞœĞ˜ĞĞ) ---
# =============================================================================

@router.callback_query(F.data == "ma_import_data", RoleFilter('main_admin'))
async def import_data_start(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(DataImport.awaiting_file)
    await callback.message.edit_text("ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ .xlsx Ñ„Ğ°Ğ¹Ğ» Ğ´Ğ»Ñ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ°/Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹. ĞĞ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºĞ¾Ğ»Ğ¾Ğ½ĞºĞ¸: `phone_number` (Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ°), `full_name`, `university`.")
    await callback.answer()

@router.callback_query(F.data == "ma_import_old_db", RoleFilter('main_admin'))
async def import_old_db_start(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(DataImport.awaiting_old_db_file)
    await callback.message.edit_text("ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ .xlsx Ñ„Ğ°Ğ¹Ğ» Ğ´Ğ»Ñ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ° ÑÑ‚Ğ°Ñ€Ğ¾Ğ¹ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….")
    await callback.answer()


from bot.utils.data_import import import_data_from_file

@router.message(DataImport.awaiting_old_db_file, F.document)
async def process_import_old_db_file(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    if not message.document.file_name.endswith('.xlsx'):
        await message.answer("ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ñ„Ğ°Ğ¹Ğ»Ğ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ñ„Ğ°Ğ¹Ğ» .xlsx")
        return

    await state.clear()
    status_msg = await message.answer("Ğ¤Ğ°Ğ¹Ğ» Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½. ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ...")
    
    file_info = await bot.get_file(message.document.file_id)
    file_bytes = await bot.download_file(file_info.file_path)

    try:
        created_count, updated_count = await import_data_from_file(session, file_bytes)
        await status_msg.edit_text(f"âœ… Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½!\n\n- Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {created_count}\n- ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ñ…: {updated_count}")
        
    except Exception as e:
        logger.error(f"Error processing XLSX import: {e}", exc_info=True)
        await status_msg.edit_text(f"âŒ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ Ñ„Ğ°Ğ¹Ğ»Ğ°: {e}")

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/system.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/user_management.py ---

# Ğ¤ĞĞ™Ğ›: bot/handlers/admin/user_management.py

import logging
import datetime
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.markdown import hbold, hcode
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests, user_requests, event_requests
from bot.filters.role import RoleFilter
from bot.states.states import (
    PointsChange,
    ManualWaiver,
    UserSearch,
    BlockUser,
    AdminAddUser,
    UserEditing
)
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router(name="admin_user_management")
logger = logging.getLogger(__name__)


# =============================================================================
# --- ğŸ‘¥ Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• ĞŸĞĞ›Ğ¬Ğ—ĞĞ’ĞĞ¢Ğ•Ğ›Ğ¯ĞœĞ˜ (Ğ‘ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ¾ ÑĞµĞºÑ†Ğ¸Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ) ---
# =============================================================================

@router.callback_query(F.data == "admin_manage_users", RoleFilter('admin'))
async def manage_users_main_menu(callback: types.CallbackQuery):
    """ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸."""
    await callback.message.edit_text(
        Text.ADMIN_USERS_HEADER,
        reply_markup=inline.get_user_management_main_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

# --- Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸ĞµĞ¹ ---
@router.callback_query(F.data.startswith("admin_users_list_page_"), RoleFilter('admin'))
async def show_users_list(callback: types.CallbackQuery, session: AsyncSession):
    page = int(callback.data.split('_')[-1])
    page_size = 10

    users, total_pages = await admin_requests.get_users_page(session, page, page_size)

    if not users:
        await callback.message.edit_text(Text.ADMIN_NO_USERS_IN_DB, reply_markup=inline.get_user_management_main_keyboard())
        await callback.answer()
        return

    text = Text.USERS_LIST_HEADER.format(page=page, total_pages=total_pages)
    builder = InlineKeyboardBuilder()
    for user in users:
        builder.row(types.InlineKeyboardButton(text=f"ğŸ‘¤ {user.full_name}", callback_data=f"admin_show_user_{user.id}"))

    pagination_keyboard = inline.get_users_list_pagination_keyboard(page, total_pages)
    for row in pagination_keyboard.inline_keyboard:
        builder.row(*row)

    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode="HTML")
    await callback.answer()

# --- ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ ---
@router.callback_query(F.data == "admin_search_user", RoleFilter('admin'))
async def search_user_start(callback: types.CallbackQuery, state: FSMContext):
    """Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµÑ‚ FSM Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
    await state.clear()
    await state.set_state(UserSearch.awaiting_query)
    await callback.message.edit_text(Text.USER_SEARCH_PROMPT)
    await callback.answer()

@router.message(UserSearch.awaiting_query)
async def process_user_search(message: types.Message, state: FSMContext, session: AsyncSession):
    """Ğ˜Ñ‰ĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ¿Ğ¾ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑƒ Ğ¸ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ñ‚ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚."""
    await state.clear()
    query = message.text
    users_found = await admin_requests.find_user_for_admin(session, query)

    if not users_found:
        await message.answer(Text.USER_SEARCH_NO_RESULTS, reply_markup=inline.get_user_management_main_keyboard())
        return

    text = Text.USER_SEARCH_RESULTS_HEADER.format(query=query)
    builder = InlineKeyboardBuilder()
    for user in users_found:
        builder.row(types.InlineKeyboardButton(text=f"ğŸ‘¤ {user.full_name}", callback_data=f"admin_show_user_{user.id}"))
    builder.row(types.InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_manage_users"))

    await message.answer(text, reply_markup=builder.as_markup(), parse_mode="HTML")

# --- ĞšĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ¼ ---
@router.callback_query(F.data.startswith("admin_show_user_"), RoleFilter('admin'))
async def show_single_user_card(callback: types.CallbackQuery, session: AsyncSession):
    """ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ñ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ¾Ğ¹."""
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer: return

    target_user_id = int(callback.data.split('_')[-1])
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await callback.answer(Text.USER_NOT_FOUND, show_alert=True)
        return

    block_status = "Ğ—ĞĞ‘Ğ›ĞĞšĞ˜Ğ ĞĞ’ĞĞ" if target_user.is_blocked else "ĞĞºÑ‚Ğ¸Ğ²ĞµĞ½"

    text = "\n".join([
        hbold(Text.USER_CARD_HEADER.format(full_name=target_user.full_name)),
        "",
        Text.USER_CARD_TEMPLATE.format(
            full_name=Text.escape_html(target_user.full_name),
            telegram_id=target_user.telegram_id,
            username=Text.escape_html(target_user.telegram_username or 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½'),
            phone_number=target_user.phone_number,
            role=target_user.role,
            points=target_user.points,
            block_status=block_status
        )
    ])

    await callback.message.edit_text(
        text,
        reply_markup=inline.get_user_management_keyboard(
            target_user_id=target_user.id,
            target_user_role=target_user.role,
            viewer_role=viewer.role,
            is_blocked=target_user.is_blocked
        ),
        parse_mode="HTML"
    )
    await callback.answer()

# --- +/- Ğ‘Ğ°Ğ»Ğ»Ñ‹ (FSM) ---
@router.callback_query(F.data.startswith("admin_points_"), RoleFilter('admin'))
async def change_points_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    user_id = int(callback.data.split('_')[-1])
    await state.update_data(user_id=user_id)
    await state.set_state(PointsChange.awaiting_points_amount)
    await callback.message.edit_text(Text.CHANGE_POINTS_PROMPT)
    await callback.answer()

@router.message(PointsChange.awaiting_points_amount)
async def change_points_amount(message: types.Message, state: FSMContext):
    try:
        points = int(message.text)
        await state.update_data(points=points)
        await state.set_state(PointsChange.awaiting_reason)
        await message.answer(Text.CHANGE_POINTS_REASON_PROMPT)
    except ValueError:
        await message.answer(Text.EVENT_POINTS_NAN_ERROR)

@router.message(PointsChange.awaiting_reason)
async def change_points_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason, user_id, points_change = message.text, data['user_id'], data['points']
    
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await message.answer(Text.USER_NOT_FOUND)
        await state.clear()
        return

    await admin_requests.add_points_to_user(session, user_id, points_change, reason)
    await session.commit()
    await state.clear()

    new_balance = user.points
    await message.answer(
        Text.CHANGE_POINTS_SUCCESS.format(name=user.full_name, balance=new_balance),
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )

    try:
        await bot.send_message(
            chat_id=user.telegram_id, # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
            text=Text.USER_POINTS_CHANGED_NOTIFICATION.format(points=points_change, reason=reason, balance=new_balance),
            parse_mode="HTML"
        )
    except Exception as e:
        logger.error(f"Failed to notify user {user_id} about points change: {e}")

# --- Ğ ÑƒÑ‡Ğ½Ğ¾Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ€Ğ¾Ğ»ÑĞ¼Ğ¸ ---
@router.callback_query(F.data.startswith("admin_promote_volunteer_"), RoleFilter('admin'))
async def promote_to_volunteer(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, user_id, 'volunteer')
    await session.commit()
    user = await user_requests.get_user_by_id(session, user_id)
    await callback.answer(Text.USER_PROMOTED_VOLUNTEER.format(name=user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=user.telegram_id, text=Text.USER_PROMOTED_VOLUNTEER_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {user.id} about promotion: {e}")
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("admin_demote_volunteer_"), RoleFilter('admin'))
async def demote_from_volunteer(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, user_id, 'student')
    await session.commit()
    user = await user_requests.get_user_by_id(session, user_id)
    await callback.answer(Text.USER_DEMOTED_VOLUNTEER.format(name=user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=user.telegram_id, text=Text.USER_DEMOTED_VOLUNTEER_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {user.id} about demotion: {e}")
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("ma_promote_admin_"), RoleFilter('main_admin'))
async def promote_to_admin(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    target_user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, target_user_id, 'admin')
    await session.commit()
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    await callback.answer(Text.USER_PROMOTED_ADMIN.format(name=target_user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=target_user.telegram_id, text=Text.USER_PROMOTED_ADMIN_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about admin promotion: {e}")
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("ma_demote_admin_"), RoleFilter('main_admin'))
async def demote_from_admin(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    target_user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, target_user_id, 'student')
    await session.commit()
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    await callback.answer(Text.USER_DEMOTED_ADMIN.format(name=target_user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=target_user.telegram_id, text=Text.USER_DEMOTED_ADMIN_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about admin demotion: {e}")
    await show_single_user_card(callback, session)

# --- Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°Ğ¼Ğ¸ ---
@router.callback_query(F.data.startswith("ma_block_user_"), RoleFilter('main_admin'))
async def block_user_from_card(callback: types.CallbackQuery, state: FSMContext):
    target_user_id = int(callback.data.split('_')[-1])
    await state.clear()
    await state.update_data(user_id=target_user_id)
    await state.set_state(BlockUser.awaiting_reason)
    await callback.message.edit_text(Text.BLOCK_USER_REASON_PROMPT)
    await callback.answer()

@router.message(BlockUser.awaiting_reason)
async def process_block_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason = message.text
    target_user_id = data['user_id']

    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    if not admin_user:
        await message.answer(Text.ADMIN_ID_ERROR)
        await state.clear()
        return

    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await message.answer(Text.BLOCK_TARGET_USER_NOT_FOUND)
        await state.clear()
        return

    await admin_requests.block_user(session, target_user_id, admin_user.id, reason)
    await session.commit()
    await state.clear()

    await message.answer(
        Text.USER_BLOCKED_SUCCESS.format(name=target_user.full_name, reason=reason),
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )
    try:
        await bot.send_message(chat_id=target_user.telegram_id, text=Text.USER_BLOCKED_NOTIFY.format(reason=reason))
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about block: {e}")

@router.callback_query(F.data.startswith("ma_unblock_user_"), RoleFilter('main_admin'))
async def unblock_user_from_card(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    target_user_id = int(callback.data.split('_')[-1])
    await admin_requests.unblock_user(session, target_user_id)
    await session.commit()
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await callback.answer(Text.USER_NOT_FOUND, show_alert=True)
        return

    await callback.answer(Text.USER_UNBLOCKED_SUCCESS.format(name=target_user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=target_user.telegram_id, text=Text.USER_UNBLOCKED_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about unblock: {e}")
    await show_single_user_card(callback, session)


# --- Ğ ÑƒÑ‡Ğ½Ğ¾Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸ ---
@router.callback_query(F.data.startswith("admin_manage_user_regs_"), RoleFilter('admin'))
async def manage_user_registrations_menu(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await callback.answer(Text.USER_NOT_FOUND, show_alert=True)
        return

    await callback.message.edit_text(
        Text.MANAGE_USER_REGS_HEADER.format(name=user.full_name),
        reply_markup=inline.get_manual_registration_management_keyboard(user_id),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_reg_start_"), RoleFilter('admin'))
async def show_events_for_manual_registration(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    events = await event_requests.get_upcoming_events(session)
    if not events:
        await callback.answer(Text.MANUAL_REG_NO_EVENTS, show_alert=True)
        return

    await callback.message.edit_text(
        Text.MANUAL_REG_CHOOSE_EVENT,
        reply_markup=inline.get_events_for_manual_registration_keyboard(user_id, events)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("adminReg_"), RoleFilter('admin'))
async def confirm_manual_registration(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    _, user_id_str, event_id_str = callback.data.split('_')
    user_id, event_id = int(user_id_str), int(event_id_str)
    
    user = await user_requests.get_user_by_id(session, user_id)
    event = await event_requests.get_event_by_id(session, event_id)
    if not user or not event:
        await callback.answer(Text.ERROR_GENERIC_ALERT, show_alert=True)
        return

    success, message = await admin_requests.manually_register_user(session, user, event)
    if success:
        await session.commit()
        try:
            await bot.send_message(
                chat_id=user.telegram_id,
                text=Text.MANUAL_REG_SUCCESS_NOTIFY.format(event_name=event.name, date=event.event_datetime.strftime('%d.%m.%Y')),
                parse_mode="HTML"
            )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about manual registration: {e}")
            await callback.message.answer(Text.NOTIFY_USER_FAILED.format(name=user.full_name))
    else:
        await session.rollback()

    await callback.answer(message, show_alert=True)
    # This might fail if the original message was deleted, need a robust way to return to menu
    try:
        await manage_user_registrations_menu(callback, session)
    except Exception:
        await callback.message.answer("Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ¼ĞµĞ½Ñ...", reply_markup=inline.get_back_to_admin_panel_keyboard())


@router.callback_query(F.data.startswith("admin_cancel_start_"), RoleFilter('admin'))
async def show_registrations_for_cancellation(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    registrations = await admin_requests.get_user_registrations(session, user_id)
    
    if not registrations:
        await callback.answer(Text.MANUAL_CANCEL_NO_REGS, show_alert=True)
        return

    await callback.message.edit_text(
        Text.MANUAL_CANCEL_CHOOSE_REG,
        reply_markup=inline.get_registrations_for_cancellation_keyboard(user_id, registrations)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("adminCancel_"), RoleFilter('admin'))
async def confirm_manual_cancellation(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    _, user_id_str, event_id_str = callback.data.split('_')
    user_id, event_id = int(user_id_str), int(event_id_str)

    user = await user_requests.get_user_by_id(session, user_id)
    event = await event_requests.get_event_by_id(session, event_id)
    if not user or not event:
        await callback.answer(Text.ERROR_GENERIC_ALERT, show_alert=True)
        return
        
    success = await event_requests.cancel_registration(session, user_id, event_id)
    if success:
        await session.commit()
        await callback.answer(Text.MANUAL_CANCEL_SUCCESS.format(name=user.full_name, event_name=event.name), show_alert=True)
        try:
            await bot.send_message(
                chat_id=user.telegram_id,
                text=Text.MANUAL_CANCEL_SUCCESS_NOTIFY.format(event_name=event.name),
                parse_mode="HTML"
            )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about manual cancellation: {e}")
            await callback.message.answer(Text.NOTIFY_USER_FAILED.format(name=user.full_name))
    else:
        await session.rollback()
        await callback.answer(Text.MANUAL_CANCEL_FAIL, show_alert=True)
    
    try:
        await manage_user_registrations_menu(callback, session)
    except Exception:
         await callback.message.answer("Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ¼ĞµĞ½Ñ...", reply_markup=inline.get_back_to_admin_panel_keyboard())


# --- Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°Ğ¼Ğ¸ ---
@router.callback_query(F.data.startswith("admin_manage_waivers_"), RoleFilter('admin'))
async def admin_manage_user_waivers_menu(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await callback.answer(Text.USER_NOT_FOUND, show_alert=True)
        return

    waivers = await admin_requests.get_all_user_active_waivers(session, user_id)
    text_header = Text.MANAGE_WAIVERS_HEADER.format(name=user.full_name)
    if not waivers:
        text = text_header + Text.MANAGE_WAIVERS_NO_WAIVERS
    else:
        text = text_header + Text.MANAGE_WAIVERS_WITH_WAIVERS

    await callback.message.edit_text(
        text,
        reply_markup=inline.get_admin_waiver_management_keyboard(user_id, waivers),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_waiver_"), RoleFilter('admin'))
async def set_waiver_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    user_id = int(callback.data.split('_')[-1])
    await state.update_data(user_id=user_id)
    await state.set_state(ManualWaiver.awaiting_end_date)
    await callback.message.edit_text(Text.MANUAL_WAIVER_DATE_PROMPT)
    await callback.answer()

@router.message(ManualWaiver.awaiting_end_date)
async def set_waiver_date(message: types.Message, state: FSMContext):
    try:
        end_date = datetime.datetime.strptime(message.text, "%d.%m.%Y").date()
        await state.update_data(end_date=end_date)
        await state.set_state(ManualWaiver.awaiting_reason)
        await message.answer(Text.MANUAL_WAIVER_REASON_PROMPT)
    except ValueError:
        await message.answer(Text.DATE_FORMAT_ERROR, parse_mode="HTML")

@router.message(ManualWaiver.awaiting_reason)
async def set_waiver_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason, user_id, end_date = message.text, data['user_id'], data['end_date']
    
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    user = await user_requests.get_user_by_id(session, user_id)

    await admin_requests.create_manual_waiver(session, user_id, end_date, reason, admin_user.id)
    await session.commit()
    await state.clear()

    await message.answer(
        Text.MANUAL_WAIVER_SUCCESS.format(name=user.full_name, date=end_date.strftime('%d.%m.%Y')),
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )
    try:
        await bot.send_message(
            chat_id=user.telegram_id,
            text=Text.MANUAL_WAIVER_NOTIFY.format(date=end_date.strftime('%d.%m.%Y'), reason=reason),
            parse_mode="HTML"
        )
    except Exception as e:
        logger.error(f"Failed to notify user {user_id} about manual waiver: {e}")

@router.callback_query(F.data.startswith("admin_del_waiver_"), RoleFilter('admin'))
async def admin_delete_waiver(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    try:
        _, _, _, waiver_id_str, user_id_str = callback.data.split('_')
        waiver_id, user_id = int(waiver_id_str), int(user_id_str)
    except ValueError:
        await callback.answer(Text.ADMIN_DELETE_WAIVER_DATA_ERROR, show_alert=True)
        return

    success = await admin_requests.force_delete_waiver(session, waiver_id)
    if success:
        await session.commit()
        await callback.answer(Text.ADMIN_DELETE_WAIVER_SUCCESS, show_alert=True)
        try:
            user = await user_requests.get_user_by_id(session, user_id)
            if user:
                await bot.send_message(chat_id=user.telegram_id, text=Text.ADMIN_DELETE_WAIVER_NOTIFY)
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about admin waiver deletion: {e}")
    else:
        await session.rollback()
        await callback.answer(Text.ADMIN_DELETE_WAIVER_FAIL, show_alert=True)
    
    try:
        await admin_manage_user_waivers_menu(callback, session)
    except Exception:
        await callback.message.answer("Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ¼ĞµĞ½Ñ...", reply_markup=inline.get_back_to_admin_panel_keyboard())

# --- Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ ---
@router.callback_query(F.data.startswith("admin_edit_user_"), RoleFilter('admin'))
async def start_user_editing(callback: types.CallbackQuery, state: FSMContext):
    user_id = int(callback.data.split('_')[-1])
    await state.clear()
    await state.update_data(user_id=user_id)
    await state.set_state(UserEditing.choosing_field)
    await callback.message.edit_text(
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğµ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:",
        reply_markup=inline.get_user_editing_keyboard(user_id)
    )
    await callback.answer()

@router.callback_query(UserEditing.choosing_field, F.data.startswith("edit_user_"))
async def choose_field_to_edit(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    try:
        _prefix, _entity, user_id_str, field_to_edit = callback.data.split('_', 3)
        user_id = int(user_id_str)
    except ValueError:
        logger.error(f"Could not parse callback data in choose_field_to_edit: {callback.data}")
        await callback.answer("ĞÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°.", show_alert=True)
        return
    
    await state.update_data(field_to_edit=field_to_edit)
    await state.set_state(UserEditing.awaiting_new_value)

    # Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ•: Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»Ñ "gender"
    if field_to_edit == "gender":
        await callback.message.edit_text(
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ğ» Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ:",
            reply_markup=inline.get_gender_selection_for_edit_keyboard(user_id)
        )
    else:
        await callback.message.edit_text(f"Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»Ñ '<code>{field_to_edit}</code>':", parse_mode="HTML")
    
    await callback.answer()


@router.message(UserEditing.awaiting_new_value, F.text)
async def process_new_value(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    user_id = data.get('user_id')
    field_to_edit = data.get('field_to_edit')
    new_value_str = message.text

    if not user_id or not field_to_edit:
        await message.answer("ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ½Ğ°Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾.", reply_markup=inline.get_back_to_admin_panel_keyboard())
        await state.clear()
        return

    try:
        if field_to_edit in ['is_blocked', 'is_dkm_donor']:
            new_value = new_value_str.lower() in ['true', '1', 'yes', 'Ğ´Ğ°', 'Ğ´Ğ°,', 'Ğ´']
        else:
            new_value = new_value_str

        await admin_requests.update_user_field(session, user_id, field_to_edit, new_value)
        await session.commit()
        
        await message.answer(f"âœ… ĞŸĞ¾Ğ»Ğµ '<code>{field_to_edit}</code>' ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾!", parse_mode="HTML")
    
    except Exception as e:
        await session.rollback()
        logger.error(f"Failed to update user field '{field_to_edit}' for user {user_id}: {e}", exc_info=True)
        await message.answer(f"âŒ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸: {e}")
        await state.clear()
        return

    await state.clear()
    
    fake_callback = types.CallbackQuery(
        id=str(message.message_id),
        from_user=message.from_user,
        chat_instance="fake",
        message=message,
        data=f"admin_show_user_{user_id}"
    )
    await show_single_user_card(fake_callback, session)

# ĞĞĞ’Ğ«Ğ™ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš: Ğ”Ğ»Ñ ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ¾Ğ»Ğ°
@router.callback_query(UserEditing.awaiting_new_value, F.data.startswith("set_gender_"))
async def set_user_gender(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    try:
        _prefix, _entity, user_id_str, new_gender = callback.data.split('_')
        user_id = int(user_id_str)
    except ValueError:
        logger.error(f"Could not parse callback data in set_user_gender: {callback.data}")
        await callback.answer("ĞÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°.", show_alert=True)
        return

    try:
        await admin_requests.update_user_field(session, user_id, "gender", new_gender)
        await session.commit()
        await callback.answer(f"âœ… ĞŸĞ¾Ğ» ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½ Ğ½Ğ° '{'ĞœÑƒĞ¶ÑĞºĞ¾Ğ¹' if new_gender == 'male' else 'Ğ–ĞµĞ½ÑĞºĞ¸Ğ¹'}'!")
    except Exception as e:
        await session.rollback()
        logger.error(f"Failed to update user gender for user {user_id}: {e}", exc_info=True)
        await callback.answer(f"âŒ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸: {e}", show_alert=True)
        return
    finally:
        await state.clear()

    # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ
    await show_single_user_card(callback, session)

# --- ĞĞĞ’Ğ«Ğ• ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜: Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ ---
@router.callback_query(F.data.startswith("admin_delete_user_"), RoleFilter('main_admin'))
async def ask_for_user_deletion(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await callback.answer(Text.USER_NOT_FOUND, show_alert=True)
        return

    await callback.message.edit_text(
        f"ğŸ—‘ï¸ <b>Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ?</b>\n\n"
        f"<b>Ğ¤Ğ˜Ğ:</b> {user.full_name}\n"
        f"<b>ID:</b> <code>{user.telegram_id}</code>\n\n"
        f"<b>Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ¾Ğ±Ñ€Ğ°Ñ‚Ğ¸Ğ¼Ğ¾ Ğ¸ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ Ğ²ÑĞµ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ (Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸, Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸, Ğ·Ğ°ĞºĞ°Ğ·Ñ‹).</b>",
        reply_markup=inline.get_user_deletion_confirmation_keyboard(user_id),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_delete_user_"), RoleFilter('main_admin'))
async def confirm_user_deletion(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    
    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ¼ Ğ¸Ğ¼Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ, Ğ¿Ğ¾ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½
    user_to_delete = await user_requests.get_user_by_id(session, user_id)
    if not user_to_delete:
        await callback.answer("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒĞ¶Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½.", show_alert=True)
        await manage_users_main_menu(callback)
        return
    user_name = user_to_delete.full_name

    success = await admin_requests.delete_user_by_id(session, user_id)

    if success:
        await callback.answer(f"ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {user_name} ÑƒĞ´Ğ°Ğ»ĞµĞ½.", show_alert=True)
        # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸
        await manage_users_main_menu(callback)
    else:
        await callback.answer("ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ. Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾, Ğ¾Ğ½ ÑƒĞ¶Ğµ Ğ±Ñ‹Ğ» ÑƒĞ´Ğ°Ğ»ĞµĞ½.", show_alert=True)
        await show_single_user_card(callback, session)
        
        
@router.callback_query(F.data == "admin_add_user_start", RoleFilter('admin'))
async def add_user_start(callback: types.CallbackQuery, state: FSMContext):
    """ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ FSM Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
    await state.clear()
    await state.set_state(AdminAddUser.awaiting_phone)
    await callback.message.edit_text("<b>Ğ¨Ğ°Ğ³ 1/8:</b> Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ° Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ <code>+7...</code>")
    await callback.answer()

@router.message(AdminAddUser.awaiting_phone)
async def add_user_phone(message: types.Message, state: FSMContext, session: AsyncSession):
    phone_number = message.text
    if not phone_number.startswith('+') or not phone_number[1:].isdigit() or len(phone_number) < 11:
        await message.answer("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ°. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ <code>+7...</code>")
        return

    existing_user = await user_requests.get_user_by_phone(session, phone_number)
    if existing_user:
        await message.answer(f"âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ñ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼ {phone_number} ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚: {existing_user.full_name}.")
        await state.clear()
        return

    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ñ‚Ñ€Ğ¸Ñ†Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ ID
    min_user_id = await admin_requests.get_min_user_id(session)
    new_telegram_id = min(0, min_user_id) - 1

    await state.update_data(
        phone_number=phone_number,
        telegram_id=new_telegram_id,
        telegram_username=f"manual_{phone_number}"
    )
    await state.set_state(AdminAddUser.awaiting_full_name)
    await message.answer("<b>Ğ¨Ğ°Ğ³ 2/8:</b> Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¤Ğ˜Ğ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.")

# Ğ”Ğ°Ğ»ĞµĞµ Ğ¼Ñ‹ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ñ‡Ñ‚Ğ¸ Ñ‚Ğµ Ğ¶Ğµ ÑˆĞ°Ğ³Ğ¸, Ñ‡Ñ‚Ğ¾ Ğ¸ Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾Ğ¹ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸.
# ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¸Ğ²ÑĞ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¸Ñ… Ğº Ğ½Ğ°ÑˆĞµĞ¼Ñƒ Ğ½Ğ¾Ğ²Ğ¾Ğ¼Ñƒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ AdminAddUser.
# Ğ­Ñ‚Ğ¾Ñ‚ ĞºĞ¾Ğ´ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² ĞºĞ¾Ğ½ĞµÑ† Ñ„Ğ°Ğ¹Ğ»Ğ° user_management.py

@router.message(AdminAddUser.awaiting_full_name)
async def add_user_full_name(message: types.Message, state: FSMContext):
    await state.update_data(full_name=message.text.strip())
    await state.set_state(AdminAddUser.awaiting_category)
    await message.answer("<b>Ğ¨Ğ°Ğ³ 3/8:</b> Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.", reply_markup=inline.get_category_keyboard())

@router.callback_query(AdminAddUser.awaiting_category, F.data.startswith('category_'))
async def add_user_category(callback: types.CallbackQuery, state: FSMContext):
    category = callback.data.split('_', 1)[1]
    await state.update_data(category=category)
    await callback.message.edit_text("<b>Ğ¨Ğ°Ğ³ 4/8:</b> Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ’Ğ£Ğ—.", reply_markup=inline.get_university_keyboard())
    await state.set_state(AdminAddUser.awaiting_university)
    await callback.answer()

@router.callback_query(AdminAddUser.awaiting_university, F.data.startswith('university_'))
async def add_user_university(callback: types.CallbackQuery, state: FSMContext):
    choice = callback.data.split('_', 1)[1]
    if choice == 'mifi':
        await state.update_data(university="ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜")
        await callback.message.edit_text("<b>Ğ¨Ğ°Ğ³ 5/8:</b> Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚.", reply_markup=inline.get_faculties_keyboard())
        await state.set_state(AdminAddUser.awaiting_faculty)
    else:
        await callback.message.edit_text("<b>Ğ¨Ğ°Ğ³ 5/8:</b> Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ’Ğ£Ğ—Ğ°.")
        await state.set_state(AdminAddUser.awaiting_custom_university_name)
    await callback.answer()

@router.message(AdminAddUser.awaiting_custom_university_name)
async def add_user_custom_university(message: types.Message, state: FSMContext):
    await state.update_data(university=message.text)
    await message.answer("<b>Ğ¨Ğ°Ğ³ 6/8:</b> Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚.")
    await state.set_state(AdminAddUser.awaiting_custom_faculty_name)

@router.callback_query(AdminAddUser.awaiting_faculty, F.data.startswith('faculty_'))
async def add_user_faculty(callback: types.CallbackQuery, state: FSMContext):
    faculty = callback.data.split('_', 1)[1]
    if faculty == 'Other':
        await callback.message.edit_text("<b>Ğ¨Ğ°Ğ³ 6/8:</b> Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ğ°.")
        await state.set_state(AdminAddUser.awaiting_custom_faculty_name)
    else:
        await state.update_data(faculty=faculty)
        await callback.message.edit_text("<b>Ğ¨Ğ°Ğ³ 7/8:</b> Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ¼ĞµÑ€ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ (Ğ¸Ğ»Ğ¸ 'Ğ½ĞµÑ‚').")
        await state.set_state(AdminAddUser.awaiting_study_group)
    await callback.answer()
    
@router.message(AdminAddUser.awaiting_custom_faculty_name)
async def add_user_custom_faculty(message: types.Message, state: FSMContext):
    await state.update_data(faculty=message.text)
    await message.answer("<b>Ğ¨Ğ°Ğ³ 7/8:</b> Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ¼ĞµÑ€ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ (Ğ¸Ğ»Ğ¸ 'Ğ½ĞµÑ‚').")
    await state.set_state(AdminAddUser.awaiting_study_group)

@router.message(AdminAddUser.awaiting_study_group)
async def add_user_study_group(message: types.Message, state: FSMContext):
    await state.update_data(study_group=message.text)
    await state.set_state(AdminAddUser.awaiting_gender)
    await message.answer("<b>Ğ¨Ğ°Ğ³ 8/8:</b> Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ».", reply_markup=inline.get_gender_inline_keyboard())

@router.callback_query(AdminAddUser.awaiting_gender, F.data.startswith("gender_"))
async def add_user_gender(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ ÑˆĞ°Ğ³ - ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ."""
    gender = callback.data.split('_', 1)[1]
    await state.update_data(gender=gender, consent_given=True) # Ğ¡Ğ¾Ğ³Ğ»Ğ°ÑĞ¸Ğµ Ğ¿Ğ¾Ğ´Ñ€Ğ°Ğ·ÑƒĞ¼ĞµĞ²Ğ°ĞµÑ‚ÑÑ, Ñ‚.Ğº. Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ°Ğ´Ğ¼Ğ¸Ğ½
    
    user_data = await state.get_data()

    await user_requests.add_user(session, user_data)
    await session.commit()
    await state.clear()
    
    await callback.message.edit_text(
        f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ <b>{user_data['full_name']}</b> ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ² Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….",
        reply_markup=inline.get_user_management_main_keyboard()
    )
    await callback.answer("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½!", show_alert=True)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/handlers/admin/user_management.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/keyboards/__init__.py ---



--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/keyboards/__init__.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/keyboards/inline.py ---

# Ğ¤ĞĞ™Ğ›: bot/keyboards/inline.py

from aiogram import types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from bot.db.models import MerchItem, InfoText
from aiogram.fsm.context import FSMContext

# --- ĞšĞ›ĞĞ’Ğ˜ĞĞ¢Ğ£Ğ Ğ« (Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ¾ get_user_management_keyboard) ---

def get_back_to_main_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_category_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="Ğ¡Ñ‚ÑƒĞ´ĞµĞ½Ñ‚", callback_data="category_student"))
    builder.row(InlineKeyboardButton(text="Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğ¹ Ğ´Ğ¾Ğ½Ğ¾Ñ€", callback_data="category_external"))
    return builder.as_markup()

def get_consent_keyboard():
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ ÑĞ¾Ğ³Ğ»Ğ°ÑĞ¸Ñ Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ĞŸĞ”Ğ½."""
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="âœ… ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ", callback_data="consent_given"))
    return builder.as_markup()


def get_student_main_menu(viewer_role: str = 'student'):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ğŸ“… Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ", callback_data="register_donation"))
    builder.row(InlineKeyboardButton(text="ğŸ‘¤ ĞœĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ", callback_data="my_profile"))
    builder.row(InlineKeyboardButton(text="ğŸ ĞœĞ°Ğ³Ğ°Ğ·Ğ¸Ğ½ Ğ¼ĞµÑ€Ñ‡Ğ°", callback_data="merch_store"))
    builder.row(InlineKeyboardButton(text="â„¹ï¸ ĞŸĞ¾Ğ»ĞµĞ·Ğ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ", callback_data="info"))
    builder.row(InlineKeyboardButton(text="âš•ï¸ ĞœĞ¾Ğ¸ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹", callback_data="my_waivers"))
    builder.row(InlineKeyboardButton(text="â“ Ğ—Ğ°Ğ´Ğ°Ñ‚ÑŒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼", callback_data="ask_question"))
    
    if viewer_role == 'volunteer':
        builder.row(InlineKeyboardButton(
            text="â­ Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğ² Ğ¼ĞµĞ½Ñ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°",
            callback_data="volunteer_panel"
        ))
    elif viewer_role in ['admin', 'main_admin']:
        builder.row(InlineKeyboardButton(
            text="â­ ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°",
            callback_data="switch_to_volunteer_view"
        ))
        builder.row(InlineKeyboardButton(
            text="âš™ï¸ Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ",
            callback_data="admin_panel"
        ))
        
    return builder.as_markup()

def get_volunteer_main_menu(viewer_role: str = 'volunteer'):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â­ ĞœĞµĞ½Ñ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚Ñ‘Ñ€Ğ°", callback_data="volunteer_panel"))
    builder.row(InlineKeyboardButton(text="ğŸ‘¤ ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ°", callback_data="switch_to_donor_view"))
    return builder.as_markup()

def get_admin_main_menu(viewer_role: str = 'admin'):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="âš™ï¸ ĞŸĞ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°", callback_data="admin_panel"))
    return builder.as_markup()  

def get_main_admin_main_menu(viewer_role: str = 'main_admin'):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="âš™ï¸ ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°", callback_data="admin_panel"))
    return builder.as_markup()

def get_university_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", callback_data="university_mifi"))
    return builder.as_markup()


def get_faculties_keyboard():
    faculties = ["Ğ˜Ğ˜ĞšĞ¡", "Ğ¤Ğ˜Ğ‘Ğ¡", "Ğ˜Ğ½Ğ¯Ğ·", "Ğ˜Ğ¤Ğ¢Ğ­Ğ‘", "Ğ‘ĞœĞ¢", "Ğ˜Ğ¤Ğ˜Ğ‘"]
    builder = InlineKeyboardBuilder()
    for faculty in faculties:
        builder.row(InlineKeyboardButton(text=faculty, callback_data=f"faculty_{faculty}"))
    builder.row(InlineKeyboardButton(text="Ğ”Ñ€ÑƒĞ³Ğ¾Ğ¹/ĞĞµ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°", callback_data="faculty_Other"))
    return builder.as_markup()

def get_gender_inline_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="ĞœÑƒĞ¶ÑĞºĞ¾Ğ¹", callback_data="gender_male"),
        InlineKeyboardButton(text="Ğ–ĞµĞ½ÑĞºĞ¸Ğ¹", callback_data="gender_female")
    )
    return builder.as_markup()

def get_profile_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ğŸ“Š ĞœĞ¾Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ", callback_data="profile_data"))
    builder.row(InlineKeyboardButton(text="ğŸ©¸ Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹", callback_data="profile_history"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_back_to_profile_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ", callback_data="my_profile"))
    return builder.as_markup()

def get_info_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ĞšĞ°Ğº Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ñ‚ÑŒÑÑ?", callback_data="info_prepare"))
    builder.row(InlineKeyboardButton(text="ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ", callback_data="info_contraindications"))
    builder.row(InlineKeyboardButton(text="Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»Ğµ?", callback_data="info_after"))
    builder.row(InlineKeyboardButton(text="ğŸ©¸ Ğ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑÑ‚Ğ²Ğµ ĞºĞ¾ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ·Ğ³Ğ° (Ğ”ĞšĞœ)", callback_data="info_dkm"))
    builder.row(InlineKeyboardButton(text="ğŸ¥ Ğ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ÑÑ… Ğ² ĞœĞ˜Ğ¤Ğ˜", callback_data="info_mifi_process"))
    builder.row(InlineKeyboardButton(text="Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼Ğ¸", callback_data="info_contacts"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_back_to_info_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ°Ğ¼", callback_data="info"))
    return builder.as_markup()

def get_merch_store_keyboard(item: MerchItem, page: int, total_pages: int):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text=f'ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ·Ğ° {item.price}Ğ‘', callback_data=f"buy_merch_{item.id}"))
    nav_buttons = []
    prev_page = total_pages if page == 1 else page - 1
    nav_buttons.append(InlineKeyboardButton(text="â—€ï¸", callback_data=f"merch_page_{prev_page}"))
    nav_buttons.append(InlineKeyboardButton(text=f"{page}/{total_pages}", callback_data="ignore"))
    next_page = 1 if page == total_pages else page + 1
    nav_buttons.append(InlineKeyboardButton(text="â–¶ï¸", callback_data=f"merch_page_{next_page}"))
    builder.row(*nav_buttons)
    builder.row(InlineKeyboardButton(text="ğŸ›ï¸ ĞœĞ¾Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹", callback_data="my_orders"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_purchase_confirmation_keyboard(item_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="âœ… ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ", callback_data=f"confirm_buy_{item_id}"),
        InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="merch_store")
    )
    return builder.as_markup()

def get_back_to_merch_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½", callback_data="merch_store"))
    return builder.as_markup()
    
def get_admin_panel_keyboard(viewer_role: str):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ğŸ—“ï¸ Ğ£Ğ¿Ñ€. Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸ÑĞ¼Ğ¸", callback_data="admin_manage_events"))
    builder.row(types.InlineKeyboardButton(text="â“ Ğ’Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹", callback_data="admin_answer_questions"))
    builder.row(InlineKeyboardButton(text="ğŸ‘¥ Ğ£Ğ¿Ñ€. Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸", callback_data="admin_manage_users"))
    builder.row(InlineKeyboardButton(text="ğŸ›ï¸ Ğ£Ğ¿Ñ€. Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½Ğ¾Ğ¼", callback_data="admin_manage_merch"))
    builder.row(InlineKeyboardButton(text="ğŸ“¦ ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²", callback_data="admin_process_orders"))
    builder.row(InlineKeyboardButton(text="ğŸ“£ Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ¸", callback_data="admin_mailing"))
    builder.row(InlineKeyboardButton(text="ğŸ“Š ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°", callback_data="admin_analytics"))
    builder.row(InlineKeyboardButton(text="ğŸ“ Ğ ĞµĞ´. Ğ¸Ğ½Ñ„Ğ¾-Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ñ‹", callback_data="admin_edit_info"))
    if viewer_role == 'main_admin':
        builder.row(
        types.InlineKeyboardButton(text="ğŸ’¾ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", callback_data="ma_export_data"),
        types.InlineKeyboardButton(text="ğŸ“¥ Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", callback_data="ma_import_data")
        )
        builder.row(types.InlineKeyboardButton(text="ğŸ“¥ Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ ÑÑ‚Ğ°Ñ€Ğ¾Ğ¹ Ğ‘Ğ”", callback_data="ma_import_old_db"))
    builder.row(InlineKeyboardButton(text="ğŸ‘¤ ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ°", callback_data="switch_to_donor_view"))
    return builder.as_markup()



def get_info_sections_for_editing_keyboard(sections: list[InfoText]):
    builder = InlineKeyboardBuilder()
    for section in sections:
        builder.row(types.InlineKeyboardButton(
            text=section.section_title,
            callback_data=f"edit_info_{section.section_key}"
        ))
    builder.row(types.InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_panel"))
    return builder.as_markup()

def get_analytics_main_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ğŸ“ˆ ĞĞ±Ñ‰Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° (KPI)", callback_data="analytics_kpi"))
    builder.row(InlineKeyboardButton(text="ğŸ“… ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹", callback_data="analytics_events_select"))
    builder.row(InlineKeyboardButton(text="ğŸ“„ ĞÑ‚Ñ‡ĞµÑ‚Ñ‹", callback_data="analytics_reports"))
    # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞµÑ‰Ğµ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ´Ğ»Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ¾Ğ²
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ", callback_data="admin_panel"))
    return builder.as_markup()

def get_reports_menu_keyboard():
    builder = InlineKeyboardBuilder()
    # I. ĞÑ‚Ñ‡ĞµÑ‚Ñ‹ Ğ¿Ğ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ğ»Ğ¾ÑĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²
    builder.row(InlineKeyboardButton(text="Ğ”Ğ¾Ğ½Ğ¾Ñ€Ñ‹-Ğ¾Ğ´Ğ½Ğ¾Ğ´Ğ½ĞµĞ²ĞºĞ¸", callback_data="report_churn_donors"))
    builder.row(InlineKeyboardButton(text="Ğ£Ğ³Ğ°ÑĞ°ÑÑ‰Ğ¸Ğµ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ñ‹", callback_data="report_lapsed_donors"))
    builder.row(InlineKeyboardButton(text="Ğ¢Ğ¾Ğ¿-20 Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²", callback_data="report_top_donors"))
    # builder.row(InlineKeyboardButton(text="Ğ”Ğ¾Ğ½Ğ¾Ñ€Ñ‹ Ñ€ĞµĞ´ĞºĞ¾Ğ¹ ĞºÑ€Ğ¾Ğ²Ğ¸", callback_data="report_rare_blood_donors"))
    # II. ĞÑ‚Ñ‡ĞµÑ‚Ñ‹ Ğ¿Ğ¾ ÑĞµĞ³Ğ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ğ¸ Ğ¸ Ğ´ĞµĞ¼Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ğ¸
    builder.row(InlineKeyboardButton(text="Ğ¡Ğ°Ğ¼Ñ‹Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ñ‹", callback_data="report_top_faculties"))
    builder.row(InlineKeyboardButton(text="ĞšĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚Ñ‹ Ğ² Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ğ”ĞšĞœ", callback_data="report_dkm_candidates"))
    # III. ĞÑ‚Ñ‡ĞµÑ‚Ñ‹ Ğ¿Ğ¾ ĞºĞ¾Ğ½Ğ²ĞµÑ€ÑĞ¸Ğ¸ Ğ¸ ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸
    builder.row(InlineKeyboardButton(text="ĞŸĞ¾Ñ‚ĞµÑ€Ñ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ½Ğ¸ĞºĞ°", callback_data="report_survey_dropoff"))

    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_analytics"))
    return builder.as_markup()

def get_events_for_analysis_keyboard(events: list):
    builder = InlineKeyboardBuilder()
    for event in events:
        builder.row(InlineKeyboardButton(
            text=f"{event.event_datetime.strftime('%d.%m.%y')} - {event.name}",
            callback_data=f"analyze_event_{event.id}"
        ))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_analytics"))
    return builder.as_markup()

def get_events_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ", callback_data="admin_create_event"))
    builder.row(InlineKeyboardButton(text="ğŸ“œ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€/Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ…", callback_data="admin_view_events"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_panel"))
    return builder.as_markup()

def get_single_event_management_keyboard(event_id: int, registration_is_open: bool, has_feedback: bool = False):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"admin_edit_event_{event_id}"))
    reg_status_text = "ğŸ”’ Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ" if registration_is_open else "ğŸ”“ ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ"
    builder.row(InlineKeyboardButton(text=reg_status_text, callback_data=f"admin_toggle_reg_{event_id}"))
    builder.row(InlineKeyboardButton(text="ğŸ‘¥ Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² (.csv)", callback_data=f"admin_event_participants_{event_id}"))
    builder.row(InlineKeyboardButton(text="ğŸš¨ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ", callback_data=f"admin_cancel_event_{event_id}"))
    if has_feedback:
        builder.row(InlineKeyboardButton(text="ğŸ“Š ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ñ‹", callback_data=f"admin_view_feedback_{event_id}"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹", callback_data="admin_view_events"))
    return builder.as_markup()

def get_back_to_admin_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°", callback_data="admin_panel"))
    return builder.as_markup()

def get_user_management_keyboard(target_user_id: int, target_user_role: str, viewer_role: str, is_blocked: bool):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ", callback_data=f"admin_edit_user_{target_user_id}"))
    builder.row(InlineKeyboardButton(text="ğŸŸï¸ Ğ£Ğ¿Ñ€. Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸", callback_data=f"admin_manage_user_regs_{target_user_id}"))
    builder.row(InlineKeyboardButton(text="âš•ï¸ Ğ£Ğ¿Ñ€. Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°Ğ¼Ğ¸", callback_data=f"admin_manage_waivers_{target_user_id}"))

    builder.row(InlineKeyboardButton(text="+/- Ğ‘Ğ°Ğ»Ğ»Ñ‹", callback_data=f"admin_points_{target_user_id}"))

    if target_user_role == 'student':
        builder.row(InlineKeyboardButton(text="â­ ĞĞ°Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ÑŒ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ¾Ğ¼", callback_data=f"admin_promote_volunteer_{target_user_id}"))
    elif target_user_role == 'volunteer':
        builder.row(InlineKeyboardButton(text="ğŸ§‘â€ğŸ“ Ğ¡Ğ½ÑÑ‚ÑŒ Ñ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°", callback_data=f"admin_demote_volunteer_{target_user_id}"))
    
    if viewer_role == 'main_admin' and target_user_role != 'main_admin':
        if target_user_role == 'admin':
            builder.row(InlineKeyboardButton(text="ğŸ‘‘â– Ğ Ğ°Ğ·Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°", callback_data=f"ma_demote_admin_{target_user_id}"))
        else:
            builder.row(InlineKeyboardButton(text="ğŸ‘‘â• ĞĞ°Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ¼", callback_data=f"ma_promote_admin_{target_user_id}"))
        if is_blocked:
            builder.row(InlineKeyboardButton(text="âœ… Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"ma_unblock_user_{target_user_id}"))
        else:
            builder.row(InlineKeyboardButton(text="ğŸš« Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"ma_block_user_{target_user_id}"))
        # ĞĞĞ’ĞĞ•: ĞšĞ½Ğ¾Ğ¿ĞºĞ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ
        builder.row(InlineKeyboardButton(text="ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", callback_data=f"admin_delete_user_{target_user_id}"))
            
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ", callback_data="admin_manage_users"))
    return builder.as_markup()

def get_user_editing_keyboard(user_id: int):
    # Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ: Ğ£Ğ±Ñ€Ğ°Ğ½ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾Ğ»ĞµĞ¹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ½ÑƒĞ¶Ğ½Ñ‹
    builder = InlineKeyboardBuilder()
    fields = {
        "full_name": "Ğ¤Ğ˜Ğ",
        "phone_number": "Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½",
        "faculty": "Ğ¤Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚",
        "study_group": "Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ°",
        "gender": "ĞŸĞ¾Ğ»",
        "is_dkm_donor": "Ğ”Ğ¾Ğ½Ğ¾Ñ€ Ğ”ĞšĞœ",
    }
    for field, name in fields.items():
        builder.row(InlineKeyboardButton(text=name, callback_data=f"edit_user_{user_id}_{field}"))

    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", callback_data=f"admin_show_user_{user_id}"))
    return builder.as_markup()

# ĞĞĞ’ĞĞ•: ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ¾Ğ»Ğ° Ğ¿Ñ€Ğ¸ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸
def get_gender_selection_for_edit_keyboard(user_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="ĞœÑƒĞ¶ÑĞºĞ¾Ğ¹", callback_data=f"set_gender_{user_id}_male"),
        InlineKeyboardButton(text="Ğ–ĞµĞ½ÑĞºĞ¸Ğ¹", callback_data=f"set_gender_{user_id}_female")
    )
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"admin_edit_user_{user_id}"))
    return builder.as_markup()

# ĞĞĞ’ĞĞ•: ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
def get_user_deletion_confirmation_keyboard(user_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="ğŸ—‘ï¸ Ğ”Ğ°, ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"admin_confirm_delete_user_{user_id}"),
        InlineKeyboardButton(text="â†©ï¸ ĞĞµÑ‚, Ğ½Ğ°Ğ·Ğ°Ğ´", callback_data=f"admin_show_user_{user_id}")
    )
    return builder.as_markup()

def get_donation_type_keyboard():
    builder = InlineKeyboardBuilder()
    types = {'whole_blood': 'Ğ¦ĞµĞ»ÑŒĞ½Ğ°Ñ ĞºÑ€Ğ¾Ğ²ÑŒ', 'plasma': 'ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°', 'platelets': 'Ğ¢Ñ€Ğ¾Ğ¼Ğ±Ğ¾Ñ†Ğ¸Ñ‚Ñ‹', 'erythrocytes': 'Ğ­Ñ€Ğ¸Ñ‚Ñ€Ğ¾Ñ†Ğ¸Ñ‚Ñ‹'}
    for key, value in types.items():
        builder.row(InlineKeyboardButton(text=value, callback_data=f"settype_{key}"))
    return builder.as_markup()


def get_blood_centers_keyboard(blood_centers, edit_mode=False):
    builder = InlineKeyboardBuilder()
    for center in blood_centers:
        builder.row(InlineKeyboardButton(text=center.name, callback_data=f"select_blood_center_{center.id}"))

    callback_data = "add_new_blood_center_edit" if edit_mode else "add_new_blood_center"
    builder.row(InlineKeyboardButton(text="â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹", callback_data=callback_data))
    return builder.as_markup()

# --- (ĞÑÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ĞºĞ¾Ğ´ Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹) ---

def get_main_admin_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ğŸ‘®â€â™‚ï¸ Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼Ğ¸", callback_data="ma_manage_admins"))
    builder.row(InlineKeyboardButton(text="ğŸš« Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°Ğ¼Ğ¸", callback_data="ma_manage_blocks"))
    builder.row(InlineKeyboardButton(text="ğŸ’¾ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", callback_data="ma_export_data"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°", callback_data="admin_panel"))
    return builder.as_markup()
    
def get_back_to_ma_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ³Ğ». Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°", callback_data="main_admin_panel"))
    return builder.as_markup()

def get_admins_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â• ĞĞ°Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°", callback_data="add_admin"))
    builder.row(InlineKeyboardButton(text="â– Ğ Ğ°Ğ·Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°", callback_data="remove_admin"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="main_admin_panel"))
    return builder.as_markup()

def get_blocks_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ğŸ”’ Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", callback_data="block_user_start"))
    builder.row(InlineKeyboardButton(text="ğŸ”“ Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", callback_data="unblock_user_start"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="main_admin_panel"))
    return builder.as_markup()
    
def get_export_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="Ğ’Ñ‹Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ (.csv)", callback_data="export_users_csv"))
    builder.row(InlineKeyboardButton(text="Ğ’Ñ‹Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ (.csv)", callback_data="export_donations_csv"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="main_admin_panel"))
    return builder.as_markup()

def get_merch_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€", callback_data="admin_create_merch"))
    builder.row(InlineKeyboardButton(text="ğŸ“œ ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€/Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ", callback_data="admin_view_merch"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_panel"))
    return builder.as_markup()

def get_event_cancellation_confirmation_keyboard(event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="âŒ Ğ”Ğ°, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data=f"admin_confirm_cancel_{event_id}"),
        InlineKeyboardButton(text="â†©ï¸ ĞĞµÑ‚, Ğ½Ğ°Ğ·Ğ°Ğ´", callback_data=f"admin_show_event_{event_id}")
    )
    return builder.as_markup()

def get_back_to_events_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğš ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸ÑĞ¼Ğ¸", callback_data="admin_manage_events"))
    return builder.as_markup()

def get_single_merch_management_keyboard(item_id: int, is_available: bool):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="âœï¸ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ", callback_data=f"admin_edit_merch_{item_id}"))
    availability_text = "âœ… Ğ¡Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğ¼" if not is_available else "âŒ Ğ¡Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğ¼"
    builder.row(InlineKeyboardButton(text=availability_text, callback_data=f"admin_toggle_merch_{item_id}"))
    builder.row(InlineKeyboardButton(text="ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€", callback_data=f"admin_delete_merch_{item_id}"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ²", callback_data="admin_view_merch"))
    return builder.as_markup()

def get_merch_deletion_confirmation_keyboard(item_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="ğŸ—‘ï¸ Ğ”Ğ°, ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ", callback_data=f"admin_confirm_delete_merch_{item_id}"),
        InlineKeyboardButton(text="â†©ï¸ ĞĞµÑ‚, Ğ½Ğ°Ğ·Ğ°Ğ´", callback_data=f"admin_show_merch_{item_id}")
    )
    return builder.as_markup()

def get_back_to_merch_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğš ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½Ğ¾Ğ¼", callback_data="admin_manage_merch"))
    return builder.as_markup()

def get_already_registered_keyboard(event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(
        text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ",
        callback_data=f"cancel_reg_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="â†©ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹",
        callback_data="register_donation"
    ))
    return builder.as_markup()

def get_event_creation_confirmation_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="âœ… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¸ Ñ€Ğ°Ğ·Ğ¾ÑĞ»Ğ°Ñ‚ÑŒ", callback_data="confirm_create_event"))
    builder.row(InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="admin_manage_events"))
    return builder.as_markup()

def get_mailing_audience_keyboard(current_filters: dict = None):
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¸ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸.
    Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°ĞµÑ‚ ÑƒĞ¶Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹ Ğ¸ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸.
    """
    if current_filters is None:
        current_filters = {}

    builder = InlineKeyboardBuilder()


    builder.row(InlineKeyboardButton(text="ğŸ“¢ Ğ’ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼", callback_data="mail_filter_role_all"))
    builder.row(InlineKeyboardButton(text="â­ Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°Ğ¼ Ğ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°Ğ¼", callback_data="mail_filter_role_volunteers"))
    builder.row(InlineKeyboardButton(text="âš™ï¸ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼", callback_data="mail_filter_role_admins"))
    # builder.row(InlineKeyboardButton(text="-"*25, callback_data="ignore")) 

    # builder.row(InlineKeyboardButton(text="ğŸ“ ĞŸĞ¾ Ğ’Ğ£Ğ—Ñƒ", callback_data="mail_audience_type_university"))
    builder.row(InlineKeyboardButton(text="ğŸ›ï¸ ĞŸĞ¾ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ñƒ", callback_data="mail_audience_type_faculty"))
    
    if current_filters:
        builder.row(InlineKeyboardButton(text="âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾ (Ğ¿ĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ)", callback_data="mail_audience_finish"))

    # ĞšĞ½Ğ¾Ğ¿ĞºĞ° "Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹"
    if current_filters:
        builder.row(InlineKeyboardButton(text="ğŸ”„ Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ²ÑĞµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹", callback_data="mail_audience_reset"))

    builder.row(InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ° Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸", callback_data="admin_panel"))
    
    return builder.as_markup()



def get_dynamic_mailing_filter_keyboard(items: list[str], filter_key: str, back_callback: str):
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°.
    :param items: Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº (Ğ½Ğ°Ğ¿Ñ€., ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ’Ğ£Ğ—Ğ¾Ğ²).
    :param filter_key: ĞšĞ»ÑÑ‡ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ° (Ğ½Ğ°Ğ¿Ñ€., 'university').
    :param back_callback: callback_data Ğ´Ğ»Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ "ĞĞ°Ğ·Ğ°Ğ´".
    """
    builder = InlineKeyboardBuilder()
    for item in items:
        builder.row(InlineKeyboardButton(text=item, callback_data=f"mail_filter_{filter_key}_{item}"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data=back_callback))
    return builder.as_markup()

def get_mailing_confirmation_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="ğŸš€ Ğ”Ğ°, Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºÑƒ", callback_data="confirm_mailing"),
        InlineKeyboardButton(text="âœï¸ Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑÑ‚", callback_data="edit_mailing_text"),
        InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="admin_panel")
    )
    return builder.as_markup()

def get_skip_media_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â¡ï¸ ĞŸÑ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ", callback_data="skip_media"))
    builder.row(InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="admin_panel"))
    return builder.as_markup()

def get_user_management_main_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ğŸ“œ Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹", callback_data="admin_users_list_page_1"))
    builder.row(InlineKeyboardButton(text="ğŸ” ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", callback_data="admin_search_user"))
    builder.row(InlineKeyboardButton(text="â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ", callback_data="admin_add_user_start"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ", callback_data="admin_panel"))
    return builder.as_markup()

def get_users_list_pagination_keyboard(page: int, total_pages: int):
    builder = InlineKeyboardBuilder()
    nav_buttons = []
    if page > 1:
        nav_buttons.append(InlineKeyboardButton(text="â—€ï¸", callback_data=f"admin_users_list_page_{page - 1}"))
    nav_buttons.append(InlineKeyboardButton(text=f"{page}/{total_pages}", callback_data="ignore"))
    if page < total_pages:
        nav_buttons.append(InlineKeyboardButton(text="â–¶ï¸", callback_data=f"admin_users_list_page_{page + 1}"))
    builder.row(*nav_buttons)
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_manage_users"))
    return builder.as_markup()

def get_successful_registration_keyboard(event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(
        text="ğŸ”² ĞœĞ¾Ğ¹ QR-ĞºĞ¾Ğ´ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ",
        callback_data=f"get_event_qr_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="ğŸ—“ï¸ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² ĞºĞ°Ğ»ĞµĞ½Ğ´Ğ°Ñ€ÑŒ",
        callback_data=f"add_to_calendar_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ",
        callback_data=f"cancel_reg_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="â†©ï¸ Ğš ÑĞ¿Ğ¸ÑĞºÑƒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹",
        callback_data="register_donation"
    ))
    return builder.as_markup()

def get_donation_confirmation_keyboard(user_id: int, event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(
            text="âœ… ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ",
            callback_data=f"confirm_donation_{user_id}_{event_id}"
        ),
        InlineKeyboardButton(
            text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°",
            callback_data="volunteer_panel"
        )
    )
    return builder.as_markup()

def get_volunteer_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="ğŸ“· ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ (QR)", callback_data="confirm_donation_qr"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğ² Ğ¼ĞµĞ½Ñ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ°", callback_data="switch_to_donor_view"))
    return builder.as_markup()

def get_manual_registration_management_keyboard(user_id: int):
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°: Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ."""
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â• Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ", callback_data=f"admin_reg_start_{user_id}"))
    builder.row(InlineKeyboardButton(text="â– ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ", callback_data=f"admin_cancel_start_{user_id}"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", callback_data=f"admin_show_user_{user_id}"))
    return builder.as_markup()

def get_events_for_manual_registration_keyboard(user_id: int, events: list):
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° ÑĞ¾ ÑĞ¿Ğ¸ÑĞºĞ¾Ğ¼ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ñ€ÑƒÑ‡Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸."""
    builder = InlineKeyboardBuilder()
    for event in events:
        builder.row(InlineKeyboardButton(
            text=f"{event.event_date.strftime('%d.%m')} - {event.name}",
            callback_data=f"adminReg_{user_id}_{event.id}" 
        ))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"admin_manage_user_regs_{user_id}"))
    return builder.as_markup()

def get_registrations_for_cancellation_keyboard(user_id: int, registrations: list):
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° ÑĞ¾ ÑĞ¿Ğ¸ÑĞºĞ¾Ğ¼ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹."""
    builder = InlineKeyboardBuilder()
    for reg in registrations:
        builder.row(InlineKeyboardButton(
            text=f"âŒ {reg.event.event_date.strftime('%d.%m')} - {reg.event.name}",
            callback_data=f"adminCancel_{user_id}_{reg.event_id}"
        ))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data=f"admin_manage_user_regs_{user_id}"))
    return builder.as_markup()



def get_my_waivers_keyboard(user_waivers_exist: bool):
    """
    ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ¼ĞµĞ½Ñ 'ĞœĞ¾Ğ¸ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹'.
    ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ñƒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ ĞµÑÑ‚ÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ¼ Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ñ‹.
    """
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â• Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²Ğ¾Ğ´", callback_data="set_user_waiver"))
    if user_waivers_exist:
        builder.row(InlineKeyboardButton(text="â– ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ²Ğ¾Ğ¹ Ğ¾Ñ‚Ğ²Ğ¾Ğ´", callback_data="cancel_user_waiver"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_waiver_cancellation_keyboard(waivers: list):
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° ÑĞ¾ ÑĞ¿Ğ¸ÑĞºĞ¾Ğ¼ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ², ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼, Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹."""
    builder = InlineKeyboardBuilder()
    for waiver in waivers:
        builder.row(InlineKeyboardButton(
            text=f"âŒ Ğ”Ğ¾ {waiver.end_date.strftime('%d.%m.%y')}: {waiver.reason[:25]}...",
            callback_data=f"delete_waiver_{waiver.id}"
        ))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="my_waivers"))
    return builder.as_markup()

def get_admin_waiver_management_keyboard(user_id: int, waivers: list):
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ° ÑĞ¾ ÑĞ¿Ğ¸ÑĞºĞ¾Ğ¼ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ´Ğ»Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ."""
    builder = InlineKeyboardBuilder()
    for waiver in waivers:
        creator_map = {'user': 'ğŸ‘¤', 'system': 'âš™ï¸', 'admin': 'ğŸ‘‘'}
        creator_icon = creator_map.get(str(waiver.created_by).lower(), 'â“')
        
        if str(waiver.created_by).isdigit():
            creator_icon = 'ğŸ‘‘'

        reason_short = (waiver.reason[:20] + '...') if len(waiver.reason) > 20 else waiver.reason
        
        builder.row(InlineKeyboardButton(
            text=f"âŒ {creator_icon} Ğ”Ğ¾ {waiver.end_date.strftime('%d.%m')} - {reason_short}",
            callback_data=f"admin_del_waiver_{waiver.id}_{user_id}"
        ))
        
    builder.row(InlineKeyboardButton(text="â• Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´", callback_data=f"admin_waiver_{user_id}"))
    builder.row(InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", callback_data=f"admin_show_user_{user_id}"))
    return builder.as_markup()

def get_feedback_well_being_keyboard():
    builder = InlineKeyboardBuilder()
    buttons = [InlineKeyboardButton(text=str(i), callback_data=f"fb_wb_{i}") for i in range(1, 6)]
    builder.row(*buttons)
    return builder.as_markup()

def get_feedback_organization_keyboard():
    builder = InlineKeyboardBuilder()
    # Ğ”Ğ²Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ¿Ğ¾ 5 ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº
    builder.row(*[InlineKeyboardButton(text=str(i), callback_data=f"fb_org_{i}") for i in range(1, 6)])
    builder.row(*[InlineKeyboardButton(text=str(i), callback_data=f"fb_org_{i}") for i in range(6, 11)])
    return builder.as_markup()

def get_feedback_skip_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="â¡ï¸ ĞŸÑ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ", callback_data="fb_skip_step"))
    return builder.as_markup()



def get_events_for_post_processing_keyboard(events: list):
    """ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞµĞ³Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸."""
    builder = InlineKeyboardBuilder()
    for event in events:
        builder.row(types.InlineKeyboardButton(
            text=f"{event.event_datetime.strftime('%d.%m.%y')} - {event.name}",
            callback_data=f"post_process_event_{event.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´", callback_data="admin_manage_events"))
    return builder.as_markup()

def get_participant_marking_keyboard(event_id: int, participants: list, marked_donations: set, marked_dkm: set):
    """Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµÑ‚ĞºĞ¸ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²."""
    builder = InlineKeyboardBuilder()
    for reg in participants:
        user = reg.user
        
        donation_icon = "ğŸŸ¢" if user.id in marked_donations else "âšªï¸"
        dkm_icon = "ğŸŸ¢" if user.id in marked_dkm else "âšªï¸"

        builder.row(
            types.InlineKeyboardButton(text=user.full_name, callback_data="ignore"),
            types.InlineKeyboardButton(
                text=f"{donation_icon} Ğ¡Ğ´Ğ°Ğ» ĞºÑ€Ğ¾Ğ²ÑŒ", 
                callback_data=f"mark_participant_{event_id}_{user.id}_donation"
            ),
            types.InlineKeyboardButton(
                text=f"{dkm_icon} Ğ’ÑÑ‚ÑƒĞ¿Ğ¸Ğ» Ğ² Ğ”ĞšĞœ", 
                callback_data=f"mark_participant_{event_id}_{user.id}_dkm"
            )
        )
    builder.row(types.InlineKeyboardButton(text="âœ… Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ¸ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ", callback_data=f"finish_marking_{event_id}"))
    builder.row(types.InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ°", callback_data="admin_manage_events"))
    return builder.as_markup()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/keyboards/inline.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/keyboards/reply.py ---

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

def get_contact_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ¾Ğ¼", request_contact=True)]],
        resize_keyboard=True
    )


def get_home_keyboard():
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ¾Ğ¹ 'Ğ”Ğ¾Ğ¼Ğ¾Ğ¹'."""
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="ğŸ  Ğ”Ğ¾Ğ¼Ğ¾Ğ¹")]
        ],
        resize_keyboard=True
    )

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/keyboards/reply.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/middlewares/__init__.py ---



--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/middlewares/__init__.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/middlewares/block.py ---

from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, Message, CallbackQuery
from sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession

from bot.db import user_requests

class BlockUserMiddleware(BaseMiddleware):
    def __init__(self):
        super().__init__()

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        if not isinstance(event, (Message, CallbackQuery)):
            return await handler(event, data)

        session: AsyncSession = data.get("session")
        if not session:
            return await handler(event, data)

        user = await user_requests.get_user_by_tg_id(session, event.from_user.id)

        if user and user.is_blocked:
            if isinstance(event, Message):
                await event.answer("âŒ Ğ’Ñ‹ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ¸ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ñ‚Ğ°.")
            elif isinstance(event, CallbackQuery):
                await event.answer("âŒ Ğ’Ñ‹ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹.", show_alert=True)
            return  # ĞŸÑ€ĞµÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ´Ğ°Ğ»ÑŒĞ½ĞµĞ¹ÑˆÑƒÑ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ

        return await handler(event, data)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/middlewares/block.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/middlewares/db.py ---

from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from sqlalchemy.ext.asyncio import async_sessionmaker

class DbSessionMiddleware(BaseMiddleware):
    def __init__(self, session_pool: async_sessionmaker):
        super().__init__()
        self.session_pool = session_pool

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        async with self.session_pool() as session:
            data["session"] = session
            return await handler(event, data)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/middlewares/db.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/states/__init__.py ---



--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/states/__init__.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/states/states.py ---

from aiogram.fsm.state import State, StatesGroup

class Registration(StatesGroup):
    awaiting_full_name = State()
    awaiting_category = State()
    awaiting_consent = State()
    awaiting_university = State()
    awaiting_custom_university_name = State()
    awaiting_faculty = State()
    awaiting_custom_faculty_name = State()
    awaiting_study_group = State()
    awaiting_gender = State()

class EventCreation(StatesGroup):
    awaiting_name = State()
    awaiting_datetime = State()
    awaiting_location_text = State()
    awaiting_location_point = State()
    awaiting_blood_center = State()
    awaiting_new_blood_center_name = State()
    awaiting_donation_type = State()
    awaiting_points = State()
    awaiting_limit = State()
    awaiting_confirmation = State()

class MerchCreation(StatesGroup):
    awaiting_photo = State()
    awaiting_name = State()
    awaiting_description = State()
    awaiting_price = State()

class PointsChange(StatesGroup):
    awaiting_user_id = State()
    awaiting_points_amount = State()
    awaiting_reason = State()

class ManualWaiver(StatesGroup):
    awaiting_end_date = State()
    awaiting_reason = State()

class Mailing(StatesGroup):
    awaiting_message_text = State()
    awaiting_media = State()
    awaiting_audience_type = State()     
    awaiting_audience_value = State()   
    awaiting_audience_choice = State()   
    awaiting_confirmation = State()
class AdminManagement(StatesGroup):
    awaiting_user_to_promote = State()
    awaiting_user_to_demote = State()
    
class BlockUser(StatesGroup):
    awaiting_user_id = State()
    awaiting_reason = State()
    awaiting_user_id_unblock = State()

class VolunteerActions(StatesGroup):
    awaiting_qr_photo = State()
    awaiting_confirmation = State()
    
class EventEditing(StatesGroup):
    choosing_field = State() 
    awaiting_new_value = State()
    awaiting_new_blood_center_name_for_edit = State()
    
class MerchEditing(StatesGroup):
    choosing_field = State()
    awaiting_new_value = State()
    
class UserSearch(StatesGroup):
    awaiting_query = State()
    
class UserWaiver(StatesGroup):
    awaiting_end_date = State()
    awaiting_reason = State()
    
    
class FeedbackSurvey(StatesGroup):
    awaiting_well_being = State()
    awaiting_well_being_comment = State()
    awaiting_organization_score = State()
    awaiting_what_liked = State()
    awaiting_what_disliked = State()
    awaiting_other_suggestions = State()
    
class AdminAnalytics(StatesGroup):
    choosing_event_for_analysis = State()
    
class AdminAddUser(StatesGroup):
    awaiting_phone = State()
    awaiting_full_name = State()
    awaiting_category = State()
    awaiting_consent = State()
    awaiting_university = State()
    awaiting_custom_university_name = State()
    awaiting_faculty = State()
    awaiting_custom_faculty_name = State()
    awaiting_study_group = State()
    awaiting_gender = State()
    
class PostEventProcessing(StatesGroup):
    choosing_event = State()
    marking_participants = State()
    
class EditInfoSection(StatesGroup):
    choosing_section = State()
    awaiting_new_text = State()
    
class AskQuestion(StatesGroup):
    awaiting_question = State()

class AnswerQuestion(StatesGroup):
    awaiting_answer = State()
    
class DataImport(StatesGroup):
    awaiting_file = State()
    awaiting_old_db_file = State()

class UserEditing(StatesGroup):
    choosing_field = State()
    awaiting_new_value = State()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/states/states.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/__init__.py ---



--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/__init__.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/analytics_service.py ---

import io
import matplotlib.pyplot as plt
import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db import analytics_requests

async def create_report(session: AsyncSession, report_type: str) -> dict:
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ¾Ñ‚Ñ‡ĞµÑ‚ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ°.
    """
    report_data = {}
    if report_type == "one_time_donors":
        report_data = await analytics_requests.get_one_time_donors(session)
    elif report_type == "no_show_donors":
        report_data = await analytics_requests.get_no_show_donors(session)
    elif report_type == "dkm_donors":
        report_data = await analytics_requests.get_dkm_donors(session)
    elif report_type == "students":
        report_data = await analytics_requests.get_students(session)
    elif report_type == "employees":
        report_data = await analytics_requests.get_employees(session)
    elif report_type == "external_donors":
        report_data = await analytics_requests.get_external_donors(session)
    elif report_type == "graduated_donors":
        report_data = await analytics_requests.get_graduated_donors(session)
    elif report_type == "churn_donors":
        report_data = await analytics_requests.get_churn_donors(session)
    elif report_type == "lapsed_donors":
        report_data = await analytics_requests.get_lapsed_donors(session)
    elif report_type == "top_donors":
        report_data = await analytics_requests.get_top_donors(session)
    elif report_type == "rare_blood_donors":
        report_data = await analytics_requests.get_rare_blood_donors(session)
    elif report_type == "top_faculties":
        report_data = await analytics_requests.get_top_faculties(session)
    elif report_type == "dkm_candidates":
        report_data = await analytics_requests.get_dkm_candidates(session)
    elif report_type == "survey_dropoff":
        report_data = await analytics_requests.get_survey_dropoff(session)
    return report_data

def plot_donations_by_month(data: list[tuple]) -> io.BytesIO:
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ³Ñ€Ğ°Ñ„Ğ¸Ğº Ğ² Ğ²Ğ¸Ğ´Ğµ ÑÑ‚Ğ¾Ğ»Ğ±Ñ‡Ğ°Ñ‚Ğ¾Ğ¹ Ğ´Ğ¸Ğ°Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹ Ğ¿Ğ¾ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼ Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ÑÑ….
    :param data: Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ĞºĞ¾Ñ€Ñ‚ĞµĞ¶ĞµĞ¹ (datetime.date, int), Ğ³Ğ´Ğµ date - Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ´ĞµĞ½ÑŒ Ğ¼ĞµÑÑÑ†Ğ°.
    :return: BytesIO Ğ¾Ğ±ÑŠĞµĞºÑ‚ Ñ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸ĞµĞ¼ PNG.
    """
    if not data:
        return None

    # plt.style.use('ggplot') # ĞœĞ¾Ğ¶ĞµÑ‚Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¸Ğ»ÑŒ Ğ¿Ğ¾ Ğ²ĞºÑƒÑÑƒ
    fig, ax = plt.subplots(figsize=(10, 6))

    months = [item[0].strftime("%b %Y") for item in data]
    counts = [item[1] for item in data]

    ax.bar(months, counts, color='#E53935') # Ğ¤Ğ¸Ñ€Ğ¼ĞµĞ½Ğ½Ñ‹Ğ¹ ĞºÑ€Ğ°ÑĞ½Ñ‹Ğ¹ Ñ†Ğ²ĞµÑ‚

    ax.set_title('Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸ĞºĞ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹ Ğ¿Ğ¾ Ğ¼ĞµÑÑÑ†Ğ°Ğ¼', fontsize=16, pad=20)
    ax.set_ylabel('ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹')
    ax.tick_params(axis='x', rotation=45)
    
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ†Ğ¸Ñ„Ñ€Ñ‹ Ğ½Ğ°Ğ´ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğ°Ğ¼Ğ¸
    for i, v in enumerate(counts):
        ax.text(i, v + 0.5, str(v), ha='center', fontweight='bold')

    plt.tight_layout()

    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ³Ñ€Ğ°Ñ„Ğ¸Ğº Ğ² Ğ±ÑƒÑ„ĞµÑ€ Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    plt.close(fig) # Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ„Ğ¸Ğ³ÑƒÑ€Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ

    return buf

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/analytics_service.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/calendar_service.py ---

import datetime
import pytz
from ics import Calendar, Event as IcsEvent
from ics.alarm import DisplayAlarm
from bot.db.models import Event as DbEvent
from bot.utils.text_messages import Text

def generate_ics_file(event: DbEvent) -> str:
    """
    Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ .ics Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ´Ğ»Ñ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ,
    Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ´Ğ»Ñ Ğ»ÑƒÑ‡ÑˆĞµĞ¹ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸, Ğ² Ñ‚.Ñ‡. Ñ Google Calendar.

    :param event: ĞĞ±ÑŠĞµĞºÑ‚ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ¸Ğ· Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….
    :return: Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° Ñ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ñ‹Ğ¼ .ics Ñ„Ğ°Ğ¹Ğ»Ğ°.
    """
    cal = Calendar()
    e = IcsEvent()

    timezone = pytz.timezone("Europe/Moscow")

    if event.event_datetime.tzinfo is None:
        start_time = timezone.localize(event.event_datetime)
    else:
        start_time = event.event_datetime.astimezone(timezone)

    end_time = start_time + datetime.timedelta(hours=2)

    e.name = f"Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ: {event.name}"
    e.begin = start_time
    e.end = end_time
    donation_type_ru = Text.DONATION_TYPE_RU.get(event.donation_type, event.donation_type)
    e.description = (
        f"Ğ¢Ğ¸Ğ¿ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸: {donation_type_ru}.\n" # <-- Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ
        f"ĞĞµ Ğ·Ğ°Ğ±ÑƒĞ´ÑŒÑ‚Ğµ Ğ²Ğ·ÑÑ‚ÑŒ Ñ ÑĞ¾Ğ±Ğ¾Ğ¹ Ğ¿Ğ°ÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¸ Ñ…Ğ¾Ñ€Ğ¾ÑˆĞ¾ ÑĞµĞ±Ñ Ñ‡ÑƒĞ²ÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ñ‚ÑŒ. "
        f"Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ²Ğ°ÑˆÑƒ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒ!"
    )
    e.location = event.location
    e.created = datetime.datetime.now(tz=timezone)
    
    e.uid = f"{datetime.datetime.now().strftime('%Y%m%dT%H%M%S')}-{event.id}@donor.mifi.ru"
    

    alarm = DisplayAlarm(trigger=datetime.timedelta(hours=-1))
    
    e.alarms.append(alarm)
    
    cal.events.add(e)
    
    return cal.serialize()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/calendar_service.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/data_import.py ---

import openpyxl
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db.models import User, Donation
from bot.db import user_requests
import datetime
import pandas as pd
import re


def format_full_name(full_name: str) -> str:
    """
    Formats a full name by capitalizing the first letter of each word and removing extra spaces.
    """
    if not isinstance(full_name, str):
        return full_name

    full_name = re.sub(r'\s+', ' ', full_name).strip()
    return ' '.join(word.capitalize() for word in full_name.split())


async def import_data_from_file(session: AsyncSession, file_bytes: bytes) -> tuple[int, int]:
    """
    Imports data from an .xlsx file with the old format into the database.
    Returns a tuple of (created_count, updated_count).
    """
    df = pd.read_excel(file_bytes)

    column_mapping = {
        'Ğ¤Ğ˜Ğ': 'full_name',
        'Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½': 'phone_number',
        'Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ°': 'study_group',
        'ĞšĞ¾Ğ»-Ğ²Ğ¾ Ğ“Ğ°Ğ²Ñ€Ğ¸Ğ»Ğ¾Ğ²Ğ°': 'donations_gavrilov',
        'ĞšĞ¾Ğ»-Ğ²Ğ¾ Ğ¤ĞœĞ‘Ğ': 'donations_fmba',
    }

    df = df.rename(columns=column_mapping)

    required_cols = ['full_name', 'phone_number']
    if not all(col in df.columns for col in required_cols):
        raise ValueError(f"ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ² Ñ„Ğ°Ğ¹Ğ»Ğµ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºĞ¾Ğ»Ğ¾Ğ½ĞºĞ¸ ({', '.join(required_cols)}).")

    created_count = 0
    updated_count = 0

    for index, row in df.iterrows():
        phone = str(row['phone_number'])
        if not phone.startswith('+'):
            phone = '+' + phone
        user = await user_requests.get_user_by_phone(session, phone)

        study_group = row.get('study_group')
        university = "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜" if 'ÑĞ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸Ğº' in str(study_group).lower() or (study_group and study_group != '-') else "Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğ¹ Ğ´Ğ¾Ğ½Ğ¾Ñ€"
        faculty = "Ğ¡Ğ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸Ğº" if 'ÑĞ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸Ğº' in str(study_group).lower() else None

        user_data = {
            'full_name': format_full_name(row.get('full_name')),
            'university': university,
            'faculty': faculty,
            'study_group': study_group if university == "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜" and faculty != "Ğ¡Ğ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸Ğº" else None,
            'role': 'student',
        }
        user_data = {k: v for k, v in user_data.items() if pd.notna(v)}

        if user:
            await user_requests.update_user_profile(session, user.id, user_data)
            updated_count += 1
        else:
            full_data = user_data.copy()
            full_data['phone_number'] = phone
            full_data['telegram_id'] = -index  # Use negative index for unique tg_id
            full_data['telegram_username'] = f"import_{phone}"
            user = await user_requests.add_user(session, full_data)
            await session.flush()  # Flush to get the user ID
            created_count += 1

        donations_gavrilov = row.get('donations_gavrilov', 0)
        donations_fmba = row.get('donations_fmba', 0)
        total_donations = (donations_gavrilov if pd.notna(donations_gavrilov) else 0) + \
                          (donations_fmba if pd.notna(donations_fmba) else 0)

        if total_donations > 0:
            for _ in range(int(total_donations)):
                donation = Donation(
                    user_id=user.id,
                    donation_date=datetime.date(2023, 1, 1),
                    donation_type='whole_blood',
                    points_awarded=0,
                    event_id=None
                )
                session.add(donation)

    await session.commit()
    return created_count, updated_count

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/data_import.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/graduation.py ---

import datetime
from bot.db import user_requests

def calculate_graduation_year(group: str) -> int | None:
    """
    Calculates the graduation year based on the group name.
    Returns None if the group format is not recognized.
    """
    if not group or not isinstance(group, str):
        return None

    group_upper = group.upper()

    try:
        if group_upper.startswith('Ğ‘') or group_upper.startswith('B'):
            # Ğ‘Ğ°ĞºĞ°Ğ»Ğ°Ğ²Ñ€Ğ¸Ğ°Ñ‚ - 4 Ğ³Ğ¾Ğ´Ğ°
            year_prefix = int(group_upper[1:3])
            return 2000 + year_prefix + 4
        elif group_upper.startswith('Ğ¡') or group_upper.startswith('C'):
            # Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ñ‚ĞµÑ‚ - 5 Ğ»ĞµÑ‚
            year_prefix = int(group_upper[1:3])
            return 2000 + year_prefix + 5
        elif group_upper.startswith('Ğœ') or group_upper.startswith('M'):
            # ĞœĞ°Ğ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚ÑƒÑ€Ğ° - 2 Ğ³Ğ¾Ğ´Ğ°
            year_prefix = int(group_upper[1:3])
            return 2000 + year_prefix + 2
    except (ValueError, IndexError):
        return None

    return None

async def check_graduation_status(bot, session):
    """
    Checks the graduation status of all users and sends a notification
    to those who have graduated.
    """
    today = datetime.date.today()
    if today.month == 9:
        users = await user_requests.get_all_users(session)
        for user in users:
            if user.graduation_year and user.graduation_year <= today.year:
                await bot.send_message(
                    user.telegram_id,
                    "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ! ĞŸĞ¾ Ğ½Ğ°ÑˆĞ¸Ğ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼, Ğ²Ñ‹ ÑƒĞ¶Ğµ Ğ²Ñ‹Ğ¿ÑƒÑÑ‚Ğ¸Ğ»Ğ¸ÑÑŒ. "
                    "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğµ ÑĞ²Ğ¾Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ‚ÑŒ "
                    "Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ±Ğ¾Ñ‚Ğ¾Ğ¼."
                )

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/graduation.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/qr_service.py ---

import io
import hashlib
import qrcode
import json
import logging
from PIL import Image
from pyzbar.pyzbar import decode, ZBarSymbol

from bot.config_reader import config

logger = logging.getLogger(__name__)

def create_secure_payload(data: dict) -> str:
    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµÑ‚ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ´Ğ»Ñ QR-ĞºĞ¾Ğ´Ğ°
    json_string = json.dumps(data, sort_keys=True, separators=(',', ':'))
    salt = config.qr_secret_key.get_secret_value()
    string_to_hash = json_string + salt
    # logger.info(f"[CREATE] String to be hashed: '{string_to_hash}'")
    h = hashlib.sha256(string_to_hash.encode()).hexdigest()
    # logger.info(f"[CREATE] Generated hash: {h}")
    return f"{json_string}|{h}"

def verify_secure_payload(payload: str) -> dict | None:
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    try:
        json_string, received_hash = payload.split('|', 1)
        salt = config.qr_secret_key.get_secret_value()
        string_to_hash = json_string + salt
        # logger.info(f"[VERIFY] String to be hashed: '{string_to_hash}'")
        expected_hash = hashlib.sha256(string_to_hash.encode()).hexdigest()
        # logger.info(f"[VERIFY] Received hash:  {received_hash}")
        # logger.info(f"[VERIFY] Expected hash:  {expected_hash}")
        if received_hash == expected_hash:
            # logger.info("[VERIFY] Hashes MATCH. Verification successful.")
            return json.loads(json_string)
        else:
            # logger.error("[VERIFY] Hashes DO NOT MATCH. Verification failed.")
            return None
    except (ValueError, IndexError, json.JSONDecodeError) as e:
        # logger.error(f"[VERIFY] An exception occurred during verification: {e}")
        return None

async def generate_qr(data: dict) -> bytes:
    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ QR-ĞºĞ¾Ğ´
    # logger.info(f"--- Generating QR for data: {data} ---")
    payload = create_secure_payload(data)
    img = qrcode.make(payload)
    buf = io.BytesIO()
    img.save(buf, 'PNG')
    buf.seek(0)
    return buf.read()

async def read_qr(photo_bytes: bytes) -> dict | None:
    # Ğ§Ğ¸Ñ‚Ğ°ĞµÑ‚ QR-ĞºĞ¾Ğ´ Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    try:
        image = Image.open(io.BytesIO(photo_bytes)).convert('L')
        decoded_objects = decode(image, symbols=[ZBarSymbol.QRCODE])
        if not decoded_objects:
            # logger.warning("pyzbar failed to find any QR codes on the image.")
            return None
        payload = decoded_objects[0].data.decode('utf-8')
        # logger.info(f"--- Verifying QR with payload: '{payload}' ---")
        verified_data = verify_secure_payload(payload)
        return verified_data
    except Exception as e:
        # logger.error(f"An exception occurred in read_qr: {e}", exc_info=True)
        return None

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/qr_service.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/scheduler.py ---

import logging
import datetime
from aiogram import Bot
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy import select, and_
from sqlalchemy.orm import joinedload
from bot.db.models import EventRegistration, MedicalWaiver, Event, User, Donation, NoShowReport
from bot.utils.text_messages import Text
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.base import StorageKey
from bot.states.states import FeedbackSurvey
from bot.keyboards import inline
from bot.utils.graduation import check_graduation_status


logger = logging.getLogger(__name__)

async def send_reminders_for_interval(
    bot: Bot, 
    session_pool: async_sessionmaker, 
    time_from_now: datetime.timedelta, 
    time_window: datetime.timedelta,
    text_template: str
):
    now = datetime.datetime.now()
    start_time = now + time_from_now
    end_time = start_time + time_window

    logger.info(f"Running reminder job. Checking for events between {start_time.strftime('%Y-%m-%d %H:%M')} and {end_time.strftime('%Y-%m-%d %H:%M')}")
    
    async with session_pool() as session:
        stmt = (
            select(EventRegistration)
            .join(Event, EventRegistration.event_id == Event.id)
            .where(
                and_(
                    Event.event_datetime >= start_time,
                    Event.event_datetime < end_time,
                    EventRegistration.status == 'registered',
                    Event.is_active == True
                )
            )
            .options(
                joinedload(EventRegistration.user),
                joinedload(EventRegistration.event)
            )
        )
        
        results = await session.execute(stmt)
        registrations = results.scalars().unique().all()
        
        if not registrations:
            logger.info("No registrations found for this time window.")
            return
            
        logger.info(f"Found {len(registrations)} registrations to notify.")
        success_count = 0
        for reg in registrations:
            try:
                user = reg.user
                event = reg.event
                
                if not user or not event:
                    continue

                formatted_datetime = event.event_datetime.strftime('%d.%m.%Y %H:%M')
                
                safe_event_name = Text.escape_html(event.name)
                safe_datetime = Text.escape_html(formatted_datetime)
                location_link = Text.format_location_link(event.location, event.latitude, event.longitude)
                
                text = text_template.format(
                    event_name=safe_event_name,
                    event_datetime=safe_datetime,
                    event_location=location_link
                )

                await bot.send_message(chat_id=user.telegram_id, text=text, parse_mode="HTML")
                success_count += 1
            except Exception as e:
                logger.error(f"Failed to send reminder to user {reg.user_id} for event {reg.event_id}. Error: {e}", exc_info=True)
        
        logger.info(f"Job finished. Sent {success_count}/{len(registrations)} reminders.")

async def send_post_donation_feedback(bot: Bot, session_pool: async_sessionmaker, storage: MemoryStorage):
    """Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ¹ ÑĞ²ÑĞ·Ğ¸ Ñ‡ĞµÑ€ĞµĞ· Ğ´ĞµĞ½ÑŒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸."""
    yesterday = datetime.date.today() - datetime.timedelta(days=1)
    logger.info(f"Running post-donation feedback job for donations made on {yesterday}.")

    async with session_pool() as session:
        stmt = (
            select(Donation)
            .options(joinedload(Donation.user))
            .where(
                Donation.donation_date == yesterday,
                Donation.feedback_requested == False
            )
        )
        results = await session.execute(stmt)
        donations_to_process = results.scalars().all()

        if not donations_to_process:
            logger.info("No donations found for feedback request.")
            return

        logger.info(f"Found {len(donations_to_process)} donations for feedback request.")
        success_count = 0
        for donation in donations_to_process:
            try:
                user = donation.user
                if not user:
                    continue
                
                storage_key = StorageKey(bot_id=bot.id, chat_id=user.telegram_id, user_id=user.telegram_id)
                state = FSMContext(storage=storage, key=storage_key)               
                
                await state.set_state(FeedbackSurvey.awaiting_well_being)
                await state.update_data(
                    event_id=donation.event_id,
                    donation_id=donation.id
                )
                
                await bot.send_message(
                    chat_id=user.telegram_id,
                    text=Text.FEEDBACK_START,
                    reply_markup=inline.get_feedback_well_being_keyboard()
                )
                
                donation.feedback_requested = True
                success_count += 1
            except Exception as e:
                logger.error(f"Failed to initiate feedback survey for user {donation.user_id}. Error: {e}", exc_info=True)
        
        if success_count > 0:
            await session.commit()
        
        logger.info(f"Post-donation feedback job finished. Initiated {success_count}/{len(donations_to_process)} surveys.")


async def check_waiver_expirations(bot: Bot, session_pool: async_sessionmaker):
    yesterday = datetime.date.today() - datetime.timedelta(days=1)
    async with session_pool() as session:
        stmt = (
            select(MedicalWaiver.user_id)
            .where(MedicalWaiver.end_date == yesterday)
        )
        results = await session.execute(stmt)
        user_ids_to_notify = results.scalars().unique().all()
        if not user_ids_to_notify:
            return
        users_stmt = select(User).where(User.id.in_(user_ids_to_notify))
        users_result = await session.execute(users_stmt)
        users = users_result.scalars().all()
        for user in users:
            try:
                await bot.send_message(chat_id=user.telegram_id, text=Text.WAIVER_EXPIRED_NOTIFICATION)
            except Exception as e:
                logger.error(f"Failed to send waiver expiration notification to user {user.id}. Error: {e}")


async def check_student_status(bot: Bot, session_pool: async_sessionmaker):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ½Ğµ Ğ²Ñ‹Ğ¿ÑƒÑÑ‚Ğ¸Ğ»ÑÑ Ğ»Ğ¸ ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚."""
    async with session_pool() as session:
        stmt = select(User).where(User.category == "student")
        results = await session.execute(stmt)
        students = results.scalars().all()

        for student in students:
            try:
                if student.study_group:
                    # Very simplified logic. A real implementation would be more complex.
                    study_group_year = int(student.study_group.split("-")[1][:2])
                    current_year = datetime.datetime.now().year % 100
                    if current_year - study_group_year > 4:
                        await bot.send_message(
                            chat_id=student.telegram_id,
                            text="ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! ĞŸĞ¾Ñ…Ğ¾Ğ¶Ğµ, Ñ‚Ñ‹ ÑƒĞ¶Ğµ Ğ²Ñ‹Ğ¿ÑƒÑÑ‚Ğ¸Ğ»ÑÑ Ğ¸Ğ· ÑƒĞ½Ğ¸Ğ²ĞµÑ€ÑĞ¸Ñ‚ĞµÑ‚Ğ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸ ÑĞ²Ğ¾Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ."
                        )
            except Exception as e:
                logger.error(f"Failed to check student status for user {student.id}. Error: {e}", exc_info=True)

def setup_scheduler(bot: Bot, session_pool: async_sessionmaker, storage: MemoryStorage) -> AsyncIOScheduler:
    scheduler = AsyncIOScheduler(timezone="Europe/Moscow")

    scheduler.add_job(
        send_no_show_surveys,
        trigger='cron',
        hour='*',
        minute=5, 
        args=[bot, session_pool]
    )

    scheduler.add_job(
        send_reminders_for_interval,
        trigger='cron',
        hour=10,
        minute=0,
        args=[bot, session_pool, datetime.timedelta(days=7), datetime.timedelta(days=1), Text.REMINDER_WEEK]
    )
    scheduler.add_job(
        send_reminders_for_interval,
        trigger='cron',
        hour=10,
        minute=30,
        args=[bot, session_pool, datetime.timedelta(days=3), datetime.timedelta(days=1), Text.REMINDER_3_DAYS]
    )
    scheduler.add_job(
        send_reminders_for_interval,
        trigger='cron',
        hour=10,
        minute=30,
        args=[bot, session_pool, datetime.timedelta(days=1), datetime.timedelta(days=1), Text.REMINDER_1_DAY]
    )
    scheduler.add_job(
        send_reminders_for_interval,
        trigger='cron',
        hour='*',
        minute=0,
        args=[bot, session_pool, datetime.timedelta(hours=2), datetime.timedelta(hours=1), Text.REMINDER_2_HOURS]
    )
    scheduler.add_job(
        check_waiver_expirations,
        trigger='cron',
        hour=9,
        minute=0,
        args=[bot, session_pool]
    )
    
    scheduler.add_job(
        send_post_donation_feedback,
        trigger='cron',
        hour=11,
        minute=0,
        args=[bot, session_pool, storage]
    )
    
    scheduler.add_job(
        check_student_status,
        trigger='cron',
        month=9,
        day=1,
        hour=12,
        minute=0,
        args=[bot, session_pool]
    )

    scheduler.add_job(
        check_graduation_status,
        trigger='cron',
        month=9,
        day=1,
        hour=13,
        minute=0,
        args=[bot, session_pool]
    )

    logger.info("Scheduler configured successfully with 7 jobs.")
    return scheduler

async def send_no_show_surveys(bot: Bot, session_pool: async_sessionmaker):
    """ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ½ĞµÑĞ²Ğ¸Ğ²ÑˆĞ¸Ñ…ÑÑ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¸Ğ¼ Ğ¾Ğ¿Ñ€Ğ¾Ñ."""
    now = datetime.datetime.now()
    # Ğ˜Ñ‰ĞµĞ¼ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»Ğ¸ÑÑŒ 3-4 Ñ‡Ğ°ÑĞ° Ğ½Ğ°Ğ·Ğ°Ğ´
    start_window = now - datetime.timedelta(hours=4)
    end_window = now - datetime.timedelta(hours=3)

    logger.info(f"Running no-show survey job for events ended between {start_window} and {end_window}")

    async with session_pool() as session:
        stmt = (
            select(EventRegistration)
            .join(Event)
            .where(
                Event.event_datetime.between(start_window, end_window),
                EventRegistration.status == 'registered'
            )
            .options(joinedload(EventRegistration.user), joinedload(EventRegistration.event))
        )
        results = await session.execute(stmt)
        no_shows = results.scalars().unique().all()
        
        if not no_shows:
            logger.info("No participants found for no-show survey.")
            return

        for reg in no_shows:
            try:
                builder = types.InlineKeyboardBuilder()
                reasons = {
                    "medical": "ĞœĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ (Ğ±Ğ¾Ğ»ĞµĞ·Ğ½ÑŒ)",
                    "personal": "Ğ›Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñ‹",
                    "forgot": "Ğ—Ğ°Ğ±Ñ‹Ğ»(Ğ°) / Ğ½Ğµ Ğ·Ğ°Ñ…Ğ¾Ñ‚ĞµĞ»(Ğ°)"
                }
                for key, text in reasons.items():
                    builder.row(types.InlineKeyboardButton(
                        text=text,
                        callback_data=f"no_show_{reg.event_id}_{key}"
                    ))
                
                await bot.send_message(
                    chat_id=reg.user.telegram_id,
                    text=(
                        f"Ğ”Ğ¾Ğ±Ñ€Ñ‹Ğ¹ Ğ´ĞµĞ½ÑŒ! Ğ’Ñ‹ Ğ±Ñ‹Ğ»Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑĞºÑƒÑ Ğ°ĞºÑ†Ğ¸Ñ Â«{reg.event.name}Â», "
                        "Ğ½Ğ¾ Ğ½Ğµ Ğ¾Ñ‚Ğ¼ĞµÑ‚Ğ¸Ğ»Ğ¸ÑÑŒ Ñƒ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ¾Ğ². ĞŸĞ¾Ğ´ÑĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ Ğ½Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¾ÑÑŒ Ğ¿Ñ€Ğ¸Ğ¹Ñ‚Ğ¸?"
                    ),
                    reply_markup=builder.as_markup()
                )
                # ĞœĞµĞ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾
                reg.status = 'no_show_survey_sent'
            except Exception as e:
                logger.error(f"Failed to send no-show survey to user {reg.user_id}: {e}")
        
        await session.commit()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/scheduler.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/text_messages.py ---

import html

class Text:
    @staticmethod
    def escape_html(text: str) -> str:
        """Ğ­ĞºÑ€Ğ°Ğ½Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹ Ğ´Ğ»Ñ parse_mode=HTML."""
        if not isinstance(text, str):
            text = str(text)
        return html.escape(text)

    @staticmethod
    def format_location_link(text: str, latitude: float | None, longitude: float | None) -> str:
        # Ğ­ĞºÑ€Ğ°Ğ½Ğ¸Ñ€ÑƒĞµĞ¼ Ğ²Ğ¸Ğ´Ğ¸Ğ¼ÑƒÑ Ñ‡Ğ°ÑÑ‚ÑŒ Ñ‚ĞµĞºÑÑ‚Ğ° Ğ´Ğ»Ñ HTML
        safe_visible_text = Text.escape_html(text)
        
        if latitude and longitude:
            # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ HTML-ÑÑÑ‹Ğ»ĞºÑƒ
            url = f"https://yandex.ru/maps/?pt={longitude},{latitude}&z=18&l=map"
            return f'<a href="{url}">{safe_visible_text}</a>'
            
        # Ğ•ÑĞ»Ğ¸ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚ Ğ½ĞµÑ‚, Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ ÑĞºÑ€Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚
        return safe_visible_text

    DONATION_TYPE_RU = {
        'whole_blood': 'Ğ¦ĞµĞ»ÑŒĞ½Ğ°Ñ ĞºÑ€Ğ¾Ğ²ÑŒ',
        'plasma': 'ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°',
        'platelets': 'Ğ¢Ñ€Ğ¾Ğ¼Ğ±Ğ¾Ñ†Ğ¸Ñ‚Ñ‹',
        'erythrocytes': 'Ğ­Ñ€Ğ¸Ñ‚Ñ€Ğ¾Ñ†Ğ¸Ñ‚Ñ‹'
    }
    WELCOME = "ğŸ‘‹ Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ğ±Ğ¾Ñ‚ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑĞºĞ¾Ğ³Ğ¾ Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ ĞœĞ˜Ğ¤Ğ˜!\n\nĞ”Ğ»Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ´ĞµĞ»Ğ¸Ñ‚ĞµÑÑŒ ÑĞ²Ğ¾Ğ¸Ğ¼ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ¾Ğ¼. Ğ­Ñ‚Ğ¾ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ´Ğ»Ñ Ğ²Ğ°ÑˆĞµĞ¹ Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²."
    AUTH_SUCCESS = "âœ… ĞĞ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾ÑˆĞ»Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾! Ğ¡ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼, {name}!"
    START_REGISTRATION = "ğŸ” ĞŸĞ¾Ñ…Ğ¾Ğ¶Ğµ, Ğ²Ñ‹ Ñƒ Ğ½Ğ°Ñ Ğ²Ğ¿ĞµÑ€Ğ²Ñ‹Ğµ. Ğ”Ğ°Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼Ğ¸Ğ¼ÑÑ!"
    GET_FULL_NAME = "ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ°ÑˆĞµ Ğ¤Ğ˜Ğ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ² Ğ˜Ğ²Ğ°Ğ½ Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‡):"
    GET_UNIVERSITY = "ğŸ“ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ’Ğ£Ğ—:"
    GET_CUSTOM_UNIVERSITY = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ’Ğ£Ğ—Ğ°:"
    GET_FACULTY = "ğŸ›ï¸ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚:"
    GET_CUSTOM_FACULTY = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ğ°:"
    GET_GROUP = "ğŸ”¢ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ¼ĞµÑ€ Ğ²Ğ°ÑˆĞµĞ¹ ÑƒÑ‡ĞµĞ±Ğ½Ğ¾Ğ¹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ‘20-505):"
    GET_GENDER = "ğŸš» Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ¿Ğ¾Ğ»:"
    REGISTRATION_COMPLETE = "ğŸ‰ ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°. Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ²ÑĞµĞ¼Ğ¸ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑĞ¼Ğ¸ Ğ±Ğ¾Ñ‚Ğ°."
    ERROR_WRONG_FORMAT = "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ğµ Ñ€Ğ°Ğ·."
    INFO_PREPARE = (
        "<b>ĞšĞ°Ğº Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ñ‚ÑŒÑÑ Ğº ÑĞ´Ğ°Ñ‡Ğµ ĞºÑ€Ğ¾Ğ²Ğ¸:</b>\n\n"
        "<b>ĞĞ°ĞºĞ°Ğ½ÑƒĞ½Ğµ Ğ¸ Ğ² Ğ´ĞµĞ½ÑŒ ÑĞ´Ğ°Ñ‡Ğ¸ ĞºÑ€Ğ¾Ğ²Ğ¸ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ğ¾:</b>\n"
        "â–ªï¸ Ğ£Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ»ÑÑ‚ÑŒ Ğ¶Ğ¸Ñ€Ğ½ÑƒÑ, Ğ¶Ğ°Ñ€ĞµĞ½ÑƒÑ, Ğ¾ÑÑ‚Ñ€ÑƒÑ Ğ¸ ĞºĞ¾Ğ¿Ñ‡ĞµĞ½ÑƒÑ Ğ¿Ğ¸Ñ‰Ñƒ, ĞºĞ¾Ğ»Ğ±Ğ°ÑĞ½Ñ‹Ğµ Ğ¸Ğ·Ğ´ĞµĞ»Ğ¸Ñ, Ğ° Ñ‚Ğ°ĞºĞ¶Ğµ Ğ¼ÑÑĞ½Ñ‹Ğµ, Ñ€Ñ‹Ğ±Ğ½Ñ‹Ğµ Ğ¸ Ğ¼Ğ¾Ğ»Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ‚Ñ‹, ÑĞ¹Ñ†Ğ° Ğ¸ Ğ¼Ğ°ÑĞ»Ğ¾ (Ğ² Ñ‚.Ñ‡. Ñ€Ğ°ÑÑ‚Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ), ÑˆĞ¾ĞºĞ¾Ğ»Ğ°Ğ´, Ğ¾Ñ€ĞµÑ…Ğ¸ Ğ¸ Ñ„Ğ¸Ğ½Ğ¸ĞºĞ¸.\n"
        "â–ªï¸ ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»ÑŒ Ğ·Ğ° 48 Ñ‡Ğ°ÑĞ¾Ğ² Ğ´Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸.\n"
        "â–ªï¸ ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ Ğ»ĞµĞºĞ°Ñ€ÑÑ‚Ğ²Ğ°, ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‰Ğ¸Ğµ Ğ°ÑĞ¿Ğ¸Ñ€Ğ¸Ğ½ Ğ¸ Ğ°Ğ½Ğ°Ğ»ÑŒĞ³ĞµÑ‚Ğ¸ĞºĞ¸, Ğ·Ğ° 72 Ñ‡Ğ°ÑĞ° Ğ´Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸.\n\n"
        "<b>Ğ§Ñ‚Ğ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ:</b>\n"
        "â–ªï¸ Ğ¥Ğ¾Ñ€Ğ¾ÑˆĞ¾ Ğ²Ñ‹ÑĞ¿Ğ°Ñ‚ÑŒÑÑ.\n"
        "â–ªï¸ Ğ›ĞµĞ³ĞºĞ¾ Ğ¿Ğ¾Ğ·Ğ°Ğ²Ñ‚Ñ€Ğ°ĞºĞ°Ñ‚ÑŒ (ÑĞ»Ğ°Ğ´ĞºĞ¸Ğ¹ Ñ‡Ğ°Ğ¹, ÑÑƒÑ…Ğ¾Ğµ Ğ¿ĞµÑ‡ĞµĞ½ÑŒĞµ, ĞºĞ°ÑˆĞ° Ğ½Ğ° Ğ²Ğ¾Ğ´Ğµ).\n"
        "â–ªï¸ ĞĞµ ĞºÑƒÑ€Ğ¸Ñ‚ÑŒ Ğ·Ğ° Ñ‡Ğ°Ñ Ğ´Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸.\n"
        "â–ªï¸ ĞĞµ Ğ¿Ñ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¸ Ğ½ĞµĞ´Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ğ½Ğ¸Ğ¸."
    )
    INFO_CONTRAINDICATIONS = (
        "<b>ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ (Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ¾Ñ‚ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑÑ‚Ğ²Ğ° Ğ½Ğ°Ğ²ÑĞµĞ³Ğ´Ğ°):</b>\n\n"
        "â–ªï¸ Ğ’Ğ˜Ğ§-Ğ¸Ğ½Ñ„ĞµĞºÑ†Ğ¸Ñ, ÑĞ¸Ñ„Ğ¸Ğ»Ğ¸Ñ, Ğ²Ğ¸Ñ€ÑƒÑĞ½Ñ‹Ğµ Ğ³ĞµĞ¿Ğ°Ñ‚Ğ¸Ñ‚Ñ‹.\n"
        "â–ªï¸ Ğ¢ÑƒĞ±ĞµÑ€ĞºÑƒĞ»ĞµĞ· (Ğ²ÑĞµ Ñ„Ğ¾Ñ€Ğ¼Ñ‹).\n"
        "â–ªï¸ Ğ‘Ğ¾Ğ»ĞµĞ·Ğ½Ğ¸ ĞºÑ€Ğ¾Ğ²Ğ¸.\n"
        "â–ªï¸ ĞĞ½ĞºĞ¾Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ·Ğ°Ğ±Ğ¾Ğ»ĞµĞ²Ğ°Ğ½Ğ¸Ñ.\n"
        "â–ªï¸ ĞĞ°Ñ€ĞºĞ¾Ğ¼Ğ°Ğ½Ğ¸Ñ, Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»Ğ¸Ğ·Ğ¼.\n\n"
        "<b>Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ:</b>\n"
        "â–ªï¸ Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ·ÑƒĞ±Ğ° (10 Ğ´Ğ½ĞµĞ¹).\n"
        "â–ªï¸ ĞĞ°Ğ½ĞµÑĞµĞ½Ğ¸Ğµ Ñ‚Ğ°Ñ‚ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸, Ğ¿Ğ¸Ñ€ÑĞ¸Ğ½Ğ³ (1 Ğ³Ğ¾Ğ´).\n"
        "â–ªï¸ ĞĞ½Ğ³Ğ¸Ğ½Ğ°, Ğ³Ñ€Ğ¸Ğ¿Ğ¿, ĞĞ Ğ’Ğ˜ (1 Ğ¼ĞµÑÑÑ† Ğ¿Ğ¾ÑĞ»Ğµ Ğ²Ñ‹Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ).\n"
        "â–ªï¸ ĞŸÑ€Ğ¸Ğ²Ğ¸Ğ²ĞºĞ¸ (Ğ¾Ñ‚ 10 Ğ´Ğ½ĞµĞ¹ Ğ´Ğ¾ 1 Ğ³Ğ¾Ğ´Ğ°)."
    )
    INFO_AFTER = (
        "<b>Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸:</b>\n\n"
        "â–ªï¸ ĞÑ‚Ğ´Ğ¾Ñ…Ğ½Ğ¸Ñ‚Ğµ 10â€“15 Ğ¼Ğ¸Ğ½ÑƒÑ‚.\n"
        "â–ªï¸ ĞĞµ ÑĞ½Ğ¸Ğ¼Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ²ÑĞ·ĞºÑƒ 3â€“4 Ñ‡Ğ°ÑĞ°.\n"
        "â–ªï¸ ĞĞµ Ğ¿Ğ¾Ğ´Ğ²ĞµÑ€Ğ³Ğ°Ğ¹Ñ‚ĞµÑÑŒ Ñ„Ğ¸Ğ·Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼ Ğ½Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°Ğ¼ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ½Ñ.\n"
        "â–ªï¸ Ğ’Ğ¾Ğ·Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ĞµÑÑŒ Ğ¾Ñ‚ ÑƒĞ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ»ĞµĞ½Ğ¸Ñ Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»Ñ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ ÑÑƒÑ‚Ğ¾Ğº.\n"
        "â–ªï¸ ĞŸĞµĞ¹Ñ‚Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ¶Ğ¸Ğ´ĞºĞ¾ÑÑ‚Ğ¸ Ğ¸ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ğ¾ Ğ¿Ğ¸Ñ‚Ğ°Ğ¹Ñ‚ĞµÑÑŒ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ²ÑƒÑ… ÑÑƒÑ‚Ğ¾Ğº."
    )
    INFO_CONTACTS = (
        "<b>Ğ¡Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼Ğ¸:</b>\n\n"
        "Ğ•ÑĞ»Ğ¸ Ñƒ Ğ²Ğ°Ñ Ğ²Ğ¾Ğ·Ğ½Ğ¸ĞºĞ»Ğ¸ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹, Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑĞ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ñ Ğ½Ğ°Ğ¼Ğ¸:\n"
        "â–ªï¸ Ğ¢ĞµĞ»ĞµĞ³Ñ€Ğ°Ğ¼-Ñ‡Ğ°Ñ‚ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²: [ÑÑÑ‹Ğ»ĞºĞ° Ğ½Ğ° Ñ‡Ğ°Ñ‚]\n"
        "â–ªï¸ ĞÑ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ·Ğ° Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑĞºĞ¾Ğµ Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ: [ĞĞ»ĞµĞºÑĞ°Ğ½Ğ´Ñ€, @Alkzaz7]"
    )
    NEW_EVENT_NOTIFICATION = (
        "ğŸ‰ <b>ĞĞ½Ğ¾Ğ½Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑĞºĞ¾Ğ³Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ!</b> \n\n"
        "ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ½Ğ°: <b>{event_name}</b>\n"
        "ğŸ—“ï¸ <b>ĞšĞ¾Ğ³Ğ´Ğ°:</b> {event_date} Ğ² {event_time}\n"
        "ğŸ“ <b>Ğ“Ğ´Ğµ:</b> {event_location}\n\n"
        "Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚ÑŒ ÑƒÑ‡Ğ°ÑÑ‚Ğ¸Ğµ! Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€ÑĞ¼Ğ¾ ÑĞµĞ¹Ñ‡Ğ°Ñ Ñ‡ĞµÑ€ĞµĞ· Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ğ±Ğ¾Ñ‚Ğ°. "
        "Ğ’Ğ°ÑˆĞ° Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒ Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ²Ğ°Ğ¶Ğ½Ğ°!"
    )

    PROFILE_DATA_TEMPLATE = (
        "ğŸ“Š <b>Ğ’Ğ°ÑˆĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ</b>\n\n"
        "ğŸ‘¤ <b>Ğ¤Ğ˜Ğ:</b> {full_name}\n"
        "ğŸ“ <b>Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ¸Ñ‚ĞµÑ‚:</b> {university}\n"
        "ğŸ›ï¸ <b>Ğ¤Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚:</b> {faculty}, <b>Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ°:</b> {study_group}\n"
        "â­ <b>Ğ‘Ğ°Ğ»Ğ»Ñ‹:</b> {points}\n"
        "ğŸ’‰ <b>Ğ’ÑĞµĞ³Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹:</b> {total_donations}\n"
        "ğŸ—“ï¸ <b>Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ°Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ñ:</b> {next_date}\n"
        "--- --- ---\n"
        "<b>ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ:</b> {last_donation_info}\n"
        "<b>Ğ”Ğ¾Ğ½Ğ¾Ñ€ ĞºĞ¾ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ·Ğ³Ğ° (Ğ”ĞšĞœ):</b> {dkm_status}"
    )

    INFO_DKM = (
        "<b>ğŸ©¸ Ğ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑÑ‚Ğ²Ğµ ĞºĞ¾ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ·Ğ³Ğ° (Ğ”ĞšĞœ)</b>\n\n"
        "<b>ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ²Ğ°Ğ¶Ğ½Ğ¾?</b>\n"
        "Ğ¢Ñ€Ğ°Ğ½ÑĞ¿Ğ»Ğ°Ğ½Ñ‚Ğ°Ñ†Ğ¸Ñ ĞºĞ¾ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ·Ğ³Ğ° â€” ÑÑ‚Ğ¾ ĞµĞ´Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ ÑˆĞ°Ğ½Ñ Ğ½Ğ° Ğ¶Ğ¸Ğ·Ğ½ÑŒ Ğ´Ğ»Ñ Ğ¼Ğ½Ğ¾Ğ³Ğ¸Ñ… Ğ»ÑĞ´ĞµĞ¹ Ñ Ñ€Ğ°ĞºĞ¾Ğ¼ ĞºÑ€Ğ¾Ğ²Ğ¸. Ğ’Ğ°ÑˆĞ¸ ÑÑ‚Ğ²Ğ¾Ğ»Ğ¾Ğ²Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸ Ğ¼Ğ¾Ğ³ÑƒÑ‚ ÑĞ¿Ğ°ÑÑ‚Ğ¸ Ñ‡ÑŒÑ-Ñ‚Ğ¾ Ğ¶Ğ¸Ğ·Ğ½ÑŒ.\n\n"
        "<b>ĞšĞ°Ğº Ğ²ÑÑ‚ÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ² Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€?</b>\n"
        "ĞĞ° ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ Ğ”Ğ½Ğµ Ğ”Ğ¾Ğ½Ğ¾Ñ€Ğ° Ğ² ĞœĞ˜Ğ¤Ğ˜ Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑĞ´Ğ°Ñ‚ÑŒ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ Ğ¿Ñ€Ğ¾Ğ±Ğ¸Ñ€ĞºÑƒ ĞºÑ€Ğ¾Ğ²Ğ¸ (4-9 Ğ¼Ğ»), Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ğ°ÑˆĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ²Ğ½ĞµÑĞ»Ğ¸ Ğ² Ğ¤ĞµĞ´ĞµÑ€Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ² ĞºĞ¾ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ·Ğ³Ğ°. Ğ­Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾, Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾ Ğ¸ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾.\n\n"
        "<b>Ğ§Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ´Ğ°Ğ»ÑŒÑˆĞµ?</b>\n"
        "Ğ•ÑĞ»Ğ¸ Ğ²Ğ°ÑˆĞ¸ ĞºĞ»ĞµÑ‚ĞºĞ¸ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ÑƒÑ‚ Ñ ĞºĞ»ĞµÑ‚ĞºĞ°Ğ¼Ğ¸ Ğ½ÑƒĞ¶Ğ´Ğ°ÑÑ‰ĞµĞ³Ğ¾ÑÑ Ğ¿Ğ°Ñ†Ğ¸ĞµĞ½Ñ‚Ğ°, Ñ Ğ²Ğ°Ğ¼Ğ¸ ÑĞ²ÑĞ¶ÑƒÑ‚ÑÑ. Ğ¡Ğ°Ğ¼Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ñ…Ğ¾Ğ¶Ğ° Ğ½Ğ° ÑĞ´Ğ°Ñ‡Ñƒ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ² ĞºÑ€Ğ¾Ğ²Ğ¸ Ğ¸ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ° Ğ´Ğ»Ñ Ğ²Ğ°Ñ."
    )

    INFO_MIFI_PROCESS = (
        "<b>ğŸ¥ ĞšĞ°Ğº Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´ÑÑ‚ Ğ”Ğ½Ğ¸ Ğ”Ğ¾Ğ½Ğ¾Ñ€Ğ° Ğ² ĞœĞ˜Ğ¤Ğ˜</b>\n\n"
        "<b>1. Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ:</b> Ğ—Ğ°Ñ€Ğ°Ğ½ĞµĞµ Ğ·Ğ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚ĞµÑÑŒ Ğ½Ğ° ÑƒĞ´Ğ¾Ğ±Ğ½ÑƒÑ Ğ´Ğ°Ñ‚Ñƒ Ñ‡ĞµÑ€ĞµĞ· ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ñ‚Ğ°.\n"
        "<b>2. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°:</b> Ğ¡Ğ¾Ğ±Ğ»ÑĞ´Ğ°Ğ¹Ñ‚Ğµ Ğ´Ğ¸ĞµÑ‚Ñƒ Ğ¸ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ĞµÑ€ĞµĞ´ ÑĞ´Ğ°Ñ‡ĞµĞ¹ ĞºÑ€Ğ¾Ğ²Ğ¸.\n"
        "<b>3. Ğ’ Ğ´ĞµĞ½ÑŒ Ğ°ĞºÑ†Ğ¸Ğ¸:</b> ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚Ğµ Ğ² Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ Ñ Ğ¿Ğ°ÑĞ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ¼. Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ñ‹ Ğ²Ğ°Ñ Ğ²ÑÑ‚Ñ€ĞµÑ‚ÑÑ‚ Ğ¸ Ğ¿Ñ€Ğ¾Ğ²Ğ¾Ğ´ÑÑ‚.\n"
        "<b>4. ĞÑĞ¼Ğ¾Ñ‚Ñ€:</b> Ğ’Ñ‹ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµÑ‚Ğµ Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ñƒ Ğ²Ñ€Ğ°Ñ‡Ğ° Ğ¸Ğ· Ğ¦ĞµĞ½Ñ‚Ñ€Ğ° ĞšÑ€Ğ¾Ğ²Ğ¸.\n"
        "<b>5. Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ:</b> Ğ¡Ğ°Ğ¼Ğ° Ğ¿Ñ€Ğ¾Ñ†ĞµĞ´ÑƒÑ€Ğ° ÑĞ´Ğ°Ñ‡Ğ¸ ĞºÑ€Ğ¾Ğ²Ğ¸ Ğ·Ğ°Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ 10-15 Ğ¼Ğ¸Ğ½ÑƒÑ‚.\n"
        "<b>6. ĞÑ‚Ğ´Ñ‹Ñ…:</b> ĞŸĞ¾ÑĞ»Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ¾Ñ‚Ğ´Ğ¾Ñ…Ğ½Ğ¸Ñ‚Ğµ, Ğ²Ñ‹Ğ¿ĞµĞ¹Ñ‚Ğµ ÑĞ»Ğ°Ğ´ĞºĞ¸Ğ¹ Ñ‡Ğ°Ğ¹ Ñ Ğ¿ĞµÑ‡ĞµĞ½ÑŒĞµĞ¼.\n"
        "<b>7. Ğ‘Ğ°Ğ»Ğ»Ñ‹ Ğ¸ Ğ¼ĞµÑ€Ñ‡:</b> ĞĞµ Ğ·Ğ°Ğ±ÑƒĞ´ÑŒÑ‚Ğµ Ğ¾Ñ‚ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ QR-ĞºĞ¾Ğ´ Ñƒ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ±Ğ°Ğ»Ğ»Ñ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾Ğ±Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ½Ğ° Ğ¼ĞµÑ€Ñ‡!\n\n"
        "Ğ”Ğ°Ñ‚Ğ° Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞµĞ³Ğ¾ Ğ”Ğ½Ñ Ğ”Ğ¾Ğ½Ğ¾Ñ€Ğ° Ğ±ÑƒĞ´ĞµÑ‚ Ğ°Ğ½Ğ¾Ğ½ÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ² Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞµ."
    )

    CONSENT_TEXT = (
        "<b>Ğ¡Ğ¾Ğ³Ğ»Ğ°ÑĞ¸Ğµ Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…</b>\n\n"
        "ĞĞ°Ğ¶Ğ¸Ğ¼Ğ°Ñ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Â«ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸ÑÂ», Ğ²Ñ‹ Ğ´Ğ°ĞµÑ‚Ğµ ÑĞ²Ğ¾Ğµ ÑĞ¾Ğ³Ğ»Ğ°ÑĞ¸Ğµ Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ñ… Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: Ğ¤Ğ˜Ğ, Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°, telegram-username, Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ÑÑ….\n\n"
        "Ğ¦ĞµĞ»Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸: Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ², Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸ÑÑ… Ğ¸ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ÑÑ… Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑĞºĞ¾Ğ³Ğ¾ Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜, Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸.\n\n"
        "Ğ’Ğ°ÑˆĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ½Ğµ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ğ½Ñ‹ Ñ‚Ñ€ĞµÑ‚ÑŒĞ¸Ğ¼ Ğ»Ğ¸Ñ†Ğ°Ğ¼, Ğ·Ğ° Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ĞµĞ¼ ÑĞ»ÑƒÑ‡Ğ°ĞµĞ², Ğ¿Ñ€ĞµĞ´ÑƒÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ½Ñ‹Ñ… Ğ·Ğ°ĞºĞ¾Ğ½Ğ¾Ğ´Ğ°Ñ‚ĞµĞ»ÑŒÑÑ‚Ğ²Ğ¾Ğ¼."
    )

    WELCOME_BACK = "âœ… Ğ¡ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼, {name}!"
    MAIN_MENU_PROMPT = "Ğ§ĞµĞ¼ Ğ¼Ğ¾Ğ³Ñƒ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‡ÑŒ?"
    USER_BLOCKED_MESSAGE = "âŒ Ğš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ğ²Ñ‹ Ğ±Ñ‹Ğ»Ğ¸ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹."
    SWITCH_TO_DONOR_VIEW = "âœ… Ğ’Ñ‹ Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ğ»Ğ¸ÑÑŒ Ğ² Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ°. Ğ—Ğ´ĞµÑÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹ Ğ²ÑĞµ ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‡ĞµÑĞºĞ¸Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸."
    ERROR_PROFILE_NOT_FOUND = "ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ²Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ."
    ALREADY_REGISTERED = "Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹, {name}!"
    USER_BLOCKED_ON_AUTH = "âŒ Ğ’Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½."
    ACTION_CANCELLED = "Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾."
    ADMIN_SWITCH_TO_VOLUNTEER_VIEW = "â­ <b>Ğ’Ñ‹ Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ğ»Ğ¸ÑÑŒ Ğ² Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°</b>"
    UNKNOWN_COMMAND = "Ğ¯ Ğ½Ğµ Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°Ñ ÑÑ‚Ñƒ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ¼ĞµĞ½Ñ Ğ´Ğ»Ñ Ğ½Ğ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ğ¸."
    ERROR_GENERIC_ALERT = "ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°."
    INFO_SECTION_NOT_FOUND = "Ğ Ğ°Ğ·Ğ´ĞµĞ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½."
    GET_CATEGORY = "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆÑƒ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ:"
    FIO_VALIDATION_ERROR = "âŒ Ğ¤Ğ˜Ğ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ñ†Ğ¸Ñ„Ñ€ Ğ¸Ğ»Ğ¸ ÑĞ¿ĞµÑ†ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ². ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ."
    FACULTY_SELECTED = "Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚: {faculty}"
    GENDER_SELECTED = "ĞŸĞ¾Ğ»: {gender}"
    DATE_FORMAT_ERROR = "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ´Ğ°Ñ‚Ñ‹. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ <b>Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“</b>."
    PROFILE_MENU_HEADER = "ğŸ‘¤ <b>ĞœĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ, Ñ‡Ñ‚Ğ¾ Ğ²Ğ°Ñ Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑÑƒĞµÑ‚:"
    PROFILE_LOAD_ERROR = "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ."
    NO_DONATION_HISTORY = "Ğ£ Ğ²Ğ°Ñ ĞµÑ‰Ğµ Ğ½ĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹ Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ÑÑ…."
    DONATION_HISTORY_HEADER = "ğŸ©¸ <b>Ğ’Ğ°ÑˆĞ° Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹:</b>\n\n"
    DONATION_HISTORY_ITEM = "â–ªï¸ {date}: {type}, <b>+{points} Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²</b>\n"
    NO_ACTIVE_EVENTS = "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ ÑĞµĞ¹Ñ‡Ğ°Ñ Ğ½ĞµÑ‚."
    CHOOSE_EVENT_TO_REGISTER = "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸:"
    ALREADY_REGISTERED_FOR_EVENT = (
        "Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Â«<b>{event_name}</b>Â».\n\n"
        "ğŸ“ <b>ĞœĞµÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ñ:</b> {event_location}\n"
        "ğŸ¢ <b>Ğ¦ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸:</b> {blood_center_name}\n\n"
        "Ğ—Ğ´ĞµÑÑŒ Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ QR-ĞºĞ¾Ğ´ Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ²Ğ¾Ñ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ."
    )
    REGISTRATION_SUCCESSFUL = (
        "âœ… Ğ’Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ°: <b>{event_name}</b>\n\n"
        "ğŸ“ <b>ĞœĞµÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ñ:</b> {event_location}\n"
        "ğŸ¢ <b>Ğ¦ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸:</b> {blood_center_name}\n\n"
        "Ğ’Ğ°Ñˆ QR-ĞºĞ¾Ğ´ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ¿Ğ¾ ĞºĞ½Ğ¾Ğ¿ĞºĞµ Ğ½Ğ¸Ğ¶Ğµ."
    )
    REGISTRATION_FAILED = "âŒ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ½ĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ°.\nĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: {reason}"
    REGISTRATION_CANCELLED_SUCCESS = "âœ… Ğ’Ğ°ÑˆĞ° Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ±Ñ‹Ğ»Ğ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°."
    REGISTRATION_CANCELLED_FAIL = "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ. Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾, Ğ¾Ğ½Ğ° ÑƒĞ¶Ğµ Ğ±Ñ‹Ğ»Ğ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°."
    MERCH_NO_ITEMS = "Ğ’ Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½Ğµ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ²."
    MERCH_ITEM_CAPTION = (
        "ğŸ›ï¸ <b>{item_name}</b>\n\n"
        "{item_description}\n\n"
        "Ğ¦ĞµĞ½Ğ°: <b>{item_price}</b> Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²\n"
        "Ğ’Ğ°Ñˆ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ: <b>{user_points}</b> Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²"
    )
    MERCH_PURCHASE_INSUFFICIENT_FUNDS = "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ². ĞÑƒĞ¶Ğ½Ğ¾ {price}, Ñƒ Ğ²Ğ°Ñ {points}."
    MERCH_ITEM_NOT_FOUND = "Ğ¢Ğ¾Ğ²Ğ°Ñ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½."
    MERCH_PURCHASE_CONFIRMATION = (
        "Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ĞºÑƒĞ¿Ğ¸Ñ‚ÑŒ <b>'{item_name}'</b> Ğ·Ğ° <b>{item_price}</b> Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²?\n\n"
        "Ğ’Ğ°Ñˆ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸: <b>{new_balance}</b> Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²."
    )
    MERCH_PURCHASE_SUCCESS = "ğŸ‰ ĞŸĞ¾Ğ·Ğ´Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¾Ğ¹!\n{message}\n\nĞœÑ‹ ÑĞ¾Ğ¾Ğ±Ñ‰Ğ¸Ğ¼, ĞºĞ¾Ğ³Ğ´Ğ° Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ±ÑƒĞ´ĞµÑ‚ Ğ·Ğ°Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·."
    MERCH_PURCHASE_ERROR = "âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ°: {message}"
    MERCH_NO_ORDERS = "Ğ£ Ğ²Ğ°Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²."
    MERCH_ORDERS_HEADER = "ğŸ›ï¸ <b>Ğ’Ğ°ÑˆĞ¸ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹:</b>\n\n"
    MERCH_ORDER_ITEM = "â–ªï¸ <b>{item_name}</b> (Ğ¾Ñ‚ {date})\n   Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: <b>{status}</b>\n"
    MERCH_STATUS_MAP = {'pending_pickup': 'ĞĞ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ²Ñ‹Ğ´Ğ°Ñ‡Ğ¸', 'completed': 'Ğ’Ñ‹Ğ´Ğ°Ğ½'}
    MERCH_UPDATE_ERROR = "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ²Ğ¾Ğ¹Ñ‚Ğ¸ Ğ² Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾."
    WAIVERS_MENU_HEADER = "âš•ï¸ <b>Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¼ĞµĞ´Ğ¸Ñ†Ğ¸Ğ½ÑĞºĞ¸Ğ¼Ğ¸ Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°Ğ¼Ğ¸</b>\n"
    NO_ACTIVE_WAIVERS = "\nâœ… Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ². Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑĞ¿Ğ°ÑĞ°Ñ‚ÑŒ Ğ¶Ğ¸Ğ·Ğ½Ğ¸! ğŸ’ª"
    SYSTEM_WAIVERS_HEADER = "\n<b>ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¾Ğ¹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ¼ (Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ):</b>"
    USER_WAIVERS_HEADER = "\n<b>Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ²Ğ°Ğ¼Ğ¸ (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ):</b>"
    WAIVER_ITEM_FORMAT = "â–ªï¸ Ğ”Ğ¾ <b>{end_date}</b> Ğ¿Ğ¾ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğµ: Â«{reason}Â»"
    WAIVER_SET_PROMPT = (
        "Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ¾Ñ‚ Ğ´Ğ¾Ğ½Ğ¾Ñ€ÑÑ‚Ğ²Ğ° (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ¸Ğ·-Ğ·Ğ° ĞĞ Ğ’Ğ˜ Ğ¸Ğ»Ğ¸ Ğ¿Ğ»Ğ¾Ñ…Ğ¾Ğ³Ğ¾ ÑĞ°Ğ¼Ğ¾Ñ‡ÑƒĞ²ÑÑ‚Ğ²Ğ¸Ñ).\n\n"
        "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ, Ğ´Ğ¾ ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ Ğ±ÑƒĞ´ĞµÑ‚ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‚Ğ²Ğ¾Ğ´, Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ <b>Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“</b>:"
    )
    WAIVER_DATE_IN_PAST_ERROR = "âŒ Ğ”Ğ°Ñ‚Ğ° Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ñ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ² Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞ¼. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°."
    WAIVER_REASON_PROMPT = "ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾. Ğ¢ĞµĞ¿ĞµÑ€ÑŒ ĞºÑ€Ğ°Ñ‚ĞºĞ¾ ÑƒĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, 'ĞŸÑ€Ğ¾ÑÑ‚ÑƒĞ´Ğ°', 'ĞŸĞ»Ğ¾Ñ…Ğ¾Ğµ ÑĞ°Ğ¼Ğ¾Ñ‡ÑƒĞ²ÑÑ‚Ğ²Ğ¸Ğµ'):"
    WAIVER_SET_SUCCESS = "âœ… Ğ’Ğ°Ñˆ Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ´Ğ¾ {end_date}."
    WAIVER_CANCELLATION_PROMPT = "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ, ĞºĞ°ĞºĞ¾Ğ¹ Ğ¸Ğ· Ğ²Ğ°ÑˆĞ¸Ñ… Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ² Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ:"
    WAIVER_NOTHING_TO_CANCEL = "Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ."
    WAIVER_CANCEL_SUCCESS = "âœ… Ğ’Ğ°Ñˆ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½."
    WAIVER_CANCEL_FAIL = "âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ²Ğ¾Ğ´."
    INFO_MENU_HEADER = "â„¹ï¸ <b>ĞŸĞ¾Ğ»ĞµĞ·Ğ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑÑƒÑÑ‰Ğ¸Ğ¹ Ğ²Ğ°Ñ Ñ€Ğ°Ğ·Ğ´ĞµĞ»:"
    QR_GENERATING = "Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒÑ Ğ²Ğ°Ñˆ QR-ĞºĞ¾Ğ´..."
    QR_GENERAL_CAPTION = "Ğ­Ñ‚Ğ¾Ñ‚ QR-ĞºĞ¾Ğ´ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ»Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾Ğ¹ Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸. Ğ”Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ QR-ĞºĞ¾Ğ´ Ğ¸Ğ· Ğ¼ĞµĞ½Ñ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ."
    QR_EVENT_CAPTION = "ĞŸĞ¾ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ÑÑ‚Ğ¾Ñ‚ QR-ĞºĞ¾Ğ´ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚Ñ‘Ñ€Ñƒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ñ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²."
    VOLUNTEER_MENU_HEADER = "â­ <b>ĞœĞµĞ½Ñ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚Ñ‘Ñ€Ğ°</b>"
    VOLUNTEER_SEND_QR_PROMPT = "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¼Ğ½Ğµ Ñ„Ğ¾Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ Ñ QR-ĞºĞ¾Ğ´Ğ¾Ğ¼ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ°."
    QR_READ_ERROR = "âŒ QR-ĞºĞ¾Ğ´ Ğ½Ğµ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ğ½ Ğ¸Ğ»Ğ¸ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°."
    QR_INVALID_DATA_ERROR = "âŒ QR-ĞºĞ¾Ğ´ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ."
    QR_DB_LOOKUP_ERROR = "âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¸Ğ»Ğ¸ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ¸Ğ· QR-ĞºĞ¾Ğ´Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ² Ğ±Ğ°Ğ·Ğµ."
    QR_DONOR_NOT_REGISTERED_ERROR = "âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ”Ğ¾Ğ½Ğ¾Ñ€ <b>{donor_name}</b> Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ğ½Ğ° ÑÑ‚Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ."
    QR_WRONG_DAY_ERROR = "âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ­Ñ‚Ğ¾Ñ‚ QR-ĞºĞ¾Ğ´ Ğ´Ğ»Ñ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğµ ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ."
    VOLUNTEER_CONFIRMATION_PROMPT = (
        "ğŸ” <b>ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸</b>\n\n"
        "Ğ’Ñ‹ ÑĞ¾Ğ±Ğ¸Ñ€Ğ°ĞµÑ‚ĞµÑÑŒ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ:\n"
        "ğŸ‘¤ <b>Ğ”Ğ¾Ğ½Ğ¾Ñ€:</b> {donor_name}\n"
        "ğŸ—“ï¸ <b>ĞœĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ:</b> {event_name}\n\n"
        "Ğ’ÑĞµ Ğ²ĞµÑ€Ğ½Ğ¾?"
    )
    VOLUNTEER_CONFIRMATION_ERROR = "âŒ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚ÑĞºĞ°Ğ½Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ QR-ĞºĞ¾Ğ´ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾."
    DONATION_CONFIRMING = "â³ ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´Ğ°Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ..."
    DONATION_CONFIRM_ERROR_NO_REG = "âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ° Ğ¸Ğ»Ğ¸ ĞµĞ³Ğ¾ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ. Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾, Ğ¾Ğ½Ğ° Ğ±Ñ‹Ğ»Ğ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°."
    DONATION_CONFIRM_SUCCESS = (
        "âœ… Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ <b>{donor_name}</b> Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¸ Â«<b>{event_name}</b>Â» Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ°.\n\n"
        "ĞĞ°Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¾ <b>{points}</b> Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ².\n\nĞ“Ğ¾Ñ‚Ğ¾Ğ²Ñ‹ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ QR-ĞºĞ¾Ğ´."
    )
    DONATION_CONFIRM_CRITICAL_ERROR = "ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğ¸ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸: {error}"
    VOLUNTEER_INVALID_INPUT_QR = "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ Ñ„Ğ¾Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ Ñ QR-ĞºĞ¾Ğ´Ğ¾Ğ¼."
    ADMIN_PANEL_HEADER = "âš™ï¸ ĞŸĞ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°"
    ADMIN_EVENTS_HEADER = "ğŸ—“ï¸ Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸ÑĞ¼Ğ¸"
    EVENT_CREATE_STEP_1_NAME = "Ğ¨Ğ°Ğ³ 1/7: Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ:"
    EVENT_CREATE_STEP_2_DATE = "Ğ¨Ğ°Ğ³ 2/7: Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ Ğ¸ Ğ²Ñ€ĞµĞ¼Ñ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ <b>Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“ Ğ§Ğ§:ĞœĞœ</b> (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, 25.12.2024 10:30):"
    EVENT_CREATE_STEP_3_LOCATION_TEXT = "Ğ¨Ğ°Ğ³ 3/7: Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ°Ğ´Ñ€ĞµÑ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, 'Ğ³. ĞœĞ¾ÑĞºĞ²Ğ°, ÑƒĞ». ĞšĞ°ÑˆĞ¸Ñ€ÑĞºĞ¾Ğµ ÑˆĞ¾ÑÑĞµ, Ğ´. 31'):"
    EVENT_CREATE_STEP_4_LOCATION_POINT = "Ğ¨Ğ°Ğ³ 4/7: ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾. Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ³ĞµĞ¾Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ°Ğ´Ñ€ĞµÑĞ°, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ñ‹ Ğ¼Ğ¾Ğ³Ğ»Ğ¸ Ğ»ĞµĞ³ĞºĞ¾ Ğ¿Ğ¾ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ÑŒ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚."
    EVENT_CREATE_STEP_5_TYPE = "Ğ¨Ğ°Ğ³ 5/7: Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸:"
    EVENT_CREATE_STEP_6_POINTS = "Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½ Ñ‚Ğ¸Ğ¿: {donation_type}\n\nĞ¨Ğ°Ğ³ 6/7: Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ² Ğ·Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ:"
    EVENT_CREATE_STEP_7_LIMIT = "Ğ¨Ğ°Ğ³ 7/7: Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²:"
    EVENT_LIMIT_NAN_ERROR = "âŒ Ğ›Ğ¸Ğ¼Ğ¸Ñ‚ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ¼."
    EVENT_POINTS_NAN_ERROR = "âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ»Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾."
    EVENT_CREATE_CONFIRMATION = (
        "âœ… Ğ’ÑĞµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ¾Ğ±Ñ€Ğ°Ğ½Ñ‹. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ:\n\n"
        "â–ªï¸ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: {name}\n"
        "â–ªï¸ Ğ”Ğ°Ñ‚Ğ° Ğ¸ Ğ²Ñ€ĞµĞ¼Ñ: {datetime}\n"
        "â–ªï¸ ĞĞ´Ñ€ĞµÑ: {location}\n"
        "â–ªï¸ Ğ¦ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸: {blood_center_name}\n"
        "â–ªï¸ Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ğµ: {location_set}\n"
        "â–ªï¸ Ğ¢Ğ¸Ğ¿: {type}\n"
        "â–ªï¸ Ğ‘Ğ°Ğ»Ğ»Ñ‹: {points}\n"
        "â–ªï¸ Ğ›Ğ¸Ğ¼Ğ¸Ñ‚: {limit}\n\n"
        "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºÑƒ?"
    )
    EVENT_CREATING_IN_PROGRESS = "ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ..."
    EVENT_CREATE_SUCCESS = "âœ… ĞœĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¾!"
    MAILING_STARTED_NOTIFICATION = "â³ ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºÑƒ. Ğ­Ñ‚Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ·Ğ°Ğ½ÑÑ‚ÑŒ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ..."
    MAILING_FINISHED_NOTIFICATION = "âœ… Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°.\n\nĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {success}\nĞÑˆĞ¸Ğ±Ğ¾Ğº: {fail}"
    MAILING_ERROR = "âŒ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸."
    ADMIN_NO_ACTIVE_EVENTS = "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ½ĞµÑ‚."
    ADMIN_CHOOSE_EVENT_TO_MANAGE = "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ:\n(âœ… - Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°, ğŸ”’ - Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°)"
    EVENT_NOT_FOUND = "ĞœĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾."
    EVENT_CARD_TEMPLATE = (
        "ğŸ—“ï¸ {name}\n\n"
        "â–ªï¸ {date_header} {datetime}\n" 
        "â–ªï¸ {location_header} {location}\n"
        "â–ªï¸ <b>Ğ¦ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸:</b> {blood_center_name}\n"
        "â–ªï¸ {type_header} {donation_type}\n"
        "â–ªï¸ {points_header} {points_per_donation}\n"
        "â–ªï¸ {limit_header} {reg_count}/{participant_limit}\n"
        "â–ªï¸ {status_header} {is_active}\n"
        "â–ªï¸ {reg_status_header} {reg_is_open}"
    )
    EVENT_TOGGLE_REG_OPEN = "Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°."
    EVENT_TOGGLE_REG_CLOSED = "Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°."
    EVENT_EDIT_PROMPT = "Ğ’Ñ‹ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€ÑƒĞµÑ‚Ğµ: <b>{event_name}</b>\n\nĞšĞ°ĞºĞ¾Ğµ Ğ¿Ğ¾Ğ»Ğµ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ?"
    EVENT_EDIT_FIELD_PROMPTS = {
        "name": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ:",
        "event_date": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ğ´Ğ°Ñ‚Ñƒ (Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“):",
        "location": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¼ĞµÑÑ‚Ğ¾:",
        "points_per_donation": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ ĞºĞ¾Ğ»-Ğ²Ğ¾ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²:",
        "participant_limit": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚:"
    }
    EVENT_EDIT_INVALID_FORMAT = "âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°."
    EVENT_EDIT_SUCCESS = "âœ… ĞŸĞ¾Ğ»Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾!"
    EVENT_NO_PARTICIPANTS = "ĞĞ° '{event_name}' Ğ¿Ğ¾ĞºĞ° Ğ½Ğ¸ĞºÑ‚Ğ¾ Ğ½Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ»ÑÑ."
    EVENT_PARTICIPANTS_CAPTION = "Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ '{event_name}'"
    EVENT_CANCEL_CONFIRMATION = "ğŸš¨ <b>ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹</b>\n\nĞ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Â«<b>{event_name}</b>Â»?\n\nĞ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ <b>{reg_count}</b> ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°Ğ¼."
    EVENT_CANCELLING_IN_PROGRESS = "â³ ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹..."
    EVENT_CANCEL_NOTIFICATION_TEXT = "â—ï¸ <b>Ğ’Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ, Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾!</b>\n\nĞš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Â«<b>{event_name}</b>Â», Ğ·Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ½Ğ° {datetime}, Ğ±Ñ‹Ğ»Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾."
    EVENT_CANCEL_SUCCESS_REPORT = "âœ… <b>ĞœĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Â«{event_name}Â» Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾.</b>\n\n<b>Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹:</b>\n- Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {success}\n- ĞÑˆĞ¸Ğ±Ğ¾Ğº: {fail}"
    MAILING_STEP_1_TEXT_PROMPT = (
        "Ğ’Ñ‹ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸.\n\n"
        "<b>Ğ¨Ğ°Ğ³ 1/3:</b> Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‚ĞµĞºÑÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ. ĞĞ½ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑŒÑ, ĞµÑĞ»Ğ¸ Ğ²Ñ‹ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚Ğµ Ñ„Ğ¾Ñ‚Ğ¾/Ğ²Ğ¸Ğ´ĞµĞ¾. "
        "ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ HTML-Ñ‚ĞµĞ³Ğ¸: <b>Ğ¶Ğ¸Ñ€Ğ½Ñ‹Ğ¹</b>, <i>ĞºÑƒÑ€ÑĞ¸Ğ²</i>, <code>ĞºĞ¾Ğ´</code>, <a href='...'>ÑÑÑ‹Ğ»ĞºĞ°</a>.\n\n"
        "Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ, Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /cancel."
    )
    MAILING_STEP_2_MEDIA_PROMPT = (
        "Ğ¢ĞµĞºÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½.\n\n"
        "<b>Ğ¨Ğ°Ğ³ 2/3:</b> Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ñ„Ğ¾Ñ‚Ğ¾ Ğ¸Ğ»Ğ¸ Ğ²Ğ¸Ğ´ĞµĞ¾, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¸ĞºÑ€ĞµĞ¿Ğ¸Ñ‚ÑŒ Ğº Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞµ. "
        "Ğ•ÑĞ»Ğ¸ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‚ĞµĞºÑÑ‚, Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ 'ĞŸÑ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ'."
    )
    MAILING_PHOTO_RECEIVED = "Ğ¤Ğ¾Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾.\n\n<b>Ğ¨Ğ°Ğ³ 3/3:</b> Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸:"
    MAILING_VIDEO_RECEIVED = "Ğ’Ğ¸Ğ´ĞµĞ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾.\n\n<b>Ğ¨Ğ°Ğ³ 3/3:</b> Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸:"
    MAILING_STEP_3_AUDIENCE_PROMPT = "<b>Ğ¨Ğ°Ğ³ 3/3:</b> Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸:"
    MAILING_AUDIENCE_MAP = {
        "all": "Ğ’ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼",
        "can_donate": "Ğ”Ğ¾Ğ½Ğ¾Ñ€Ğ°Ğ¼, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ ÑĞ´Ğ°Ğ²Ğ°Ñ‚ÑŒ",
        "volunteers": "Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°Ğ¼",
        "admins": "ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼"
    }
    MAILING_PREVIEW_HEADER = (
    "<b>ğŸ” ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºÑƒ Ğ¿ĞµÑ€ĞµĞ´ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ¾Ğ¼</b>\n\n"
    "<b>ğŸ‘¤ ĞÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ:</b> {audience}\n"
    "<b>ğŸ‘¥ ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ĞµĞ»ĞµĞ¹:</b> {count}\n"
    )
    MAILING_PREVIEW_WITH_PHOTO = "ğŸ–¼ï¸ <b>ĞŸÑ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¾ Ñ„Ğ¾Ñ‚Ğ¾</b>\n"
    MAILING_PREVIEW_WITH_VIDEO = "ğŸ“¹ <b>ĞŸÑ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¾ Ğ²Ğ¸Ğ´ĞµĞ¾</b>\n"
    MAILING_PREVIEW_TEXT_HEADER = "\n<b>âœ‰ï¸ Ğ¢ĞµĞºÑÑ‚/Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑŒ:</b>\n------------------------------------\n{text}\n------------------------------------"
    MAILING_EDIT_TEXT_PROMPT = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸:"
    MAILING_CONFIRMED_AND_RUNNING = "âœ… Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ° Ğ² Ñ„Ğ¾Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğµ. Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ±Ğ¾Ñ‚Ğ¾Ğ¼."
    ADMIN_MERCH_HEADER = "ğŸ›ï¸ <b>Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½Ğ¾Ğ¼</b>"
    MERCH_CREATE_STEP_1_PHOTO = "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ñ„Ğ¾Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°."
    MERCH_PHOTO_RECEIVED = "Ğ¤Ğ¾Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°:"
    MERCH_NAME_RECEIVED = "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°:"
    MERCH_DESC_RECEIVED = "ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ†ĞµĞ½Ñƒ Ğ² Ğ±Ğ°Ğ»Ğ»Ğ°Ñ…:"
    MERCH_PRICE_NAN_ERROR = "âŒ Ğ¦ĞµĞ½Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ñ†ĞµĞ»Ñ‹Ğ¼ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ¼."
    MERCH_CREATE_PHOTO_ID_ERROR = "âŒ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: ID Ñ„Ğ¾Ñ‚Ğ¾ Ğ½Ğµ Ğ±Ñ‹Ğ» ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½. ĞĞ°Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾."
    MERCH_CREATE_SUCCESS = "âœ… Ğ¢Ğ¾Ğ²Ğ°Ñ€ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½!"
    ADMIN_NO_MERCH_ITEMS = "Ğ’ Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½Ğµ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ²."
    ADMIN_CHOOSE_MERCH_TO_MANAGE = "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ:"
    MERCH_CARD_CAPTION = (
        "ğŸ›ï¸ <b>Ğ¢Ğ¾Ğ²Ğ°Ñ€: {name}</b>\n\n"
        "â–ªï¸ <b>ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:</b> {description}\n"
        "â–ªï¸ <b>Ğ¦ĞµĞ½Ğ°:</b> {price} Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²\n"
        "â–ªï¸ <b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> {status}"
    )
    MERCH_EDIT_PROMPT = "Ğ’Ñ‹ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€ÑƒĞµÑ‚Ğµ: <b>{name}</b>\n\nĞšĞ°ĞºĞ¾Ğµ Ğ¿Ğ¾Ğ»Ğµ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ?"
    MERCH_EDIT_FIELD_PROMPTS = {
        "name": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ:",
        "description": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:",
        "price": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ñ†ĞµĞ½Ñƒ Ğ² Ğ±Ğ°Ğ»Ğ»Ğ°Ñ…:"
    }
    MERCH_EDIT_NEW_VALUE_PROMPT = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ:"
    MERCH_EDIT_SUCCESS = "âœ… ĞŸĞ¾Ğ»Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾!"
    MERCH_TOGGLE_AVAILABILITY = "Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½ Ğ½Ğ°: {status}."
    MERCH_DELETE_CONFIRMATION = "ğŸ—‘ï¸ <b>ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ</b>\n\nĞ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ <b>Ğ±ĞµĞ·Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ½Ğ¾</b> ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Â«<b>{name}</b>Â»?"
    MERCH_DELETE_SUCCESS = "âœ… Ğ¢Ğ¾Ğ²Ğ°Ñ€ Â«<b>{name}</b>Â» Ğ±Ñ‹Ğ» ÑƒĞ´Ğ°Ğ»ĞµĞ½."
    MERCH_ITEM_ALREADY_DELETED = "Ğ¢Ğ¾Ğ²Ğ°Ñ€ ÑƒĞ¶Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½."
    ADMIN_NO_PENDING_ORDERS = "ĞĞ¾Ğ²Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ğ½ĞµÑ‚."
    ADMIN_PENDING_ORDERS_HEADER = "ğŸ“¦ <b>ĞĞ¾Ğ²Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹ Ğ½Ğ° Ğ²Ñ‹Ğ´Ğ°Ñ‡Ñƒ:</b>\n\n"
    ADMIN_ORDER_ITEM_TEXT = (
        "ğŸ”¹ <b>Ğ—Ğ°ĞºĞ°Ğ· â„–{order_id}</b> Ğ¾Ñ‚ {date}\n"
        "   Ğ¢Ğ¾Ğ²Ğ°Ñ€: Â«{item_name}Â»\n"
        "   Ğ—Ğ°ĞºĞ°Ğ·Ğ°Ğ»: {user_link} (@{username})\n"
        "   Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {phone}"
    )
    ADMIN_ORDER_ITEM_TEXT_NO_USERNAME = (
        "ğŸ”¹ <b>Ğ—Ğ°ĞºĞ°Ğ· â„–{order_id}</b> Ğ¾Ñ‚ {date}\n"
        "   Ğ¢Ğ¾Ğ²Ğ°Ñ€: Â«{item_name}Â»\n"
        "   Ğ—Ğ°ĞºĞ°Ğ·Ğ°Ğ»: {user_link}\n"
        "   Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {phone}"
    )
    ADMIN_COMPLETE_ORDER_ADMIN_ID_ERROR = "ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°."
    ADMIN_ORDER_NOT_FOUND_OR_PROCESSED = "Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ¸Ğ»Ğ¸ ÑƒĞ¶Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½."
    ADMIN_ORDER_COMPLETED_SUCCESS = "âœ… Ğ—Ğ°ĞºĞ°Ğ· â„–{order_id} Ğ¿Ğ¾Ğ¼ĞµÑ‡ĞµĞ½ ĞºĞ°Ğº Ğ²Ñ‹Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¹."
    USER_ORDER_COMPLETED_NOTIFICATION = "ğŸ‰ Ğ’Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· Â«{item_name}Â» Ğ±Ñ‹Ğ» Ğ²Ñ‹Ğ´Ğ°Ğ½. ĞŸÑ€Ğ¸ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ!"
    EXPORT_STARTED = "â³ ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ ÑĞ±Ğ¾Ñ€ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ°Ñ€Ñ…Ğ¸Ğ²Ğ°... Ğ­Ñ‚Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ·Ğ°Ğ½ÑÑ‚ÑŒ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ."
    EXPORT_SUCCESSFUL = "âœ… ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ±ÑĞºĞ°Ğ¿ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ³Ğ¾Ñ‚Ğ¾Ğ²."
    EXPORT_FAILED = "âŒ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ğ±ÑĞºĞ°Ğ¿Ğ°. ĞŸĞ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ² Ğ»Ğ¾Ğ³Ğ°Ñ…."
    ADMIN_USERS_HEADER = "ğŸ‘¥ <b>Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸</b>"
    ADMIN_NO_USERS_IN_DB = "Ğ’ Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹."
    USERS_LIST_HEADER = "ğŸ“œ <b>Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ (Ğ¡Ñ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ° {page}/{total_pages})</b>\n\n"
    USER_SEARCH_PROMPT = "ğŸ” Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° (Ğ¤Ğ˜Ğ, username, ID, Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½):"
    USER_SEARCH_NO_RESULTS = "ğŸ¤·â€â™‚ï¸ ĞŸĞ¾ Ğ²Ğ°ÑˆĞµĞ¼Ñƒ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑƒ Ğ½Ğ¸ĞºĞ¾Ğ³Ğ¾ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾."
    USER_SEARCH_RESULTS_HEADER = "ğŸ” <b>Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ¾ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑƒ Â«{query}Â»:</b>\n\n"
    USER_CARD_HEADER = "ğŸ‘¤ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ: {full_name}"
    USER_CARD_TEMPLATE = (
        "  <b>Ğ¤Ğ˜Ğ:</b> {full_name}\n"
        "  <b>ID:</b> <code>{telegram_id}</code>\n"
        "  <b>Username:</b> @{username}\n"
        "  <b>Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½:</b> <code>{phone_number}</code>\n"
        "  <b>Ğ Ğ¾Ğ»ÑŒ:</b> <code>{role}</code>\n"
        "  <b>Ğ‘Ğ°Ğ»Ğ»Ñ‹:</b> <b>{points}</b>\n"
        "  <b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:</b> <b>{block_status}</b>"
    )
    USER_NOT_FOUND = "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½."
    CHANGE_POINTS_PROMPT = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑÑƒĞ¼Ğ¼Ñƒ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ² Ğ´Ğ»Ñ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ñ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, 50) Ğ¸Ğ»Ğ¸ ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ (-50):"
    CHANGE_POINTS_REASON_PROMPT = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ñ/ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ:"
    CHANGE_POINTS_SUCCESS = "âœ… Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {name} Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½. ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ: {balance}"
    USER_POINTS_CHANGED_NOTIFICATION = "âš™ï¸ ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ» Ğ²Ğ°Ñˆ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ½Ğ° {points} Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ².\n<b>ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°:</b> {reason}\n<b>Ğ’Ğ°Ñˆ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ:</b> {balance}"
    USER_PROMOTED_VOLUNTEER = "âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {name} Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ¾Ğ¼."
    USER_PROMOTED_VOLUNTEER_NOTIFY = "â­ ĞŸĞ¾Ğ·Ğ´Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼! ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡Ğ¸Ğ» Ğ²Ğ°Ñ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ¾Ğ¼. Ğ’Ğ°Ğ¼ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ Ğ¼ĞµĞ½Ñ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°."
    USER_DEMOTED_VOLUNTEER = "âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {name} ÑĞ½ÑÑ‚ Ñ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°."
    USER_DEMOTED_VOLUNTEER_NOTIFY = "âš™ï¸ Ğ’Ğ°ÑˆĞ° Ñ€Ğ¾Ğ»ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ° Ğ½Ğ° 'ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚'. ĞœĞµĞ½Ñ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ° Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾."
    USER_PROMOTED_ADMIN = "âœ… {name} Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ¼."
    USER_PROMOTED_ADMIN_NOTIFY = "ĞŸĞ¾Ğ·Ğ´Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼! Ğ’Ğ°Ñ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡Ğ¸Ğ»Ğ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ¼ Ğ±Ğ¾Ñ‚Ğ°."
    USER_DEMOTED_ADMIN = "âœ… {name} Ñ€Ğ°Ğ·Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ğ½ Ğ´Ğ¾ ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚Ğ°."
    USER_DEMOTED_ADMIN_NOTIFY = "Ğ’Ğ°ÑˆĞ° Ñ€Ğ¾Ğ»ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ° Ğ½Ğ° 'ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚'."
    BLOCK_USER_REASON_PROMPT = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸:"
    ADMIN_ID_ERROR = "ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ğ°Ñ."
    BLOCK_TARGET_USER_NOT_FOUND = "ĞÑˆĞ¸Ğ±ĞºĞ°: Ñ†ĞµĞ»ĞµĞ²Ğ¾Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½."
    USER_BLOCKED_SUCCESS = "âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {name} Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½. ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: {reason}"
    USER_BLOCKED_NOTIFY = "Ğ’Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ±Ñ‹Ğ» Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½.\nĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: {reason}"
    USER_UNBLOCKED_SUCCESS = "âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {name} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½."
    USER_UNBLOCKED_NOTIFY = "ğŸ‰ Ğ’Ğ°Ñˆ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚ Ğ±Ñ‹Ğ» Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½. Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹ ÑĞ½Ğ¾Ğ²Ğ° Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ±Ğ¾Ñ‚Ğ¾Ğ¼."
    MANAGE_USER_REGS_HEADER = "ğŸŸï¸ Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸ Ğ´Ğ»Ñ: <b>{name}</b>\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:"
    MANUAL_REG_CHOOSE_EVENT = "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ, Ğ½Ğ° ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ:"
    MANUAL_REG_NO_EVENTS = "ĞĞµÑ‚ Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ¾ÑÑ‰Ğ¸Ñ… Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸."
    MANUAL_REG_SUCCESS_NOTIFY = "âš™ï¸ ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ» Ğ²Ğ°Ñ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Â«<b>{event_name}</b>Â» Ğ½Ğ° {datetime}."
    NOTIFY_USER_FAILED = "âš ï¸ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {name}."
    MANUAL_CANCEL_CHOOSE_REG = "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€ÑƒÑ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ:"
    MANUAL_CANCEL_NO_REGS = "Ğ£ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¹ Ğ½Ğ° Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ."
    MANUAL_CANCEL_SUCCESS = "Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {name} Ğ½Ğ° {event_name} Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°."
    MANUAL_CANCEL_SUCCESS_NOTIFY = "âš™ï¸ ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» Ğ²Ğ°ÑˆÑƒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Â«<b>{event_name}</b>Â»."
    MANUAL_CANCEL_FAIL = "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ (Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾, ÑƒĞ¶Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°)."
    MANAGE_WAIVERS_HEADER = "âš•ï¸ Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°Ğ¼Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ <b>{name}</b>.\n\n"
    MANAGE_WAIVERS_NO_WAIVERS = "ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ² Ğ½ĞµÑ‚. Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹."
    MANAGE_WAIVERS_WITH_WAIVERS = "ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Ğ½Ğ° Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ, Ğ¸Ğ»Ğ¸ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹:"
    MANUAL_WAIVER_DATE_PROMPT = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ñ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ° Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“:"
    MANUAL_WAIVER_REASON_PROMPT = "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°:"
    MANUAL_WAIVER_SUCCESS = "âœ… ĞœĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ´Ğ»Ñ {name} ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ´Ğ¾ {date}."
    MANUAL_WAIVER_NOTIFY = "âš•ï¸ ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ğ» Ğ²Ğ°Ğ¼ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ´Ğ¾ {date}.\n<b>ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°:</b> {reason}"
    ADMIN_DELETE_WAIVER_DATA_ERROR = "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°."
    ADMIN_DELETE_WAIVER_SUCCESS = "âœ… ĞœĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»ĞµĞ½."
    ADMIN_DELETE_WAIVER_FAIL = "âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ñ‚."
    ADMIN_DELETE_WAIVER_NOTIFY = "âš™ï¸ ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» Ğ¾Ğ´Ğ¸Ğ½ Ğ¸Ğ· Ğ²Ğ°ÑˆĞ¸Ñ… Ğ¼ĞµĞ´Ğ¸Ñ†Ğ¸Ğ½ÑĞºĞ¸Ñ… Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ²."
    WAIVER_EXPIRED_NOTIFICATION = "ğŸ‰ ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚Ğ¸! Ğ¡Ñ€Ğ¾Ğº Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ¼ĞµĞ´Ğ¸Ñ†Ğ¸Ğ½ÑĞºĞ¾Ğ³Ğ¾ Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ° Ğ¸ÑÑ‚ĞµĞº. Ğ’Ñ‹ ÑĞ½Ğ¾Ğ²Ğ° Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑĞ¿Ğ°ÑĞ°Ñ‚ÑŒ Ğ¶Ğ¸Ğ·Ğ½Ğ¸, ÑƒÑ‡Ğ°ÑÑ‚Ğ²ÑƒÑ Ğ² Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ÑÑ…! ğŸ’ª"
    REMINDER_WEEK = (
        "ğŸ‘‹ <b>ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ñ‡ĞµÑ€ĞµĞ· Ğ½ĞµĞ´ĞµĞ»Ñ!</b> \n\n"
        "Ğ’Ñ‹ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Â«<b>{event_name}</b>Â», ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾Ğ¸Ñ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· Ğ½ĞµĞ´ĞµĞ»Ñ - <b>{event_datetime}</b>.\n\n"
        "ğŸ“ <b>ĞœĞµÑÑ‚Ğ¾:</b> {event_location}\n\n"
        "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ½Ğ°Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ·Ğ°Ñ€Ğ°Ğ½ĞµĞµ Ğ¸ ÑĞ»ĞµĞ´Ğ¸Ñ‚Ğµ Ğ·Ğ° ÑĞ²Ğ¾Ğ¸Ğ¼ ÑĞ°Ğ¼Ğ¾Ñ‡ÑƒĞ²ÑÑ‚Ğ²Ğ¸ĞµĞ¼. Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾!"
    )
    REMINDER_3_DAYS = (
        "ğŸ‘‹ <b>ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸!</b> \n\n"
        "Ğ’Ñ‹ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Â«<b>{event_name}</b>Â», ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾Ğ¸Ñ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· 3 Ğ´Ğ½Ñ - <b>{event_datetime}</b>.\n\n"
        "ğŸ“ <b>ĞœĞµÑÑ‚Ğ¾:</b> {event_location}\n\n"
        "ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°ĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ·Ğ° 48 Ñ‡Ğ°ÑĞ¾Ğ² Ğ´Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ Ğ»ĞµĞºĞ°Ñ€ÑÑ‚Ğ²Ğ°, ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‰Ğ¸Ğµ Ğ°ÑĞ¿Ğ¸Ñ€Ğ¸Ğ½ Ğ¸ Ğ°Ğ½Ğ°Ğ»ÑŒĞ³ĞµÑ‚Ğ¸ĞºĞ¸."
    )
    REMINDER_2_DAYS = (
        "ğŸ‘‹ <b>ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸!</b> \n\n"
        "Ğ’Ñ‹ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Â«<b>{event_name}</b>Â», ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾Ğ¸Ñ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· 2 Ğ´Ğ½Ñ - <b>{event_datetime}</b>.\n\n"
        "ğŸ“ <b>ĞœĞµÑÑ‚Ğ¾:</b> {event_location}\n\n"
        "ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°ĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ·Ğ° 48 Ñ‡Ğ°ÑĞ¾Ğ² Ğ´Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ Ğ»ĞµĞºĞ°Ñ€ÑÑ‚Ğ²Ğ°, ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‰Ğ¸Ğµ Ğ°ÑĞ¿Ğ¸Ñ€Ğ¸Ğ½ Ğ¸ Ğ°Ğ½Ğ°Ğ»ÑŒĞ³ĞµÑ‚Ğ¸ĞºĞ¸."
    )
    REMINDER_1_DAY = (
        "ğŸ‘‹ <b>ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸!</b> \n\n"
        "Ğ’Ñ‹ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Â«<b>{event_name}</b>Â», ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾Ğ¸Ñ‚ÑÑ Ğ·Ğ°Ğ²Ñ‚Ñ€Ğ°, <b>{event_datetime}</b>.\n\n"
        "ğŸ“ <b>ĞœĞµÑÑ‚Ğ¾:</b> {event_location}\n\n"
        "ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°ĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ·Ğ° 24 Ñ‡Ğ°ÑĞ° Ğ´Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ½ĞµĞ»ÑŒĞ·Ñ ÑƒĞ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ»ÑÑ‚ÑŒ Ğ‘ĞĞ”Ñ‹. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ½Ğµ Ğ·Ğ°Ğ±ÑƒĞ´ÑŒÑ‚Ğµ Ğ¿Ğ°ÑĞ¿Ğ¾Ñ€Ñ‚ Ğ¸ Ñ…Ğ¾Ñ€Ğ¾ÑˆĞ¾ Ğ²Ñ‹ÑĞ¿Ğ¸Ñ‚ĞµÑÑŒ. Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°ĞµÑ‚Ğµ!"
    )
    REMINDER_2_HOURS = (
        "â—ï¸<b>Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ ÑƒĞ¶Ğµ ÑĞºĞ¾Ñ€Ğ¾!</b> \n\n"
        "ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°ĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ²Ñ‹ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Â«<b>{event_name}</b>Â», ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ½Ğ°Ñ‡Ğ½ĞµÑ‚ÑÑ ÑƒĞ¶Ğµ Ñ‡ĞµÑ€ĞµĞ· 2 Ñ‡Ğ°ÑĞ°, Ğ² <b>{event_datetime}</b>.\n\n"
        "Ğ–Ğ´ĞµĞ¼ Ğ²Ğ°Ñ Ğ¿Ğ¾ Ğ°Ğ´Ñ€ĞµÑÑƒ: {event_location}"
    )
    POST_DONATION_FEEDBACK = "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! ĞšĞ°Ğº Ñ‚Ñ‹ ÑĞµĞ±Ñ Ñ‡ÑƒĞ²ÑÑ‚Ğ²ÑƒĞµÑˆÑŒ?\n\nĞÑ†ĞµĞ½Ğ¸, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ 1/5"
    FEEDBACK_START = "ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ñ‚Ğ²Ğ¾Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ²Ñ‡ĞµÑ€Ğ°. ĞœÑ‹ Ğ±Ñ‹Ğ»Ğ¸ Ğ±Ñ‹ Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹, ĞµÑĞ»Ğ¸ Ğ±Ñ‹ Ñ‚Ñ‹ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¸Ğ»(Ğ°) Ğ½Ğ° Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ². Ğ­Ñ‚Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ½Ğ°Ğ¼ ÑÑ‚Ğ°Ñ‚ÑŒ Ğ»ÑƒÑ‡ÑˆĞµ!\n\nĞ”Ğ»Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ°, ĞºĞ°Ğº Ñ‚Ñ‹ ÑĞµĞ±Ñ Ñ‡ÑƒĞ²ÑÑ‚Ğ²ÑƒĞµÑˆÑŒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸? ĞÑ†ĞµĞ½Ğ¸ Ğ¿Ğ¾ ÑˆĞºĞ°Ğ»Ğµ Ğ¾Ñ‚ 1 (Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ¿Ğ»Ğ¾Ñ…Ğ¾) Ğ´Ğ¾ 5 (Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾)."
    FEEDBACK_WELL_BEING_BAD = "ĞĞ°Ğ¼ Ğ¶Ğ°Ğ»ÑŒ ÑÑ‚Ğ¾ ÑĞ»Ñ‹ÑˆĞ°Ñ‚ÑŒ. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸, Ñ‡Ñ‚Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ Ğ½Ğµ Ñ‚Ğ°Ğº? (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, 'ĞºÑ€ÑƒĞ¶Ğ¸Ñ‚ÑÑ Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ°', 'ÑĞ»Ğ°Ğ±Ğ¾ÑÑ‚ÑŒ'). Ğ•ÑĞ»Ğ¸ Ñ‚ĞµĞ±Ğµ Ğ½ÑƒĞ¶Ğ½Ğ° Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒ, Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ ÑĞ²ÑĞ¶Ğ¸ÑÑŒ Ñ Ğ½Ğ°Ğ¼Ğ¸!"
    FEEDBACK_GET_ORGANIZATION_SCORE = "ĞŸĞ¾Ğ½ÑÑ‚Ğ½Ğ¾, ÑĞ¿Ğ°ÑĞ¸Ğ±Ğ¾! Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ñ†ĞµĞ½Ğ¸, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ°Ğ¼Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ¿Ğ¾ ÑˆĞºĞ°Ğ»Ğµ Ğ¾Ñ‚ 1 (Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ¿Ğ»Ğ¾Ñ…Ğ¾) Ğ´Ğ¾ 10 (Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾)."
    FEEDBACK_GET_WHAT_LIKED = "ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ Ğ°ÑÑĞºĞ°Ğ¶Ğ¸, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ñ‡Ñ‚Ğ¾ Ñ‚ĞµĞ±Ğµ Ğ¿Ğ¾Ğ½Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ÑÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ²ÑĞµĞ³Ğ¾?"
    FEEDBACK_GET_WHAT_DISLIKED = "Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾! Ğ Ñ‡Ñ‚Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ Ğ±Ñ‹ ÑƒĞ»ÑƒÑ‡ÑˆĞ¸Ñ‚ÑŒ? Ğ§Ñ‚Ğ¾ Ğ½Ğµ Ğ¿Ğ¾Ğ½Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ÑÑŒ?"
    FEEDBACK_GET_OTHER_SUGGESTIONS = "ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¾. Ğ˜ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ: ĞµÑÑ‚ÑŒ Ğ»Ğ¸ Ñƒ Ñ‚ĞµĞ±Ñ ĞºĞ°ĞºĞ¸Ğµ-Ğ»Ğ¸Ğ±Ğ¾ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¸Ğ´ĞµĞ¸ Ğ¸Ğ»Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ?"
    FEEDBACK_FINISH = "ğŸ‰ ĞĞ¿Ñ€Ğ¾Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½! ĞĞ³Ñ€Ğ¾Ğ¼Ğ½Ğ¾Ğµ ÑĞ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ñ‚Ğ²Ğ¾Ñ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½ÑƒÑ ÑĞ²ÑĞ·ÑŒ. ĞĞ½Ğ° Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ²Ğ°Ğ¶Ğ½Ğ° Ğ´Ğ»Ñ Ğ½Ğ°Ñ!"
    FEEDBACK_ADMIN_HEADER = "ğŸ“Š <b>ĞÑ‚Ğ·Ñ‹Ğ²Ñ‹ Ğ¿Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Â«{event_name}Â»</b>\n\n"
    FEEDBACK_ADMIN_NO_FEEDBACK = "ĞŸĞ¾ ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ¾Ğ²."
    FEEDBACK_ADMIN_ITEM = (
        "--- ĞÑ‚Ğ·Ñ‹Ğ² Ğ¾Ñ‚ {user_name} ---\n"
        "<b>Ğ¡Ğ°Ğ¼Ğ¾Ñ‡ÑƒĞ²ÑÑ‚Ğ²Ğ¸Ğµ:</b> {wb_score}/5\n"
        "<i>ĞšĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¹:</i> {wb_comment}\n"
        "<b>ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ:</b> {org_score}/10\n"
        "<b>ğŸ‘ ĞŸĞ¾Ğ½Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ÑÑŒ:</b> {liked}\n"
        "<b>ğŸ‘ ĞĞµ Ğ¿Ğ¾Ğ½Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ÑÑŒ:</b> {disliked}\n"
        "<b>ğŸ’¬ ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:</b> {suggestions}\n\n"
    )

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: bot/utils/text_messages.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: donor_bot_telegram.egg-info/SOURCES.txt ---

README.md
pyproject.toml
bot/__init__.py
bot/config_reader.py
bot/db/__init__.py
bot/db/admin_requests.py
bot/db/analytics_requests.py
bot/db/engine.py
bot/db/event_requests.py
bot/db/info_requests.py
bot/db/merch_requests.py
bot/db/models.py
bot/db/qa_management.py
bot/db/question_requests.py
bot/db/user_requests.py
bot/filters/role.py
bot/handlers/__init__.py
bot/handlers/common.py
bot/handlers/main_admin.py
bot/handlers/other.py
bot/handlers/student.py
bot/handlers/volunteer.py
bot/handlers/admin/__init__.py
bot/handlers/admin/analytics.py
bot/handlers/admin/event_management.py
bot/handlers/admin/info_management.py
bot/handlers/admin/mailing.py
bot/handlers/admin/merch_management.py
bot/handlers/admin/qa_management.py
bot/handlers/admin/system.py
bot/handlers/admin/user_management.py
bot/keyboards/__init__.py
bot/keyboards/inline.py
bot/keyboards/reply.py
bot/middlewares/__init__.py
bot/middlewares/block.py
bot/middlewares/db.py
bot/states/__init__.py
bot/states/states.py
bot/utils/__init__.py
bot/utils/analytics_service.py
bot/utils/calendar_service.py
bot/utils/graduation.py
bot/utils/qr_service.py
bot/utils/scheduler.py
bot/utils/text_messages.py
donor_bot_telegram.egg-info/PKG-INFO
donor_bot_telegram.egg-info/SOURCES.txt
donor_bot_telegram.egg-info/dependency_links.txt
donor_bot_telegram.egg-info/top_level.txt
tests/test_admin_fsm.py
tests/test_analytics.py
tests/test_calendar_service.py
tests/test_db_requests.py
tests/test_filters.py
tests/test_graduation.py
tests/test_handlers_logic.py
tests/test_keyboards.py
tests/test_mailing_logic.py
tests/test_middlewares.py
tests/test_registration_logic.py
tests/test_scheduler_logic.py
tests/test_security.py
tests/test_survey_logic.py
tests/test_utils.py
tests/test_volunteer_fsm.py

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: donor_bot_telegram.egg-info/SOURCES.txt ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: donor_bot_telegram.egg-info/dependency_links.txt ---



--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: donor_bot_telegram.egg-info/dependency_links.txt ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: donor_bot_telegram.egg-info/top_level.txt ---

bot

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: donor_bot_telegram.egg-info/top_level.txt ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/__init__.py ---



--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/__init__.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/conftest.py ---

# tests/conftest.py

import pytest
import sys
from pathlib import Path
from typing import AsyncGenerator

from sqlalchemy.ext.asyncio import (
    create_async_engine,
    async_sessionmaker,
    AsyncSession,
    AsyncEngine,
)

# --- ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿ÑƒÑ‚ĞµĞ¹ ---
# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ¾Ñ€Ğ½ĞµĞ²ÑƒÑ Ğ¿Ğ°Ğ¿ĞºÑƒ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° Ğ² sys.path, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ pytest Ğ¼Ğ¾Ğ³ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸ Ğ±Ğ¾Ñ‚Ğ°.
# Ğ­Ñ‚Ğ¾ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ°Ñ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ° Ğ´Ğ»Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ¹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ² Ğ² Ñ‚ĞµÑÑ‚Ğ°Ñ….
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from bot.db.models import Base

# --- ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ¹ Ğ‘Ğ” ---

# URL Ğ´Ğ»Ñ Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ¾Ğ¹ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… SQLite Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸.
# Ğ­Ñ‚Ğ¾ Ğ¸Ğ´ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ñ… Ğ¸ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ¸Ğ·Ğ¾Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ²,
# Ñ‚Ğ°Ğº ĞºĞ°Ğº Ğ±Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ÑÑ Ğ² Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ¾Ğ¹ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¸ Ğ¸ÑÑ‡ĞµĞ·Ğ°ĞµÑ‚ Ğ¿Ğ¾ÑĞ»Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ².
TEST_DATABASE_URL = "sqlite+aiosqlite:///:memory:"

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ´Ğ²Ğ¸Ğ¶Ğ¾Ğº Ğ‘Ğ”. ĞĞ½ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¶Ğ¸Ñ‚ÑŒ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµĞ¹ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ¹ ÑĞµÑÑĞ¸Ğ¸.
test_engine: AsyncEngine = create_async_engine(TEST_DATABASE_URL, echo=False)

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ„Ğ°Ğ±Ñ€Ğ¸ĞºÑƒ ÑĞµÑÑĞ¸Ğ¹ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ².
# ĞĞ½Ğ° Ğ±ÑƒĞ´ĞµÑ‚ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ½Ğ¾Ğ²Ñ‹Ñ… ÑĞµÑÑĞ¸Ğ¹ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ñ‚ĞµÑÑ‚Ğ°.
TestSessionMaker = async_sessionmaker(
    bind=test_engine, class_=AsyncSession, expire_on_commit=False
)


@pytest.fixture(scope="session", autouse=True)
async def setup_database() -> AsyncGenerator[None, None]:
    """
    Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° ÑƒÑ€Ğ¾Ğ²Ğ½Ñ ÑĞµÑÑĞ¸Ğ¸ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ¸ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….

    `scope="session"`: ĞºĞ¾Ğ´ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ Ğ¾Ğ´Ğ¸Ğ½ Ñ€Ğ°Ğ· Ğ¿ĞµÑ€ĞµĞ´ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ¾Ğ¼ Ğ²ÑĞµÑ… Ñ‚ĞµÑÑ‚Ğ¾Ğ².
    `autouse=True`: Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸, ĞµĞµ Ğ½Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ² Ñ‚ĞµÑÑ‚Ğ°Ñ….

    Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ:
    1. ĞŸĞµÑ€ĞµĞ´ Ñ‚ĞµÑÑ‚Ğ°Ğ¼Ğ¸: ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ²ÑĞµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ Ğ¼Ğ¾Ğ´ĞµĞ»ĞµĞ¹ SQLAlchemy.
    2. ĞŸĞ¾ÑĞ»Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²: ÑƒĞ´Ğ°Ğ»ÑĞµÑ‚ Ğ²ÑĞµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹, Ğ¾Ñ‡Ğ¸Ñ‰Ğ°Ñ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ğµ.
    """
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    yield  # Ğ’ ÑÑ‚Ğ¾Ñ‚ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑÑ‚ÑÑ Ğ²ÑĞµ Ñ‚ĞµÑÑ‚Ñ‹

    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)


@pytest.fixture(scope="function")
async def session(setup_database: None) -> AsyncGenerator[AsyncSession, None]:
    """
    ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ ÑĞµÑÑĞ¸Ğ¸ Ğ² ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞµĞ¹Ñ.

    `scope="function"`: ĞºĞ¾Ğ´ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ¹ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸.
    `setup_database`: Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ñ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ°Ñ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ ÑƒĞ¶Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹.

    ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¾Ğ»ÑÑ†Ğ¸Ğ¸ Ñ‚ĞµÑÑ‚Ğ¾Ğ²:
    1. Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ñ Ğ‘Ğ”.
    2. ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµÑ‚ÑÑ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ñ.
    3. Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ÑÑ ÑĞµÑÑĞ¸Ñ, Ğ¿Ñ€Ğ¸Ğ²ÑĞ·Ğ°Ğ½Ğ½Ğ°Ñ Ğº ÑÑ‚Ğ¾Ğ¹ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸.
    4. Ğ¡ĞµÑÑĞ¸Ñ Ğ¿ĞµÑ€ĞµĞ´Ğ°ĞµÑ‚ÑÑ Ğ² Ñ‚ĞµÑÑ‚ (`yield session`).
    5. Ğ¢ĞµÑÑ‚ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ ÑĞ²Ğ¾Ğ¸ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ‘Ğ” (Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ, Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…).
    6. ĞŸĞ¾ÑĞ»Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ° Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ñ Ğ¾Ñ‚ĞºĞ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ (`rollback`), Ğ¾Ñ‚Ğ¼ĞµĞ½ÑÑ Ğ²ÑĞµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ,
       ÑĞ´ĞµĞ»Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ² Ñ‚ĞµÑÑ‚Ğµ.
    7. Ğ¡Ğ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ.

    Ğ¢Ğ°ĞºĞ¸Ğ¼ Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ¼, ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ñ‚ĞµÑÑ‚ Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµÑ‚ÑÑ Ñ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾ Ñ‡Ğ¸ÑÑ‚Ğ¾Ğ¹ Ğ‘Ğ”.
    """
    connection = await test_engine.connect()
    transaction = await connection.begin()

    try:
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞµÑÑĞ¸Ñ, Ğ¿Ñ€Ğ¸Ğ²ÑĞ·Ğ°Ğ½Ğ½ÑƒÑ Ğº Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸
        session_for_test = TestSessionMaker(bind=connection)
        yield session_for_test
    finally:
        # ĞÑ‚ĞºĞ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ñ Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ² Ğ»ÑĞ±Ğ¾Ğ¼ ÑĞ»ÑƒÑ‡Ğ°Ğµ
        await transaction.rollback()
        await connection.close()
        
@pytest.fixture(scope="session")
def session_pool() -> async_sessionmaker:
    """
    Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ°, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ°Ñ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ Ñ„Ğ°Ğ±Ñ€Ğ¸ĞºÑƒ ÑĞµÑÑĞ¸Ğ¹ (session maker).
    ĞĞ½Ğ° Ğ½ÑƒĞ¶Ğ½Ğ° Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ÑĞ°Ğ¼Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑÑÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸ĞµĞ¼ ÑĞµÑÑĞ¸Ğ¹,
    Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ´Ğ»Ñ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ°.
    """
    return TestSessionMaker

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/conftest.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_admin_fsm.py ---

import pytest
import datetime
from unittest.mock import AsyncMock, Mock

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from aiogram import Bot

from bot.handlers.admin import merch_management as merch_handlers
from bot.handlers.admin import user_management as user_handlers
from bot.handlers.admin import event_management as event_handlers
from bot.handlers.admin import mailing as mailing_handlers
from bot.states.states import MerchCreation, BlockUser, ManualWaiver, EventEditing, UserSearch, Mailing, AdminAddUser, EditInfoSection, PostEventProcessing

from bot.db.models import MerchItem, User, UserBlock, MedicalWaiver, Event, InfoText, Donation, EventRegistration
from bot.handlers.admin import info_management as info_handlers


pytestmark = pytest.mark.asyncio

class MockMessage:
    def __init__(self, text=None, from_user_id=1, photo=None):
        self.text = text
        self.from_user = Mock(id=from_user_id)
        self.photo = [Mock(file_id="photo_file_id_123")] if photo else None
        self.html_text = text
        self.answer = AsyncMock()
        self.delete = AsyncMock()

class MockCallbackQuery:
    def __init__(self, data, from_user_id=1, message=None):
        self.data = data
        self.from_user = Mock(id=from_user_id)
        if not message:
            self.message = MockMessage(from_user_id=from_user_id)
        else:
            self.message = message
        for method_name in ['edit_text', 'delete', 'answer']:
            if not hasattr(self.message, method_name):
                setattr(self.message, method_name, AsyncMock())
        self.answer = AsyncMock()

class MockFSMContext:
    def __init__(self):
        self._state = None
        self._data = {}
    async def get_state(self): return self._state
    async def set_state(self, state): self._state = state
    async def get_data(self): return self._data.copy()
    async def update_data(self, **kwargs): self._data.update(kwargs)
    async def clear(self):
        self._state = None
        self._data = {}

async def test_merch_creation_fsm_full_path(session: AsyncSession):
    admin_user_id = 1001
    state = MockFSMContext()
    callback_start = MockCallbackQuery(data="admin_create_merch", from_user_id=admin_user_id)
    await merch_handlers.start_merch_creation(callback_start, state)
    assert await state.get_state() == MerchCreation.awaiting_photo
    msg_photo = MockMessage(from_user_id=admin_user_id, photo=True)
    await merch_handlers.process_merch_photo(msg_photo, state)
    assert await state.get_state() == MerchCreation.awaiting_name
    msg_name = MockMessage(text="ĞšÑ€ÑƒÑ‚Ğ°Ñ ĞºÑ€ÑƒĞ¶ĞºĞ°", from_user_id=admin_user_id)
    await merch_handlers.process_merch_name(msg_name, state)
    assert await state.get_state() == MerchCreation.awaiting_description
    msg_desc = MockMessage(text="ĞÑ‡ĞµĞ½ÑŒ ĞºÑ€ÑƒÑ‚Ğ°Ñ ĞºÑ€ÑƒĞ¶ĞºĞ° Ğ´Ğ»Ñ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²", from_user_id=admin_user_id)
    await merch_handlers.process_merch_description(msg_desc, state)
    assert await state.get_state() == MerchCreation.awaiting_price
    msg_price = MockMessage(text="150", from_user_id=admin_user_id)
    await merch_handlers.process_merch_price(msg_price, state, session)
    assert await state.get_state() is None
    created_item = (await session.execute(select(MerchItem))).scalar_one_or_none()
    assert created_item is not None
    assert created_item.name == "ĞšÑ€ÑƒÑ‚Ğ°Ñ ĞºÑ€ÑƒĞ¶ĞºĞ°"

async def test_block_user_fsm_full_path(session: AsyncSession, mocker):
    mock_bot = Mock(spec=Bot)
    mock_bot.send_message = AsyncMock()
    main_admin = User(phone_number="+1", telegram_id=1001, full_name="Main Admin", university="Test")
    target_user = User(phone_number="+2", telegram_id=2002, full_name="Target User", university="Test")
    session.add_all([main_admin, target_user])
    await session.commit()
    state = MockFSMContext()
    callback_start = MockCallbackQuery(data=f"ma_block_user_{target_user.id}", from_user_id=main_admin.telegram_id)
    await user_handlers.block_user_from_card(callback_start, state)
    assert await state.get_state() == BlockUser.awaiting_reason
    msg_reason = MockMessage(text="ĞĞ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»", from_user_id=main_admin.telegram_id)
    await user_handlers.process_block_reason(msg_reason, state, session, mock_bot)
    assert await state.get_state() is None
    await session.refresh(target_user)
    assert target_user.is_blocked is True
    mock_bot.send_message.assert_called_once()

async def test_manual_waiver_fsm_full_path(session: AsyncSession, mocker):
    mock_bot = Mock(spec=Bot)
    mock_bot.send_message = AsyncMock()
    admin = User(phone_number="+1", telegram_id=1001, full_name="Admin", university="Test")
    target_user = User(phone_number="+2", telegram_id=2002, full_name="Target User", university="Test")
    session.add_all([admin, target_user])
    await session.commit()
    state = MockFSMContext()
    callback_start = MockCallbackQuery(data=f"admin_waiver_{target_user.id}", from_user_id=admin.telegram_id)
    await user_handlers.set_waiver_start(callback_start, state)
    assert await state.get_state() == ManualWaiver.awaiting_end_date
    msg_date = MockMessage(text="01.01.2099", from_user_id=admin.telegram_id)
    await user_handlers.set_waiver_date(msg_date, state)
    assert await state.get_state() == ManualWaiver.awaiting_reason
    msg_reason = MockMessage(text="ĞœĞµĞ´Ğ¸Ñ†Ğ¸Ğ½ÑĞºĞ¸Ğµ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ", from_user_id=admin.telegram_id)
    await user_handlers.set_waiver_reason(msg_reason, state, session, mock_bot)
    assert await state.get_state() is None
    waiver_record = (await session.execute(select(MedicalWaiver))).scalar_one_or_none()
    assert waiver_record is not None
    mock_bot.send_message.assert_called_once()

async def test_user_search_fsm_full_path(session: AsyncSession):
    admin_id = 1001
    user_to_find = User(phone_number="+7123", telegram_id=123, full_name="Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ² Ğ˜Ğ²Ğ°Ğ½", university="Test")
    session.add(user_to_find)
    await session.commit()
    state = MockFSMContext()
    callback = MockCallbackQuery(data="admin_search_user", from_user_id=admin_id)
    await user_handlers.search_user_start(callback, state)
    assert await state.get_state() == UserSearch.awaiting_query
    message = MockMessage(text="Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ²", from_user_id=admin_id)
    await user_handlers.process_user_search(message, state, session)
    assert await state.get_state() is None
    message.answer.assert_called_once()
    args, kwargs = message.answer.call_args
    assert "Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ¿Ğ¾Ğ¸ÑĞºĞ°" in args[0]
    assert "Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ² Ğ˜Ğ²Ğ°Ğ½" in str(kwargs['reply_markup'])

async def test_event_editing_fsm_full_path(session: AsyncSession, mocker):
    admin_id = 1001
    event = Event(name="Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ", event_datetime=datetime.datetime.now(), location="Test", donation_type="d", points_per_donation=1, participant_limit=1)
    session.add(event)
    await session.commit()
    state = MockFSMContext()
    callback_start = MockCallbackQuery(data=f"admin_edit_event_{event.id}", from_user_id=admin_id)
    await event_handlers.start_event_editing(callback_start, state, session)
    assert await state.get_state() == EventEditing.choosing_field
    callback_choose_field = MockCallbackQuery(data="edit_field_name", from_user_id=admin_id)
    await event_handlers.choose_field_to_edit(callback_choose_field, state, session)
    assert await state.get_state() == EventEditing.awaiting_new_value
    message = MockMessage(text="ĞĞ¾Ğ²Ğ¾Ğµ Ğ¨Ğ¸ĞºĞ°Ñ€Ğ½Ğ¾Ğµ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ", from_user_id=admin_id)
    await event_handlers.process_new_value_for_event(message, state, session)
    assert await state.get_state() is None
    await session.refresh(event)
    assert event.name == "ĞĞ¾Ğ²Ğ¾Ğµ Ğ¨Ğ¸ĞºĞ°Ñ€Ğ½Ğ¾Ğµ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ"
    message.answer.assert_called_once_with("âœ… ĞŸĞ¾Ğ»Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾!", reply_markup=mocker.ANY)

async def test_mailing_fsm_full_path(session: AsyncSession, mocker):
    mock_do_mailing = mocker.patch("bot.handlers.admin.mailing.do_mailing", new_callable=AsyncMock)
    admin = User(id=1001, phone_number="+1", telegram_id=1001, full_name="Admin", university="ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", role="admin")
    user_mifi = User(id=1, phone_number="+2", telegram_id=1, full_name="User1", university="ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", role="student")
    user_mgu = User(id=2, phone_number="+3", telegram_id=2, full_name="User2", university="ĞœĞ“Ğ£", role="student")
    session.add_all([admin, user_mifi, user_mgu])
    await session.commit()
    state = MockFSMContext()
    cb_start = MockCallbackQuery(data="admin_mailing", from_user_id=admin.id)
    await mailing_handlers.start_mailing(cb_start, state)
    assert await state.get_state() == Mailing.awaiting_message_text
    msg_text = MockMessage(text="<b>Ğ’ÑĞµĞ¼ Ğ¿Ñ€Ğ¸Ğ²ĞµÑ‚!</b>", from_user_id=admin.id)
    await mailing_handlers.get_mailing_text(msg_text, state)
    assert await state.get_state() == Mailing.awaiting_media
    msg_photo = MockMessage(from_user_id=admin.id, photo=True)
    await mailing_handlers.get_mailing_photo(msg_photo, state)
    assert await state.get_state() == Mailing.awaiting_audience_choice
    cb_choose_filter = MockCallbackQuery(data="mail_audience_type_university", from_user_id=admin.id)
    await mailing_handlers.choose_audience_filter_type(cb_choose_filter, state, session)
    cb_set_filter = MockCallbackQuery(data="mail_filter_university_ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", from_user_id=admin.id)
    await mailing_handlers.set_audience_filter(cb_set_filter, state)
    cb_finish_audience = MockCallbackQuery(data="mail_audience_finish", from_user_id=admin.id)
    await mailing_handlers.finish_audience_selection(cb_finish_audience, state, session)
    assert await state.get_state() == Mailing.awaiting_confirmation
    cb_finish_audience.message.answer.assert_called_once()
    args, _ = cb_finish_audience.message.answer.call_args
    assert "<b>ğŸ‘¥ ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ĞµĞ»ĞµĞ¹:</b> 2" in args[0]
    assert "ĞŸÑ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¾ Ñ„Ğ¾Ñ‚Ğ¾" in args[0]
    cb_confirm = MockCallbackQuery(data="confirm_mailing", from_user_id=admin.id)
    await mailing_handlers.confirm_and_start_mailing(cb_confirm, state, Mock(spec=Bot))
    assert await state.get_state() is None
    mock_do_mailing.assert_called_once()

async def test_admin_add_user_fsm_full_path(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ»Ğ½ÑƒÑ FSM-Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºÑƒ Ñ€ÑƒÑ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ¼.
    """
    admin_user_id = 1001
    state = MockFSMContext()

    callback_start = MockCallbackQuery(data="admin_add_user_start", from_user_id=admin_user_id)
    await user_handlers.add_user_start(callback_start, state)
    assert await state.get_state() == AdminAddUser.awaiting_phone
    callback_start.message.edit_text.assert_called_once()

    await user_handlers.add_user_phone(MockMessage(text="+79876543210"), state, session)
    assert await state.get_state() == AdminAddUser.awaiting_full_name

    await user_handlers.add_user_full_name(MockMessage(text="ĞœĞ°Ğ½ÑƒĞ°Ğ»Ğ¾Ğ² ĞœĞ°Ğ½ÑƒĞ°Ğ» ĞœĞ°Ğ½ÑƒĞ°Ğ»Ğ¾Ğ²Ğ¸Ñ‡"), state)
    assert await state.get_state() == AdminAddUser.awaiting_category

    await user_handlers.add_user_category(MockCallbackQuery(data="category_student"), state)
    assert await state.get_state() == AdminAddUser.awaiting_university
    
    await user_handlers.add_user_university(MockCallbackQuery(data="university_mifi"), state)
    assert await state.get_state() == AdminAddUser.awaiting_faculty

    await user_handlers.add_user_faculty(MockCallbackQuery(data="faculty_Ğ˜Ğ˜ĞšĞ¡"), state)
    assert await state.get_state() == AdminAddUser.awaiting_study_group

    await user_handlers.add_user_study_group(MockMessage(text="Ğ‘21-123"), state)
    assert await state.get_state() == AdminAddUser.awaiting_gender

    callback_gender = MockCallbackQuery(data="gender_male")
    await user_handlers.add_user_gender(callback_gender, state, session)
    
    assert await state.get_state() is None

    created_user = (await session.execute(
        select(User).where(User.phone_number == "+79876543210")
    )).scalar_one_or_none()

    assert created_user is not None
    assert created_user.full_name == "ĞœĞ°Ğ½ÑƒĞ°Ğ»Ğ¾Ğ² ĞœĞ°Ğ½ÑƒĞ°Ğ» ĞœĞ°Ğ½ÑƒĞ°Ğ»Ğ¾Ğ²Ğ¸Ñ‡"
    assert created_user.university == "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜"
    assert created_user.faculty == "Ğ˜Ğ˜ĞšĞ¡"
    assert created_user.study_group == "Ğ‘21-123"
    assert created_user.telegram_id == -1
    assert created_user.consent_given is True


async def test_edit_info_section_fsm(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ FSM Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ñ‚ĞµĞºÑÑ‚Ğ° Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ°.
    """
    admin_user_id = 1001
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²ÑƒÑ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ² Ğ‘Ğ”
    info_section = InfoText(
        section_key="prepare",
        section_title="ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°",
        section_text="Ğ¡Ñ‚Ğ°Ñ€Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚"
    )
    session.add(info_section)
    await session.commit()

    state = MockFSMContext()
    
    callback_start = MockCallbackQuery(data="admin_edit_info", from_user_id=admin_user_id)
    await info_handlers.start_info_editing(callback_start, state, session)
    assert await state.get_state() == EditInfoSection.choosing_section
    
    callback_choose = MockCallbackQuery(data="edit_info_prepare", from_user_id=admin_user_id)
    await info_handlers.choose_section_to_edit(callback_choose, state, session)
    assert await state.get_state() == EditInfoSection.awaiting_new_text
    
    new_text = "<b>Ğ­Ñ‚Ğ¾ Ğ½Ğ¾Ğ²Ñ‹Ğ¹, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚!</b>"
    message_new_text = MockMessage(text=new_text, from_user_id=admin_user_id)
    # Ğ˜Ğ¼Ğ¸Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼, Ñ‡Ñ‚Ğ¾ message.html_text ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ñ‚Ğ¾Ñ‚ Ğ¶Ğµ Ñ‚ĞµĞºÑÑ‚
    message_new_text.html_text = new_text 
    await info_handlers.process_new_info_text(message_new_text, state, session)
    assert await state.get_state() is None

    await session.refresh(info_section) 
    assert info_section.section_text == new_text
    
    
    
      
async def test_post_event_processing_fsm(session: AsyncSession, mocker):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ»Ğ½ÑƒÑ FSM-Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºÑƒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞµĞ³Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ:
    - Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ
    - ĞÑ‚Ğ¼ĞµÑ‚ĞºĞ° ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² (ÑĞ´Ğ°Ğ» ĞºÑ€Ğ¾Ğ²ÑŒ / Ğ²ÑÑ‚ÑƒĞ¿Ğ¸Ğ» Ğ² Ğ”ĞšĞœ)
    - Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ² Ğ² Ğ‘Ğ”
    """
    # 1. ĞŸĞĞ”Ğ“ĞĞ¢ĞĞ’ĞšĞ Ğ”ĞĞĞĞ«Ğ¥
    admin = User(phone_number="+0", telegram_id=1000, full_name="Admin", university="Test")
    user1 = User(phone_number="+1", telegram_id=1001, full_name="User One", university="Test", is_dkm_donor=False, points=0, gender="male")
    user2 = User(phone_number="+2", telegram_id=1002, full_name="User Two", university="Test", is_dkm_donor=False, points=0, gender="female")
    
    past_event = Event(
        name="Past Event", 
        event_datetime=datetime.datetime.now() - datetime.timedelta(days=5),
        location="Test", donation_type="whole_blood", points_per_donation=100, participant_limit=10
    )
    session.add_all([admin, user1, user2, past_event])
    await session.commit()
    
    # Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ğ±Ğ¾Ğ¸Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ
    reg1 = EventRegistration(user_id=user1.id, event_id=past_event.id)
    reg2 = EventRegistration(user_id=user2.id, event_id=past_event.id)
    session.add_all([reg1, reg2])
    await session.commit()

    state = MockFSMContext()
    
    # 2. ĞŸĞ ĞĞ¥ĞĞ–Ğ”Ğ•ĞĞ˜Ğ• FSM
    
    # --- Ğ¨Ğ°Ğ³ 1: Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ ---
    callback_start = MockCallbackQuery(data=f"post_process_event_{past_event.id}", from_user_id=admin.telegram_id)
    await event_handlers.choose_event_for_processing(callback_start, state, session)
    assert await state.get_state() == PostEventProcessing.marking_participants
    
    # --- Ğ¨Ğ°Ğ³ 2: ĞÑ‚Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² ---
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 1: ÑĞ´Ğ°Ğ» ĞºÑ€Ğ¾Ğ²ÑŒ
    cb_mark1 = MockCallbackQuery(data=f"mark_participant_{past_event.id}_{user1.id}_donation", from_user_id=admin.telegram_id, message=callback_start.message)
    await event_handlers.mark_participant(cb_mark1, state, session)
    
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 2: ÑĞ´Ğ°Ğ» ĞºÑ€Ğ¾Ğ²ÑŒ
    cb_mark2_don = MockCallbackQuery(data=f"mark_participant_{past_event.id}_{user2.id}_donation", from_user_id=admin.telegram_id, message=callback_start.message)
    await event_handlers.mark_participant(cb_mark2_don, state, session)
    
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 2: Ğ²ÑÑ‚ÑƒĞ¿Ğ¸Ğ» Ğ² Ğ”ĞšĞœ
    cb_mark2_dkm = MockCallbackQuery(data=f"mark_participant_{past_event.id}_{user2.id}_dkm", from_user_id=admin.telegram_id, message=callback_start.message)
    await event_handlers.mark_participant(cb_mark2_dkm, state, session)

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ FSM
    fsm_data = await state.get_data()
    assert fsm_data["marked_donations"] == {user1.id, user2.id}
    assert fsm_data["marked_dkm"] == {user2.id}

    # --- Ğ¨Ğ°Ğ³ 3: Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµĞ¼ Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ---
    callback_finish = MockCallbackQuery(data=f"finish_marking_{past_event.id}", from_user_id=admin.telegram_id, message=callback_start.message)
    await event_handlers.finish_marking(callback_finish, state, session)

    # 3. ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢ĞĞ’ Ğ’ Ğ‘Ğ”
    assert await state.get_state() is None
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ 1
    await session.refresh(user1)
    donations_user1 = (await session.execute(select(Donation).where(Donation.user_id == user1.id))).scalars().all()
    assert len(donations_user1) == 1
    assert user1.points == 100
    assert user1.is_dkm_donor is False # ĞĞµ Ğ¾Ñ‚Ğ¼ĞµÑ‡Ğ°Ğ»Ğ¸ Ğ”ĞšĞœ

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ 2
    await session.refresh(user2)
    donations_user2 = (await session.execute(select(Donation).where(Donation.user_id == user2.id))).scalars().all()
    assert len(donations_user2) == 1
    assert user2.points == 100
    assert user2.is_dkm_donor is True # ĞÑ‚Ğ¼ĞµÑ‡Ğ°Ğ»Ğ¸ Ğ”ĞšĞœ

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_admin_fsm.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_analytics.py ---

# tests/test_analytics.py

import pytest
import datetime
from sqlalchemy.ext.asyncio import AsyncSession

# ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ğ¸Ğ· ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ
from bot.db import analytics_requests
from bot.db.models import User, Donation, MedicalWaiver, Survey, Event, EventRegistration

pytestmark = pytest.mark.asyncio

# --- Ğ¢ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹ Ğ¸Ğ· analytics_requests.py ---

async def test_get_churn_donors(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚: ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ²-Ğ¾Ğ´Ğ½Ğ¾Ğ´Ğ½ĞµĞ²Ğ¾Ğº (1 Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ, >6 Ğ¼ĞµÑ. Ğ½Ğ°Ğ·Ğ°Ğ´).
    """
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 1: Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¿Ğ¾Ğ´ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ
    user1 = User(id=1, full_name="Churn Donor", telegram_id=111, phone_number="111", university="Test")
    donation1 = Donation(user_id=1, donation_date=datetime.date.today() - datetime.timedelta(days=200), donation_type='whole_blood', points_awarded=10)
    
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 2: Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ±Ñ‹Ğ»Ğ° Ğ½ĞµĞ´Ğ°Ğ²Ğ½Ğ¾
    user2 = User(id=2, full_name="Active Donor", telegram_id=222, phone_number="222", university="Test")
    donation2 = Donation(user_id=2, donation_date=datetime.date.today() - datetime.timedelta(days=30), donation_type='whole_blood', points_awarded=10)
    
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 3: Ğ¸Ğ¼ĞµĞµÑ‚ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹
    user3 = User(id=3, full_name="Multiple Donor", telegram_id=333, phone_number="333", university="Test")
    donation3_1 = Donation(user_id=3, donation_date=datetime.date.today() - datetime.timedelta(days=200), donation_type='whole_blood', points_awarded=10)
    donation3_2 = Donation(user_id=3, donation_date=datetime.date.today() - datetime.timedelta(days=30), donation_type='plasma', points_awarded=10)

    session.add_all([user1, donation1, user2, donation2, user3, donation3_1, donation3_2])
    await session.commit()

    churn_donors = await analytics_requests.get_churn_donors(session)

    assert len(churn_donors) == 1
    assert churn_donors[0]['full_name'] == "Churn Donor"


async def test_get_lapsed_donors(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚: ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑƒĞ³Ğ°ÑĞ°ÑÑ‰Ğ¸Ñ… Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ² (2+ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸, Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ >9 Ğ¼ĞµÑ. Ğ½Ğ°Ğ·Ğ°Ğ´, Ğ±ĞµĞ· Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°).
    """
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 1: Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¿Ğ¾Ğ´ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ
    user1 = User(id=4, full_name="Lapsed Donor", telegram_id=444, phone_number="444", university="Test")
    d1_1 = Donation(user_id=4, donation_date=datetime.date.today() - datetime.timedelta(days=300), donation_type='whole_blood', points_awarded=10)
    d1_2 = Donation(user_id=4, donation_date=datetime.date.today() - datetime.timedelta(days=400), donation_type='whole_blood', points_awarded=10)

    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 2: Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ±Ñ‹Ğ»Ğ° Ğ½ĞµĞ´Ğ°Ğ²Ğ½Ğ¾
    user2 = User(id=5, full_name="Active Donor", telegram_id=555, phone_number="555", university="Test")
    d2_1 = Donation(user_id=5, donation_date=datetime.date.today() - datetime.timedelta(days=30), donation_type='whole_blood', points_awarded=10)
    d2_2 = Donation(user_id=5, donation_date=datetime.date.today() - datetime.timedelta(days=60), donation_type='plasma', points_awarded=10)

    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 3: Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¿Ğ¾ Ğ´Ğ°Ñ‚Ğ°Ğ¼, Ğ½Ğ¾ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´
    user3 = User(id=6, full_name="Lapsed With Waiver", telegram_id=666, phone_number="666", university="Test")
    d3_1 = Donation(user_id=6, donation_date=datetime.date.today() - datetime.timedelta(days=300), donation_type='whole_blood', points_awarded=10)
    d3_2 = Donation(user_id=6, donation_date=datetime.date.today() - datetime.timedelta(days=400), donation_type='whole_blood', points_awarded=10)
    waiver = MedicalWaiver(user_id=6, start_date=datetime.date.today(), end_date=datetime.date.today() + datetime.timedelta(days=30), reason="test", created_by="system")

    session.add_all([user1, d1_1, d1_2, user2, d2_1, d2_2, user3, d3_1, d3_2, waiver])
    await session.commit()

    lapsed_donors = await analytics_requests.get_lapsed_donors(session)

    assert len(lapsed_donors) == 1
    assert lapsed_donors[0]['full_name'] == "Lapsed Donor"

async def test_get_survey_dropoff(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚: ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹, Ğ¿Ñ€Ğ¾ÑˆĞµĞ´ÑˆĞ¸Ñ… Ğ¾Ğ¿Ñ€Ğ¾Ñ, Ğ½Ğ¾ Ğ½Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ²ÑˆĞ¸Ñ…ÑÑ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ ÑÑ‚Ğ¾Ğ³Ğ¾.
    """
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 1: Ğ¿Ñ€Ğ¾ÑˆĞµĞ» Ğ¾Ğ¿Ñ€Ğ¾Ñ, Ğ½Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ»ÑÑ -> Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ² ÑĞ¿Ğ¸ÑĞºĞµ
    user1 = User(id=38, full_name="Dropoff User", telegram_id=380, phone_number="380", university="Test")
    survey1 = Survey(user_id=38, passed=True, answers_json={}, created_at=datetime.datetime.now() - datetime.timedelta(days=10))

    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 2: Ğ¿Ñ€Ğ¾ÑˆĞµĞ» Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ»ÑÑ ĞŸĞĞ¡Ğ›Ğ•
    user2 = User(id=39, full_name="Registered User", telegram_id=390, phone_number="390", university="Test")
    survey2 = Survey(user_id=39, passed=True, answers_json={}, created_at=datetime.datetime.now() - datetime.timedelta(days=10))
    event1 = Event(name="event 1", event_datetime=datetime.datetime.now(), location="Ğ¦ĞµĞ½Ñ‚Ñ€ ĞºÑ€Ğ¾Ğ²Ğ¸", donation_type="d", points_per_donation=1, participant_limit=1)
    session.add(event1)
    await session.commit()
    reg2 = EventRegistration(user_id=39, event_id=event1.id, registration_date=datetime.datetime.now() - datetime.timedelta(days=5))

    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 3: Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½
    user3 = User(id=40, full_name="Failed Survey User", telegram_id=400, phone_number="400", university="Test")
    survey3 = Survey(user_id=40, passed=False, answers_json={}, created_at=datetime.datetime.now() - datetime.timedelta(days=10))

    session.add_all([user1, survey1, user2, survey2, reg2, user3, survey3])
    await session.commit()
    
    dropoff_users = await analytics_requests.get_survey_dropoff(session)

    assert len(dropoff_users) == 1
    assert dropoff_users[0]['full_name'] == "Dropoff User"

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_analytics.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_api.py ---

# Ğ¤ĞĞ™Ğ›: tests/test_api.py

import pytest
import pytest_asyncio
from unittest.mock import AsyncMock
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from main import app, SurveyPayload, SurveyAnswers
from bot.db.models import User, Survey, MedicalWaiver
from tests.test_security import generate_test_auth_data
from bot.config_reader import config
from tests.conftest import TestSessionMaker

async def override_get_session():
    async with TestSessionMaker() as session:
        yield session

from main import app, get_session
from tests.conftest import TestSessionMaker

async def override_get_session():
    async with TestSessionMaker() as session:
        yield session

@pytest_asyncio.fixture
async def client():
    app.dependency_overrides[get_session] = override_get_session
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
    app.dependency_overrides = {}

# --- Ğ¢ĞµÑÑ‚Ñ‹ ---

async def test_health_check(client: AsyncClient):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚ /health."""
    response = await client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "ok"}


async def test_submit_survey_failure_bad_payload(client: AsyncClient):
    """Ğ¢ĞµÑÑ‚: ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ³Ğ¾ JSON."""
    response = await client.post("/api/submit_survey", content="this is not json")
    assert response.status_code == 400

async def test_submit_survey_failure_invalid_auth(client: AsyncClient):
    """Ğ¢ĞµÑÑ‚: ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¼ Ñ…ĞµÑˆĞµĞ¼."""
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Payload Ñ‚ĞµĞ¿ĞµÑ€ÑŒ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ²ÑĞµ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ´Ğ»Ñ SurveyAnswers
    payload = {
        "survey_data": {
            "age": "yes", "weight": "yes", "health_issues_last_month": "no",
            "symptoms": "no", "pressure": "ok", "hemoglobin_level": "ok",
            "diet_followed": "yes", "alcohol_last_48h": "no", "medication_last_72h": "no",
            "sleep_last_night": "yes", "smoking_last_hour": "no",
            "tattoo_or_piercing": "no", "tooth_removal_last_10_days": "no",
            "antibiotics_last_2_weeks": "no", "analgesics_last_3_days": "no",
            "has_hiv_or_hepatitis": "no", "has_cancer_or_blood_disease": "no",
            "has_chronic_disease": "no"
        },
        "auth_string": "invalid_hash_string"
    }
    response = await client.post("/api/submit_survey", json=payload)
    # Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¼Ñ‹ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµĞ¼ 403, Ñ‚Ğ°Ğº ĞºĞ°Ğº Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ payload Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµÑ‚, Ğ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ auth_string - Ğ½ĞµÑ‚
    assert response.status_code == 403

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_api.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_calendar_service.py ---

import pytest
import datetime
from bot.utils.calendar_service import generate_ics_file
from bot.db.models import Event

def test_generate_ics_file():
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğ³Ğ¾ .ics Ñ„Ğ°Ğ¹Ğ»Ğ°.
    ĞĞ´Ğ°Ğ¿Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ğ´Ğ»Ñ ics==0.7.2, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ²Ñ€ĞµĞ¼Ñ Ğ² UTC.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° "Ñ„ĞµĞ¹ĞºĞ¾Ğ²Ğ¾Ğ³Ğ¾" Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ.
    # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ°Ğ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¸Ğ¹ ĞºĞ»ÑÑ‡, ĞºĞ°Ğº Ğ² Ğ‘Ğ”.
    mock_event = Event(
        id=123,
        name="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ",
        event_datetime=datetime.datetime(2025, 10, 26, 14, 0, 0), 
        location="ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜, ĞšĞ°ÑˆĞ¸Ñ€ÑĞºĞ¾Ğµ Ñˆ. 31",
        donation_type="plasma" 
    )

    # 2. Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚Ğ°
    ics_string = generate_ics_file(mock_event)

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
    assert "BEGIN:VCALENDAR" in ics_string
    assert "SUMMARY:Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ: Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ" in ics_string
    assert "LOCATION:ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜\\, ĞšĞ°ÑˆĞ¸Ñ€ÑĞºĞ¾Ğµ Ñˆ. 31" in ics_string
    assert "DESCRIPTION:Ğ¢Ğ¸Ğ¿ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸: ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°" in ics_string
    assert "DTSTART:20251026T110000Z" in ics_string
    assert "DTEND:20251026T130000Z" in ics_string

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ±ÑƒĞ´Ğ¸Ğ»ÑŒĞ½Ğ¸ĞºĞ°
    assert "ACTION:DISPLAY" in ics_string
    assert "TRIGGER:-PT1H" in ics_string

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_calendar_service.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_data_io.py ---

import pytest
import pandas as pd
import io
from datetime import date
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from bot.handlers.admin.system import create_full_backup_xlsx
from bot.utils.data_import import import_data_from_file
from bot.db.models import User, Donation

pytestmark = pytest.mark.asyncio

# --- Ğ¢ĞµÑÑ‚ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ° ---

async def test_create_full_backup_xlsx(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ñ‡Ñ‚Ğ¾ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚ ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ XLSX Ñ„Ğ°Ğ¹Ğ»."""
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°: ĞĞ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ‘Ğ” Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
    user1 = User(id=1, phone_number="+1", telegram_id=1, full_name="User Export", university="Test", points=50)
    donation1 = Donation(id=1, user_id=1, donation_date=date(2024, 1, 1), donation_type="test", points_awarded=50)
    session.add_all([user1, donation1])
    await session.commit()

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ: Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ°
    xlsx_bytes_io = await create_full_backup_xlsx(session)
    
    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    assert isinstance(xlsx_bytes_io, io.BytesIO)
    xlsx_bytes_io.seek(0) # ĞŸĞµÑ€ĞµĞ¼Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ "Ñ„Ğ°Ğ¹Ğ»" Ğ² Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ğ´Ğ»Ñ Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ
    
    # Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ XLSX Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ pandas
    xls = pd.ExcelFile(xlsx_bytes_io)
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ½ÑƒĞ¶Ğ½Ñ‹Ñ… Ğ»Ğ¸ÑÑ‚Ğ¾Ğ²
    assert 'Users' in xls.sheet_names
    assert 'Donations' in xls.sheet_names
    
    # Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ Ğ»Ğ¸ÑÑ‚Ğ° Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ
    users_df = pd.read_excel(xls, sheet_name='Users')
    assert len(users_df) == 1
    assert users_df.iloc[0]['full_name'] == "User Export"
    assert users_df.iloc[0]['points'] == 50

# --- Ğ¢ĞµÑÑ‚Ñ‹ Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ° ---

async def test_import_data_from_file_create_and_update(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ¿Ñ€Ğ¸ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğµ."""
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ ÑƒĞ¶Ğµ ĞµÑÑ‚ÑŒ Ğ² Ğ‘Ğ”
    existing_user = User(id=1, phone_number="+79000000000", telegram_id=1, full_name="Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ˜Ğ¼Ñ", university="Test")
    session.add(existing_user)
    await session.commit()
    
    # Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ğ¼ "Ñ„Ğ°Ğ¹Ğ»" Ğ´Ğ»Ñ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ°
    import_data = {
        'Ğ¤Ğ˜Ğ': ['Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ Ğ˜Ğ¼Ñ', 'ĞĞ¾Ğ²Ñ‹Ğ¹ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ'],
        'Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½': ['79000000000', '79111111111'],
        'Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ°': ['Ğ‘20-505', 'ÑĞ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸Ğº']
    }
    df = pd.DataFrame(import_data)
    
    output_buffer = io.BytesIO()
    df.to_excel(output_buffer, index=False, engine='openpyxl')
    output_buffer.seek(0)
    
    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    created_count, updated_count = await import_data_from_file(session, output_buffer)

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    assert created_count == 1
    assert updated_count == 1
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    await session.refresh(existing_user)
    assert existing_user.study_group == "Ğ‘20-505"
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    new_user = (await session.execute(select(User).where(User.phone_number == "+79111111111"))).scalar_one()
    assert new_user.full_name == "ĞĞ¾Ğ²Ñ‹Ğ¹ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ"
    assert new_user.faculty == "Ğ¡Ğ¾Ñ‚Ñ€ÑƒĞ´Ğ½Ğ¸Ğº"
    assert new_user.telegram_id < 0 # Ğ£Ğ±ĞµĞ¶Ğ´Ğ°ĞµĞ¼ÑÑ, Ñ‡Ñ‚Ğ¾ ID Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹

async def test_import_data_missing_column_raises_error():
    """Ğ¢ĞµÑÑ‚: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚ Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¾Ğ¹, ĞµÑĞ»Ğ¸ Ğ½ĞµÑ‚ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ñ… ĞºĞ¾Ğ»Ğ¾Ğ½Ğ¾Ğº."""
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°: Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ "Ğ¿Ğ»Ğ¾Ñ…Ğ¾Ğ¹" Ñ„Ğ°Ğ¹Ğ» Ğ±ĞµĞ· ĞºĞ¾Ğ»Ğ¾Ğ½ĞºĞ¸ 'Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½'
    import_data = {'Ğ¤Ğ˜Ğ': ['ĞšĞ°ĞºĞ¾Ğ¹-Ñ‚Ğ¾ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ']}
    df = pd.DataFrame(import_data)
    
    output_buffer = io.BytesIO()
    df.to_excel(output_buffer, index=False, engine='openpyxl')
    output_buffer.seek(0)
    
    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°: ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼ ValueError
    with pytest.raises(ValueError, match="Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºĞ¾Ğ»Ğ¾Ğ½ĞºĞ¸"):
        # ĞŸĞµÑ€ĞµĞ´Ğ°ĞµĞ¼ None Ğ²Ğ¼ĞµÑÑ‚Ğ¾ ÑĞµÑÑĞ¸Ğ¸, Ñ‚Ğ°Ğº ĞºĞ°Ğº Ğ´Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ½ĞµĞ¹ Ğ½Ğµ Ğ´Ğ¾Ğ¹Ğ´ĞµÑ‚
        await import_data_from_file(None, output_buffer)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_data_io.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_db_requests.py ---

import pytest
import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from bot.db import user_requests, admin_requests, event_requests, merch_requests, info_requests
from bot.db.models import User, Event, EventRegistration, MedicalWaiver, Donation, MerchItem, UserBlock, MerchOrder, InfoText

# ĞœĞ°Ñ€ĞºĞ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑĞµ Ñ‚ĞµÑÑ‚Ñ‹ Ğ² ÑÑ‚Ğ¾Ğ¼ Ñ„Ğ°Ğ¹Ğ»Ğµ Ğ´Ğ»Ñ pytest-asyncio
pytestmark = pytest.mark.asyncio

async def test_add_user_with_custom_university(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ñ ĞºĞ°ÑÑ‚Ğ¾Ğ¼Ğ½Ñ‹Ğ¼ Ğ’Ğ£Ğ—Ğ¾Ğ¼ Ğ¸ ĞµĞ³Ğ¾ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    user_data = {
        "phone_number": "+79991112233",
        "telegram_id": 987654321,
        "telegram_username": "msu_student",
        "full_name": "Ğ¡Ñ‚ÑƒĞ´ĞµĞ½Ñ‚ Ğ”Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾ Ğ’Ğ£Ğ—Ğ°",
        "university": "ĞœĞ“Ğ£ Ğ¸Ğ¼. Ğ›Ğ¾Ğ¼Ğ¾Ğ½Ğ¾ÑĞ¾Ğ²Ğ°", 
        "faculty": "Ğ’ĞœĞš",
        "study_group": "101",
        "gender": "male"
    }

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    new_user = await user_requests.add_user(session, user_data)
    await session.commit()
    
    retrieved_user = await user_requests.get_user_by_tg_id(session, 987654321)

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    assert new_user.id is not None
    assert retrieved_user is not None
    assert retrieved_user.full_name == "Ğ¡Ñ‚ÑƒĞ´ĞµĞ½Ñ‚ Ğ”Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾ Ğ’Ğ£Ğ—Ğ°"
    assert retrieved_user.university == "ĞœĞ“Ğ£ Ğ¸Ğ¼. Ğ›Ğ¾Ğ¼Ğ¾Ğ½Ğ¾ÑĞ¾Ğ²Ğ°" # Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    assert retrieved_user.role == "student"


# --- ĞĞĞ’Ğ«Ğ™ Ğ¢Ğ•Ğ¡Ğ¢ Ğ”Ğ›Ğ¯ ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ˜ Ğ¡ĞĞ¥Ğ ĞĞĞ•ĞĞ˜Ğ¯ ĞšĞĞĞ Ğ”Ğ˜ĞĞĞ¢ ---
async def test_create_event_with_location(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ñ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ°Ğ¼Ğ¸ Ğ¸ Ğ¸Ñ… ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ² Ğ‘Ğ”.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    event_data = {
        "name": "Event with Location",
        "event_datetime": datetime.datetime(2030, 5, 20, 10, 0),
        "location": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜, ĞšĞ°ÑˆĞ¸Ñ€ÑĞºĞ¾Ğµ Ñˆ. 31",
        "latitude": 55.649917,
        "longitude": 37.662128,
        "donation_type": "whole_blood",
        "points_per_donation": 100,
        "participant_limit": 50,
    }

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    new_event = await admin_requests.create_event(session, event_data)
    await session.commit()

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    retrieved_event = await session.get(Event, new_event.id)
    assert retrieved_event is not None
    assert retrieved_event.name == "Event with Location"
    assert retrieved_event.latitude == 55.649917
    assert retrieved_event.longitude == 37.662128
# --- ĞšĞĞĞ•Ğ¦ ĞĞĞ’ĞĞ“Ğ Ğ¢Ğ•Ğ¡Ğ¢Ğ ---


async def test_add_and_get_user(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Ğ‘Ğ” Ğ¸ ĞµĞ³Ğ¾ Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞµ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    user_data = {
        "phone_number": "+79991234567",
        "telegram_id": 123456789,
        "telegram_username": "testuser",
        "full_name": "Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ",
        "university": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜",
    }

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    new_user = await user_requests.add_user(session, user_data)
    await session.commit()
    
    retrieved_user = await user_requests.get_user_by_tg_id(session, 123456789)

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    assert new_user.id is not None
    assert retrieved_user is not None
    assert retrieved_user.full_name == "Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ"
    assert retrieved_user.telegram_id == 123456789

async def test_find_user_for_admin(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğ¼ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸ÑĞ¼.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° (ÑĞ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹)
    users_to_add = [
        User(phone_number="+7001", telegram_id=1, telegram_username="john_doe", full_name="John Doe", university="A"),
        User(phone_number="+7002", telegram_id=2, telegram_username="jane_smith", full_name="Jane Smith", university="B"),
        User(phone_number="+7003", telegram_id=3, telegram_username="tester", full_name="Another Tester", university="C"),
    ]
    session.add_all(users_to_add)
    await session.commit()

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    # ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ‡Ğ°ÑÑ‚Ğ¸ Ğ¤Ğ˜Ğ
    found_by_name = await admin_requests.find_user_for_admin(session, "Smith")
    assert len(found_by_name) == 1
    assert found_by_name[0].full_name == "Jane Smith"

    # ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ username
    found_by_username = await admin_requests.find_user_for_admin(session, "john_doe")
    assert len(found_by_username) == 1
    assert found_by_username[0].telegram_id == 1

    # ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ID
    found_by_id = await admin_requests.find_user_for_admin(session, "3")
    assert len(found_by_id) == 1
    assert found_by_id[0].full_name == "Another Tester"

    # ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ‡Ğ°ÑÑ‚Ğ¸ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°
    found_by_phone = await admin_requests.find_user_for_admin(session, "001")
    assert len(found_by_phone) == 1
    assert found_by_phone[0].telegram_id == 1

async def test_check_registration_eligibility(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    user = User(
        phone_number="+7111", telegram_id=111, full_name="Eligible User", gender="male",
        is_blocked=False, university="TestUni"
    )
    event = Event(
        name="Test Event",
        event_datetime=datetime.datetime.now() + datetime.timedelta(days=10),
        location="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ, Ğ³. ĞœĞ¾ÑĞºĞ²Ğ°",
        donation_type="whole_blood",
        participant_limit=5,
        registration_is_open=True,
        points_per_donation=10
    )
    session.add_all([user, event])
    await session.commit()

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: Ğ£ÑĞ¿ĞµÑˆĞ½Ğ°Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ
    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    assert is_eligible is True
    assert "Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ñ‹" in reason

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 2: Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°
    event.registration_is_open = False
    await session.commit()
    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    assert is_eligible is False
    assert "Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°" in reason
    event.registration_is_open = True 
    await session.commit()

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 3: ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒĞ¶Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½
    reg = EventRegistration(user_id=user.id, event_id=event.id)
    session.add(reg)
    await session.commit()
    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    assert is_eligible is False
    assert "ÑƒĞ¶Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹" in reason
    await session.delete(reg) 
    await session.commit()

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 4: Ğ£ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ ĞµÑÑ‚ÑŒ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´
    waiver = MedicalWaiver(
        user_id=user.id,
        start_date=datetime.date.today(),
        end_date=datetime.date.today() + datetime.timedelta(days=30), 
        reason="Test Waiver",
        created_by="system"
    )
    session.add(waiver)
    await session.commit()
    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    assert is_eligible is False
    assert "Ğ´ĞµĞ¹ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¾Ñ‚Ğ²Ğ¾Ğ´" in reason


# --- ĞĞĞ’Ğ«Ğ• Ğ¢Ğ•Ğ¡Ğ¢Ğ« ---

async def test_change_user_role(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ğµ Ğ¸ Ğ¿Ğ¾Ğ½Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ Ñ€Ğ¾Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    user = User(phone_number="+7111", telegram_id=111, full_name="Test User", role="student", university="TestUni")
    session.add(user)
    await session.commit()

    # 2. ĞŸĞ¾Ğ²Ñ‹ÑˆĞ°ĞµĞ¼ Ğ´Ğ¾ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°
    await admin_requests.change_user_role(session, user.id, "volunteer")
    
    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼
    updated_user_1 = await session.get(User, user.id)
    assert updated_user_1.role == "volunteer"

    # 4. ĞŸĞ¾Ğ½Ğ¸Ğ¶Ğ°ĞµĞ¼ Ğ´Ğ¾ ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚Ğ°
    await admin_requests.change_user_role(session, user.id, "student")

    # 5. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼
    updated_user_2 = await session.get(User, user.id)
    assert updated_user_2.role == "student"


async def test_block_and_unblock_user(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºÑƒ Ğ¸ Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºÑƒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    admin = User(phone_number="+7_admin", telegram_id=999, full_name="Admin", university="TestUni")
    target_user = User(phone_number="+7_target", telegram_id=123, full_name="Target", university="TestUni")
    session.add_all([admin, target_user])
    await session.commit()

    # 2. Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    await admin_requests.block_user(session, target_user.id, admin.id, "Test block reason")
    
    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼
    blocked_user = await session.get(User, target_user.id)
    block_record = (await session.execute(select(UserBlock))).scalar_one_or_none()
    assert blocked_user.is_blocked is True
    assert block_record is not None
    assert block_record.reason == "Test block reason"
    assert block_record.is_active is True

    # 4. Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµĞ¼
    await admin_requests.unblock_user(session, target_user.id)
    
    # 5. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼
    unblocked_user = await session.get(User, target_user.id)
    await session.refresh(block_record) # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ Ğ¸Ğ· Ğ‘Ğ”
    assert unblocked_user.is_blocked is False
    assert block_record.is_active is False


async def test_confirm_donation_transaction(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ»Ğ½ÑƒÑ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸."""
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    user = User(phone_number="+7", telegram_id=1, full_name="Donor", gender="male", points=0, university="TestUni")
    event_date = datetime.date.today()
    event_dt = datetime.datetime.combine(event_date, datetime.time.min)
    event = Event(
        name="Transaction Test Event",
        event_datetime=event_dt,
        location="Test",
        donation_type="whole_blood",
        points_per_donation=50,
        participant_limit=5
    )
    session.add_all([user, event])
    await session.commit()
    registration = EventRegistration(user_id=user.id, event_id=event.id)
    session.add(registration)
    await session.commit()

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    points, waiver_end_date = await event_requests.confirm_donation_transaction(session, user, registration)
    
    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²
    updated_user = await session.get(User, user.id)
    assert points == 50
    assert updated_user.points == 50
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸
    donation = (await session.execute(select(Donation))).scalar_one()
    assert donation.user_id == user.id
    assert donation.points_awarded == 50
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one()
    expected_end_date = event_date + datetime.timedelta(days=60) # 60 Ğ´Ğ½ĞµĞ¹ Ğ´Ğ»Ñ Ğ¼ÑƒĞ¶Ñ‡Ğ¸Ğ½Ñ‹
    assert waiver.end_date == expected_end_date
    assert waiver_end_date == expected_end_date
    assert waiver.created_by == "system"

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸
    updated_reg = await session.get(EventRegistration, registration.id)
    assert updated_reg.status == "attended"


async def test_create_merch_order_success_and_fail(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¸ Ğ¾Ñ‚ĞºĞ°Ğ· Ğ¿Ñ€Ğ¸ Ğ½ĞµÑ…Ğ²Ğ°Ñ‚ĞºĞµ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²."""
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    user_rich = User(phone_number="+1", telegram_id=1, full_name="Rich", points=100, university="TestUni")
    user_poor = User(phone_number="+2", telegram_id=2, full_name="Poor", points=10, university="TestUni")
    item = MerchItem(name="Test Mug", description="A mug", price=50, photo_file_id="123")
    session.add_all([user_rich, user_poor, item])
    await session.commit()

    # 2. Ğ£ÑĞ¿ĞµÑˆĞ½Ğ°Ñ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ°
    success, msg = await merch_requests.create_merch_order(session, user_rich, item)
    await session.commit()

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¹ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸
    order = (await session.execute(select(MerchOrder).where(MerchOrder.user_id == user_rich.id))).scalar_one()
    assert success is True
    assert "ĞŸĞ¾ĞºÑƒĞ¿ĞºĞ° ÑĞ¾Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°" in msg
    assert user_rich.points == 50
    assert order is not None

    # 4. ĞĞµÑƒÑĞ¿ĞµÑˆĞ½Ğ°Ñ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ°
    success_fail, msg_fail = await merch_requests.create_merch_order(session, user_poor, item)
    await session.commit()

    # 5. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½ĞµÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¹ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸
    order_fail = (await session.execute(select(MerchOrder).where(MerchOrder.user_id == user_poor.id))).scalar_one_or_none()
    assert success_fail is False
    assert "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ²" in msg_fail
    assert user_poor.points == 10 # Ğ‘Ğ°Ğ»Ğ»Ñ‹ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ±Ñ‹Ğ»Ğ¸ ÑĞ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ
    assert order_fail is None


async def test_user_can_delete_own_waiver_but_not_system(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ²Ğ¾Ğ¹ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´, Ğ½Ğ¾ Ğ½Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğ¹.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    user = User(phone_number="+1", telegram_id=1, full_name="Waiver User", university="TestUni")
    session.add(user)
    await session.commit()

    # --- Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ•: Ğ”ĞĞ‘ĞĞ’Ğ›Ğ¯Ğ•Ğœ start_date ---
    today = datetime.date.today()
    waiver_by_user = MedicalWaiver(
        user_id=user.id,
        start_date=today, # <-- Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾
        end_date=datetime.date.max,
        reason="self",
        created_by="user"
    )
    waiver_by_system = MedicalWaiver(
        user_id=user.id,
        start_date=today, # <-- Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾
        end_date=datetime.date.max,
        reason="donation",
        created_by="system"
    )
    # ----------------------------------------
    
    session.add_all([waiver_by_user, waiver_by_system])
    await session.commit()
    
    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    # ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ²Ğ¾Ğ¹
    can_delete_own = await user_requests.delete_user_waiver(session, waiver_by_user.id, user.id)
    assert can_delete_own is True
    
    # ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğ¹
    can_delete_system = await user_requests.delete_user_waiver(session, waiver_by_system.id, user.id)
    assert can_delete_system is False

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ² Ğ‘Ğ” Ğ¾ÑÑ‚Ğ°Ğ»ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğ¹
    remaining_waivers = (await session.execute(select(MedicalWaiver))).scalars().all()
    assert len(remaining_waivers) == 1
    assert remaining_waivers[0].id == waiver_by_system.id
    
@pytest.mark.parametrize(
    "user_data, donations, waivers, expected_in_list",
    [
        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: Ğ§Ğ¸ÑÑ‚Ñ‹Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ, Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ğ¾Ğ¿Ğ°ÑÑ‚ÑŒ Ğ² Ñ€Ğ°ÑÑÑ‹Ğ»ĞºÑƒ
        ({"gender": "male", "id": 1, "tg_id": 1}, [], [], True),
        
        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 2: ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ñ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ¼, ĞĞ• Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ğ¾Ğ¿Ğ°ÑÑ‚ÑŒ
        ({"gender": "male", "id": 2, "tg_id": 2}, [], [{"days_ago": 10, "duration": 30}], False),
        
        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 3: ĞœÑƒĞ¶Ñ‡Ğ¸Ğ½Ğ°, ÑĞ´Ğ°Ñ‡Ğ° ĞºÑ€Ğ¾Ğ²Ğ¸ < 60 Ğ´Ğ½ĞµĞ¹ Ğ½Ğ°Ğ·Ğ°Ğ´, ĞĞ• Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ğ¾Ğ¿Ğ°ÑÑ‚ÑŒ
        ({"gender": "male", "id": 3, "tg_id": 3}, [{"type": "whole_blood", "days_ago": 45}], [], False),
        
        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 4: ĞœÑƒĞ¶Ñ‡Ğ¸Ğ½Ğ°, ÑĞ´Ğ°Ñ‡Ğ° ĞºÑ€Ğ¾Ğ²Ğ¸ > 60 Ğ´Ğ½ĞµĞ¹ Ğ½Ğ°Ğ·Ğ°Ğ´, Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ğ¾Ğ¿Ğ°ÑÑ‚ÑŒ
        ({"gender": "male", "id": 4, "tg_id": 4}, [{"type": "whole_blood", "days_ago": 70}], [], True),
        
        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 5: Ğ–ĞµĞ½Ñ‰Ğ¸Ğ½Ğ°, ÑĞ´Ğ°Ñ‡Ğ° ĞºÑ€Ğ¾Ğ²Ğ¸ 80 Ğ´Ğ½ĞµĞ¹ Ğ½Ğ°Ğ·Ğ°Ğ´. Ğ˜Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» 90 Ğ´Ğ½ĞµĞ¹. 80+15=95 > 90. Ğ”ĞĞ›Ğ–ĞĞ ĞŸĞĞŸĞĞ¡Ğ¢Ğ¬.
        ({"gender": "female", "id": 5, "tg_id": 5}, [{"type": "whole_blood", "days_ago": 80}], [], True), 

        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 6: Ğ–ĞµĞ½Ñ‰Ğ¸Ğ½Ğ°, ÑĞ´Ğ°Ñ‡Ğ° ĞºÑ€Ğ¾Ğ²Ğ¸ 100 Ğ´Ğ½ĞµĞ¹ Ğ½Ğ°Ğ·Ğ°Ğ´. Ğ”ĞĞ›Ğ–ĞĞ ĞŸĞĞŸĞĞ¡Ğ¢Ğ¬.
        ({"gender": "female", "id": 6, "tg_id": 6}, [{"type": "whole_blood", "days_ago": 100}], [], True),

        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 7: Ğ¡Ğ´Ğ°Ñ‡Ğ° Ğ¿Ğ»Ğ°Ğ·Ğ¼Ñ‹ 10 Ğ´Ğ½ĞµĞ¹ Ğ½Ğ°Ğ·Ğ°Ğ´. Ğ˜Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» 14 Ğ´Ğ½ĞµĞ¹. 10+15=25 > 14. Ğ”ĞĞ›Ğ–Ğ•Ğ ĞŸĞĞŸĞĞ¡Ğ¢Ğ¬.
        ({"gender": "male", "id": 7, "tg_id": 7}, [{"type": "plasma", "days_ago": 10}], [], True),
        
        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 8: Ğ¡Ğ´Ğ°Ñ‡Ğ° ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ² > 14 Ğ´Ğ½ĞµĞ¹ Ğ½Ğ°Ğ·Ğ°Ğ´, Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ğ¾Ğ¿Ğ°ÑÑ‚ÑŒ
        ({"gender": "male", "id": 8, "tg_id": 8}, [{"type": "plasma", "days_ago": 20}], [], True),

        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 9: ĞœÑƒĞ¶Ñ‡Ğ¸Ğ½Ğ°, Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ° (5) Ğ¿Ğ¾ Ñ†ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ ĞºÑ€Ğ¾Ğ²Ğ¸, ĞĞ• Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ğ¾Ğ¿Ğ°ÑÑ‚ÑŒ
        ({"gender": "male", "id": 9, "tg_id": 9}, [{"type": "whole_blood", "days_ago": d} for d in [70, 140, 210, 280, 350]], [], False),

        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 10: ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑĞ¾ ÑÑ‚Ğ°Ñ€Ñ‹Ğ¼ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ¼, Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ğ¾Ğ¿Ğ°ÑÑ‚ÑŒ
        ({"gender": "male", "id": 10, "tg_id": 10}, [], [{"days_ago": 100, "duration": 30}], True),
    ]
)
async def test_get_users_for_event_notification(session: AsyncSession, user_data, donations, waivers, expected_in_list):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ»Ğ¾Ğ¶Ğ½ÑƒÑ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ´Ğ»Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¸.
    Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ° ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸ĞµĞ².
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    today = datetime.date.today()
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ´Ğ»Ñ ÑĞ´Ğ°Ñ‡Ğ¸ Ñ†ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ ĞºÑ€Ğ¾Ğ²Ğ¸ Ñ‡ĞµÑ€ĞµĞ· 15 Ğ´Ğ½ĞµĞ¹
    event = Event(
        name="Notification Test Event",
        event_datetime=datetime.datetime.now() + datetime.timedelta(days=15),
        location="Test",
        donation_type="whole_blood",
        points_per_donation=10,
        participant_limit=100
    )
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user = User(
        id=user_data["id"],
        telegram_id=user_data["tg_id"],
        phone_number=f"+{user_data['id']}",
        full_name=f"User {user_data['id']}",
        gender=user_data["gender"],
        university="TestUni"
    )
    session.add(user)

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ĞµĞ³Ğ¾ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹
    for don in donations:
        donation = Donation(
            user_id=user.id,
            donation_type=don["type"],
            donation_date=today - datetime.timedelta(days=don["days_ago"]),
            points_awarded=10
        )
        session.add(donation)
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ĞµĞ³Ğ¾ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ²
    for wav in waivers:
        waiver = MedicalWaiver(
            user_id=user.id,
            start_date=today - datetime.timedelta(days=wav["days_ago"]),
            end_date=today - datetime.timedelta(days=wav["days_ago"]) + datetime.timedelta(days=wav["duration"]),
            reason="test",
            created_by="system"
        )
        session.add(waiver)
        
    await session.commit()

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    users_to_notify = await user_requests.get_users_for_event_notification(session, event)
    user_ids_to_notify = {u.id for u in users_to_notify}

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    if expected_in_list:
        assert user.id in user_ids_to_notify, f"User {user.id} should be in the list but was NOT"
    else:
        assert user.id not in user_ids_to_notify, f"User {user.id} should NOT be in the list but was"
        
        
async def test_admin_create_manual_waiver(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ¼.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    admin = User(phone_number="+1", telegram_id=101, full_name="Admin", university="TestUni")
    user = User(phone_number="+2", telegram_id=102, full_name="User", university="TestUni")
    session.add_all([admin, user])
    await session.commit()
    
    end_date = datetime.date.today() + datetime.timedelta(days=30)
    
    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    await admin_requests.create_manual_waiver(session, user_id=user.id, end_date=end_date, reason="Manual by admin", admin_id=admin.id)
    
    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one_or_none()
    
    assert waiver is not None
    assert waiver.user_id == user.id
    assert waiver.reason == "Manual by admin"
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ID Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ° Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ»ÑÑ ĞºĞ°Ğº ÑÑ‚Ñ€Ğ¾ĞºĞ°
    assert waiver.created_by == str(admin.id)
    
    
async def test_create_event_with_datetime(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ñ Ğ´Ğ°Ñ‚Ğ¾Ğ¹ Ğ¸ Ğ²Ñ€ĞµĞ¼ĞµĞ½ĞµĞ¼ Ğ¸ Ğ¸Ñ… ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ.
    """
    event_dt = datetime.datetime(2030, 11, 25, 15, 30)
    event_data = {
        "name": "Event with Time",
        "event_datetime": event_dt,
        "location": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜",
        "donation_type": "platelets",
        "points_per_donation": 200,
        "participant_limit": 20,
    }

    new_event = await admin_requests.create_event(session, event_data)
    await session.commit()

    retrieved_event = await session.get(Event, new_event.id)
    assert retrieved_event is not None
    assert retrieved_event.name == "Event with Time"
    assert retrieved_event.event_datetime == event_dt
    
    
async def test_update_info_text(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ñ€ÑĞ¼Ğ¾Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞºÑÑ‚Ğ° Ğ¸Ğ½Ñ„Ğ¾-Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ° Ñ‡ĞµÑ€ĞµĞ· DB-Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    section_key = "test_section"
    original_text = "This is the original text."
    new_text = "This is the updated text."
    
    session.add(InfoText(
        section_key=section_key, 
        section_title="Test Section", 
        section_text=original_text
    ))
    await session.commit()
    
    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    await info_requests.update_info_text(session, section_key, new_text)
    
    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    updated_section = await session.get(InfoText, section_key)
    assert updated_section is not None
    assert updated_section.section_text == new_text

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_db_requests.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_filters.py ---

import pytest
from unittest.mock import Mock
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db.models import User
from bot.filters.role import RoleFilter

# ĞœĞ°Ñ€ĞºĞ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑĞµ Ñ‚ĞµÑÑ‚Ñ‹ Ğ² ÑÑ‚Ğ¾Ğ¼ Ñ„Ğ°Ğ¹Ğ»Ğµ Ğ´Ğ»Ñ pytest-asyncio
pytestmark = pytest.mark.asyncio

# Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ´Ğ¸Ğ¼ "Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºÑƒ" Ğ´Ğ»Ñ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ° CallbackQuery, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ aiogram
class MockUser:
    def __init__(self, id):
        self.id = id

class MockCallback:
    def __init__(self, user_id):
        self.from_user = MockUser(id=user_id)

async def test_role_filter(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ° RoleFilter Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ€Ğ¾Ğ»ĞµĞ¹ Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ².
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°: ÑĞ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğ¼Ğ¸ Ñ€Ğ¾Ğ»ÑĞ¼Ğ¸
    # --- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ğ¾Ğ»Ğµ university ---
    student = User(phone_number="+1", telegram_id=101, full_name="Student", role="student", university="TestUni")
    volunteer = User(phone_number="+2", telegram_id=102, full_name="Volunteer", role="volunteer", university="TestUni")
    admin = User(phone_number="+3", telegram_id=103, full_name="Admin", role="admin", university="TestUni")
    main_admin = User(phone_number="+4", telegram_id=104, full_name="Main Admin", role="main_admin", university="TestUni")
    blocked_admin = User(phone_number="+5", telegram_id=105, full_name="Blocked Admin", role="admin", is_blocked=True, university="TestUni")
    # --- ĞšĞĞĞ•Ğ¦ Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ¯ ---

    session.add_all([student, volunteer, admin, main_admin, blocked_admin])
    await session.commit()

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    
    # --- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº "admin" ÑƒÑ€Ğ¾Ğ²Ğ½Ñ ---
    admin_filter = RoleFilter(required_role="admin")
    
    # Ğ¡Ñ‚ÑƒĞ´ĞµĞ½Ñ‚ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸
    assert not await admin_filter(MockCallback(user_id=101), session)
    # Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸
    assert not await admin_filter(MockCallback(user_id=102), session)
    # ĞĞ´Ğ¼Ğ¸Ğ½ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸
    assert await admin_filter(MockCallback(user_id=103), session)
    # Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ Ñ‚Ğ¾Ğ¶Ğµ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸ (Ğ¸ĞµÑ€Ğ°Ñ€Ñ…Ğ¸Ñ)
    assert await admin_filter(MockCallback(user_id=104), session)
    # Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸
    assert not await admin_filter(MockCallback(user_id=105), session)
    # ĞĞµÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸
    assert not await admin_filter(MockCallback(user_id=999), session)

    # --- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº "volunteer" ÑƒÑ€Ğ¾Ğ²Ğ½Ñ ---
    volunteer_filter = RoleFilter(required_role="volunteer")
    
    # Ğ¡Ñ‚ÑƒĞ´ĞµĞ½Ñ‚ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸
    assert not await volunteer_filter(MockCallback(user_id=101), session)
    # Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸
    assert await volunteer_filter(MockCallback(user_id=102), session)
    # ĞĞ´Ğ¼Ğ¸Ğ½ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸ (Ğ¸ĞµÑ€Ğ°Ñ€Ñ…Ğ¸Ñ)
    assert await volunteer_filter(MockCallback(user_id=103), session)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_filters.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_fsm_unhappy_paths.py ---

import pytest
from unittest.mock import AsyncMock, Mock

from sqlalchemy.ext.asyncio import AsyncSession
from bot.states.states import EventCreation
from bot.handlers.admin import event_management as event_handlers
from bot.handlers import common as common_handlers
from bot.utils.text_messages import Text

pytestmark = pytest.mark.asyncio

# --- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ Ğ¼Ğ¾ĞºĞ¸ Ğ¸Ğ· Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ ĞºĞ¾Ğ½ÑĞ¸ÑÑ‚ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚Ğ¸ ---

class MockMessage:
    def __init__(self, text=None, from_user_id=1, command=None):
        self.text = text
        self.from_user = Mock(id=from_user_id)
        self.answer = AsyncMock()
        self.delete = AsyncMock()
        # Ğ”Ğ»Ñ FSM /cancel
        self.bot = Mock(id=1)
        self.chat = Mock(id=1)

class MockCallbackQuery:
    def __init__(self, data, from_user_id=1, message=None):
        self.data = data
        self.from_user = Mock(id=from_user_id)
        self.message = message or MockMessage(from_user_id=from_user_id)
        setattr(self.message, 'edit_text', AsyncMock())
        self.answer = AsyncMock()

class MockFSMContext:
    def __init__(self):
        self._state = None
        self._data = {}
    async def get_state(self): return self._state
    async def set_state(self, state): self._state = state
    async def get_data(self): return self._data.copy()
    async def update_data(self, **kwargs): self._data.update(kwargs)
    async def clear(self):
        self._state = None
        self._data = {}

# --- Ğ¢ĞµÑÑ‚Ñ‹ ---

async def test_event_creation_fsm_invalid_date(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚: ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ²Ğ²Ğ¾Ğ´Ğ¸Ñ‚ Ñ‚ĞµĞºÑÑ‚ "Ğ·Ğ°Ğ²Ñ‚Ñ€Ğ°" Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ´Ğ°Ñ‚Ñ‹ Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ.
    ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ñ‹Ğ¹ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: Ğ‘Ğ¾Ñ‚ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¾Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ°, ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ FSM Ğ½Ğµ Ğ¼ĞµĞ½ÑĞµÑ‚ÑÑ.
    """
    state = MockFSMContext()
    await state.set_state(EventCreation.awaiting_datetime) # Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ FSM Ğ² Ğ½ÑƒĞ¶Ğ½Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ

    message = MockMessage(text="Ğ·Ğ°Ğ²Ñ‚Ñ€Ğ°")
    
    await event_handlers.process_event_datetime(message, state)

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ½Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»Ğ¾ÑÑŒ
    assert await state.get_state() == EventCreation.awaiting_datetime
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ±Ğ¾Ñ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ» ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ
    message.answer.assert_called_once_with(Text.DATE_FORMAT_ERROR, parse_mode="HTML")

async def test_event_creation_fsm_invalid_limit(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚: ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ²Ğ²Ğ¾Ğ´Ğ¸Ñ‚ Ñ‚ĞµĞºÑÑ‚ "ÑÑ‚Ğ¾" Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ñ‡Ğ¸ÑĞ»Ğ° Ğ´Ğ»Ñ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ° ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ².
    ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ñ‹Ğ¹ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: Ğ‘Ğ¾Ñ‚ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¾Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ°, ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ FSM Ğ½Ğµ Ğ¼ĞµĞ½ÑĞµÑ‚ÑÑ.
    """
    state = MockFSMContext()
    await state.set_state(EventCreation.awaiting_limit)
    await state.update_data(
        name="Test",
        event_datetime="2030-01-01T10:00:00",
        location="Test", latitude=0.0, longitude=0.0,
        donation_type="test", points_per_donation=100
    )

    message = MockMessage(text="ÑÑ‚Ğ¾")

    await event_handlers.process_event_limit(message, state, session)
    
    assert await state.get_state() == EventCreation.awaiting_limit
    message.answer.assert_called_once_with(Text.EVENT_LIMIT_NAN_ERROR)

async def test_fsm_cancel_command(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚: ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ /cancel Ğ² ÑĞµÑ€ĞµĞ´Ğ¸Ğ½Ğµ FSM.
    ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ñ‹Ğ¹ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ FSM ÑĞ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµÑ‚ÑÑ, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ÑÑ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ.
    """
    state = MockFSMContext()
    await state.set_state(EventCreation.awaiting_name)

    # ĞœĞ¾ĞºĞ°ĞµĞ¼ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼ÑƒÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ Ğ´Ğ»Ñ Ñ…ĞµĞ½Ğ´Ğ»ĞµÑ€Ğ°
    message = MockMessage(text="/cancel")
    message.answer = AsyncMock()
    # common_handlers.send_or_edit_main_menu Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ñƒ message Ğ±ÑƒĞ´ĞµÑ‚ message
    setattr(message, 'message', message)
    
    # ĞœĞ¾ĞºĞ°ĞµĞ¼ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµĞ½Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ·Ğ¾Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚ĞµÑÑ‚
    common_handlers.send_or_edit_main_menu = AsyncMock()

    await common_handlers.cancel_fsm_handler(message, state, session)
    
    assert await state.get_state() is None
    message.answer.assert_called_once_with(Text.ACTION_CANCELLED)
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ±Ñ‹Ğ»Ğ° Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ° Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµĞ½Ñ
    common_handlers.send_or_edit_main_menu.assert_called_once()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_fsm_unhappy_paths.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_graduation.py ---

import pytest
from bot.utils.graduation import calculate_graduation_year

@pytest.mark.parametrize(
    "group, expected_year",
    [
        ("Ğ‘20-505", 2024),
        ("Ğ¡20-2131", 2025),
        ("Ğœ22-1232", 2024),
        ("b20-505", 2024),
        ("c20-2131", 2025),
        ("m22-1232", 2024),
        ("asdf", None),
        (None, None),
        ("", None),
    ],
)
def test_calculate_graduation_year(group, expected_year):
    assert calculate_graduation_year(group) == expected_year

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_graduation.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_handlers_logic.py ---

import pytest
from unittest.mock import AsyncMock, Mock
import datetime

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram import Bot, types
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage

from bot.db.models import User, Event, MedicalWaiver, Feedback
from bot.states.states import Registration, EventCreation, PointsChange, FeedbackSurvey
from bot.handlers import common as common_handlers
from bot.handlers.admin import event_management
from bot.handlers.admin import user_management as user_management_handlers
from bot.handlers import student as student_handlers
from bot.keyboards import inline
from bot.utils.text_messages import Text

pytestmark = pytest.mark.asyncio

class MockMessage:
    """ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ğ¸Ñ€ÑƒĞµĞ¼Ğ°Ñ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ° Ğ´Ğ»Ñ Message, Ğ½Ğµ Ğ½Ğ°ÑĞ»ĞµĞ´ÑƒĞµÑ‚ÑÑ Ğ¾Ñ‚ Mock."""
    def __init__(self, text=None, from_user_id=123, from_user_username=None, location=None, contact=None):
        self.text = text
        self.from_user = Mock(id=from_user_id, username=from_user_username)
        self.location = location
        self.contact = contact
        self.message_id = 12345
        self.reply_markup = None
        # Ğ¯Ğ²Ğ½Ğ¾ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ²ÑĞµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½Ñ‹
        self.answer = AsyncMock()
        self.edit_text = AsyncMock()
        self.delete = AsyncMock()
        self.answer_photo = AsyncMock()
        self.answer_document = AsyncMock()
        self.edit_reply_markup = AsyncMock()

class MockCallbackQuery:
    """ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ğ¸Ñ€ÑƒĞµĞ¼Ğ°Ñ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ° Ğ´Ğ»Ñ CallbackQuery."""
    def __init__(self, data, from_user_id=123, from_user_username=None, message=None):
        self.data = data
        self.from_user = Mock(id=from_user_id, username=from_user_username)
        self.message = message if message else MockMessage(from_user_id=from_user_id)
        self.answer = AsyncMock()

class MockFSMContext:
    """Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ° Ğ´Ğ»Ñ FSMContext, Ñ…Ñ€Ğ°Ğ½ÑÑ‰Ğ°Ñ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ² ÑĞ»Ğ¾Ğ²Ğ°Ñ€Ğµ"""
    def __init__(self):
        self._state = None
        self._data = {}
    async def get_state(self): return self._state
    async def set_state(self, state): self._state = state
    async def get_data(self): return self._data.copy()
    async def update_data(self, **kwargs): self._data.update(kwargs)
    async def clear(self):
        self._state = None
        self._data = {}

class MockLocation:
    """Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ° Ğ´Ğ»Ñ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ° Location aiogram"""
    def __init__(self, latitude, longitude):
        self.latitude = latitude
        self.longitude = longitude





async def test_add_points_to_user(session: AsyncSession, mocker):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ±Ğ°Ğ»Ğ»Ğ¾Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ¼, Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ.
    """
    mock_bot = Mock()
    mock_bot.send_message = AsyncMock()

    user = User(phone_number="+1", telegram_id=101, full_name="User For Points", points=100, university="TestUni")
    session.add(user)
    await session.commit()

    state = MockFSMContext()
    await state.set_state(PointsChange.awaiting_reason)
    await state.update_data(user_id=user.id, points=50)

    msg_reason = MockMessage("Ğ—Ğ° Ñ…Ğ¾Ñ€Ğ¾ÑˆÑƒÑ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ")
    await user_management_handlers.change_points_reason(msg_reason, state, session, mock_bot)

    await session.refresh(user)
    assert user.points == 150

    mock_bot.send_message.assert_called_once()
    call_args = mock_bot.send_message.call_args
    assert call_args.kwargs['chat_id'] == user.telegram_id
    assert "Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ» Ğ²Ğ°Ñˆ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ½Ğ° 50" in call_args.kwargs['text']
    assert call_args.kwargs['parse_mode'] == "HTML"


async def test_user_receives_location_link_on_registration(session: AsyncSession, mocker):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ĞºĞ»Ğ¸ĞºĞ°Ğ±ĞµĞ»ÑŒĞ½ÑƒÑ ÑÑÑ‹Ğ»ĞºÑƒ Ğ½Ğ° Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ
    Ğ² ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¸ Ğ¿Ğ¾ÑĞ»Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¹ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ° Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ°Ğ¼Ğ¸.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    mock_callback_message = MockMessage()
    mock_callback_message.edit_text = AsyncMock()

    user = User(phone_number="+1", telegram_id=101, full_name="Location User", university="TestUni")
    event = Event(
        name="Event With Coords",
        event_datetime=datetime.datetime.now() + datetime.timedelta(days=5),
        location="ĞœĞ¾ÑĞºĞ²Ğ°, ÑƒĞ». ĞŸÑƒÑˆĞºĞ¸Ğ½Ğ°, Ğ´. ĞšĞ¾Ğ»Ğ¾Ñ‚ÑƒÑˆĞºĞ¸Ğ½Ğ°",
        latitude=55.123,
        longitude=37.456,
        donation_type="plasma",
        points_per_donation=1,
        participant_limit=10,
        registration_is_open=True
    )
    session.add_all([user, event])
    await session.commit()

    callback = MockCallbackQuery(
        data=f"reg_event_{event.id}",
        from_user_id=user.telegram_id,
        message=mock_callback_message
    )

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    await student_handlers.process_event_registration(callback, session)

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    mock_callback_message.edit_text.assert_called_once()
    call_args = mock_callback_message.edit_text.call_args.kwargs
    sent_text = call_args['text']

    expected_link_part = f'href="https://yandex.ru/maps/?pt={event.longitude},{event.latitude}&z=18&l=map"'
    assert expected_link_part in sent_text

    assert ">ĞœĞ¾ÑĞºĞ²Ğ°, ÑƒĞ». ĞŸÑƒÑˆĞºĞ¸Ğ½Ğ°, Ğ´. ĞšĞ¾Ğ»Ğ¾Ñ‚ÑƒÑˆĞºĞ¸Ğ½Ğ°</a>" in sent_text
    assert call_args['parse_mode'] == "HTML"


async def test_add_to_calendar_handler(session: AsyncSession, mocker):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ñ…ĞµĞ½Ğ´Ğ»ĞµÑ€ 'add_to_calendar' ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾ Ñ„Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ .ics Ñ„Ğ°Ğ¹Ğ».
    """
    user = User(phone_number="+987", telegram_id=987, full_name="Calendar User", university="Test")
    event = Event(
        name="Calendar Event",
        event_datetime=datetime.datetime.now(),
        location="Test Location",
        donation_type="blood", points_per_donation=1, participant_limit=1
    )
    session.add_all([user, event])
    await session.commit()

    mock_message = MockMessage()
    mock_message.answer_document = AsyncMock()

    callback = MockCallbackQuery(
        data=f"add_to_calendar_{event.id}",
        from_user_id=user.telegram_id,
        message=mock_message
    )

    await student_handlers.send_calendar_file(callback, session)

    mock_message.answer_document.assert_called_once()

    call_args = mock_message.answer_document.call_args.kwargs
    document = call_args['document']

    assert "ĞšĞ°Ğ»ĞµĞ½Ğ´Ğ°Ñ€Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»" in call_args['caption']
    assert f"event_{event.id}.ics" == document.filename

    mock_bot = Mock(spec=Bot)

    file_chunks = []
    async for chunk in document.read(bot=mock_bot):
        file_chunks.append(chunk)

    file_content_bytes = b"".join(file_chunks)
    file_content = file_content_bytes.decode('utf-8')

    assert "BEGIN:VCALENDAR" in file_content
    assert "SUMMARY:Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ: Calendar Event" in file_content

async def test_feedback_survey_fsm_full_pass(session: AsyncSession, mocker):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ»Ğ½ÑƒÑ Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºÑƒ FSM Ğ¾Ğ¿Ñ€Ğ¾ÑĞ° Ñ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸ĞµĞ¼ Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ»ĞµĞ¹.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    user = User(phone_number="+1", telegram_id=101, full_name="Feedback User", university="TestUni")
    session.add(user)
    await session.commit()

    state = MockFSMContext()
    await state.set_state(FeedbackSurvey.awaiting_well_being)
    await state.update_data(event_id=1, donation_id=1)

    mock_message_to_edit = MockMessage()

    # 2. ĞŸÑ€Ğ¾Ñ…Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ FSM
    # Ğ¨Ğ°Ğ³ 1: ĞÑ†ĞµĞ½ĞºĞ° ÑĞ°Ğ¼Ğ¾Ñ‡ÑƒĞ²ÑÑ‚Ğ²Ğ¸Ñ
    cb_wb = MockCallbackQuery(data="fb_wb_5", from_user_id=user.telegram_id, message=mock_message_to_edit)
    await student_handlers.process_well_being(cb_wb, state)
    assert await state.get_state() == FeedbackSurvey.awaiting_organization_score

    # Ğ¨Ğ°Ğ³ 2: ĞÑ†ĞµĞ½ĞºĞ° Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
    cb_org = MockCallbackQuery(data="fb_org_9", from_user_id=user.telegram_id, message=mock_message_to_edit)
    await student_handlers.process_org_score(cb_org, state)
    assert await state.get_state() == FeedbackSurvey.awaiting_what_liked

    # Ğ¨Ğ°Ğ³ 3: Ğ§Ñ‚Ğ¾ Ğ¿Ğ¾Ğ½Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ÑÑŒ (Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼)
    msg_liked = MockMessage(text="Ğ’ĞºÑƒÑĞ½Ñ‹Ğ¹ Ñ‡Ğ°Ğ¹", from_user_id=user.telegram_id)
    await student_handlers.process_what_liked(msg_liked, state)
    assert await state.get_state() == FeedbackSurvey.awaiting_what_disliked

    # Ğ¨Ğ°Ğ³ 4: Ğ§Ñ‚Ğ¾ Ğ½Ğµ Ğ¿Ğ¾Ğ½Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ÑÑŒ (Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼)
    cb_skip_disliked = MockCallbackQuery(data="fb_skip_step", from_user_id=user.telegram_id, message=mock_message_to_edit)
    await student_handlers.process_what_disliked(cb_skip_disliked, state)
    assert await state.get_state() == FeedbackSurvey.awaiting_other_suggestions

    # Ğ¨Ğ°Ğ³ 5: ĞŸÑ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ (Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼)
    msg_suggestions = MockMessage(text="Ğ”Ğ°Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ¿ĞµÑ‡ĞµĞ½ÑŒÑ", from_user_id=user.telegram_id)
    await student_handlers.process_other_suggestions(msg_suggestions, state, session)

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    assert await state.get_state() is None

    feedback_entry = (await session.execute(select(Feedback))).scalar_one_or_none()
    assert feedback_entry is not None
    assert feedback_entry.user_id == user.id
    assert feedback_entry.event_id == 1
    assert feedback_entry.well_being_score == 5
    assert feedback_entry.well_being_comment is None
    assert feedback_entry.organization_score == 9
    assert feedback_entry.what_liked == "Ğ’ĞºÑƒÑĞ½Ñ‹Ğ¹ Ñ‡Ğ°Ğ¹"
    assert feedback_entry.what_disliked == "ĞŸÑ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ¾"
    assert feedback_entry.other_suggestions == "Ğ”Ğ°Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ¿ĞµÑ‡ĞµĞ½ÑŒÑ"

async def test_admin_can_view_feedback(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ¾Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ¼.
    """
    admin = User(phone_number="+0", telegram_id=100, full_name="Admin", university="TestUni")
    user1 = User(phone_number="+1", telegram_id=101, full_name="User One", university="TestUni")
    event = Event(name="Event With Feedback", event_datetime=datetime.datetime.now(), location="Loc", donation_type="d", points_per_donation=1, participant_limit=1)
    session.add_all([admin, user1, event])
    await session.commit()

    fb1 = Feedback(user_id=user1.id, event_id=event.id, organization_score=10, what_liked="Ğ’ÑÑ‘")
    session.add(fb1)
    await session.commit()

    mock_message = MockMessage()
    callback = MockCallbackQuery(data=f"admin_view_feedback_{event.id}", from_user_id=admin.telegram_id, message=mock_message)

    await event_management.view_event_feedback(callback, session)

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ±Ñ‹Ğ»Ğ¾ Ğ¾Ñ‚Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾
    mock_message.answer.assert_called_once()

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ Ğ¾Ñ‚Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
    call_args = mock_message.answer.call_args
    sent_text = call_args.args[0]

    assert "ĞÑ‚Ğ·Ñ‹Ğ²Ñ‹ Ğ¿Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ" in sent_text
    assert "Event With Feedback" in sent_text
    assert "User One" in sent_text
    assert "Ğ’ÑÑ‘" in sent_text

@pytest.mark.asyncio
async def test_process_category_external_donor():
    # Arrange
    storage = MemoryStorage()
    state = FSMContext(storage, key=Mock(bot_id=1, chat_id=1, user_id=1))

    message = Mock(
        edit_text=AsyncMock()
    )
    callback = Mock(
        data="category_external",
        message=message,
        answer=AsyncMock()
    )

    # Act
    await common_handlers.process_category(callback, state)

    # Assert
    data = await state.get_data()
    assert data['category'] == 'external'
    assert data['university'] == 'Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğ¹ Ğ´Ğ¾Ğ½Ğ¾Ñ€'
    assert data['faculty'] == 'ĞĞµ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ğ¼Ğ¾'
    assert data['study_group'] == '-'

    current_state = await state.get_state()
    assert current_state == Registration.awaiting_gender

    message.edit_text.assert_called_once_with(
        Text.GET_GENDER,
        reply_markup=inline.get_gender_inline_keyboard()
    )
    callback.answer.assert_called_once()

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_handlers_logic.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_keyboards.py ---

import pytest
from bot.keyboards import inline

def get_button_texts(keyboard):
    """Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ñ Ñ‚ĞµĞºÑÑ‚Ğ° ÑĞ¾ Ğ²ÑĞµÑ… ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº."""
    return [button.text for row in keyboard.inline_keyboard for button in row]

def test_get_student_main_menu():
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ² Ğ¼ĞµĞ½Ñ ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚Ğ° ĞµÑÑ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸, Ğ² Ñ‚.Ñ‡. Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°."""
    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: ĞĞ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚
    student_keyboard = inline.get_student_main_menu(viewer_role='student')
    student_buttons = get_button_texts(student_keyboard)
    
    assert "ğŸ“… Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ" in student_buttons
    assert "ğŸ ĞœĞ°Ğ³Ğ°Ğ·Ğ¸Ğ½ Ğ¼ĞµÑ€Ñ‡Ğ°" in student_buttons
    assert "âš™ï¸ Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ" not in student_buttons

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 2: ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ¼ĞµĞ½Ñ ĞºĞ°Ğº ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚
    admin_keyboard = inline.get_student_main_menu(viewer_role='admin')
    admin_buttons = get_button_texts(admin_keyboard)

    assert "ğŸ“… Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ" in admin_buttons
    assert "â­ ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°" in admin_buttons
    assert "âš™ï¸ Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ" in admin_buttons

def test_get_admin_panel_keyboard():
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ñƒ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ° ĞµÑÑ‚ÑŒ ĞºĞ½Ğ¾Ğ¿ĞºĞ° ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ°, Ğ° Ñƒ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾Ğ³Ğ¾ - Ğ½ĞµÑ‚."""
    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: ĞĞ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½
    admin_keyboard = inline.get_admin_panel_keyboard(viewer_role='admin')
    admin_buttons = get_button_texts(admin_keyboard)
    
    assert "ğŸ‘¥ Ğ£Ğ¿Ñ€. Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸" in admin_buttons
    assert "ğŸ’¾ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…" not in admin_buttons

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 2: Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½
    main_admin_keyboard = inline.get_admin_panel_keyboard(viewer_role='main_admin')
    main_admin_buttons = get_button_texts(main_admin_keyboard)

    assert "ğŸ‘¥ Ğ£Ğ¿Ñ€. Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸" in main_admin_buttons
    assert "ğŸ’¾ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…" in main_admin_buttons

def test_get_user_management_keyboard_permissions():
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼
    Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ñ€Ğ¾Ğ»ĞµĞ¹ ÑĞ¼Ğ¾Ñ‚Ñ€ÑÑ‰ĞµĞ³Ğ¾ Ğ¸ Ñ†ĞµĞ»Ğ¸.
    """
    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ½Ğ° Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾Ğ³Ğ¾ ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚Ğ°
    kbd1 = inline.get_user_management_keyboard(
        target_user_id=1, target_user_role='student', viewer_role='main_admin', is_blocked=False
    )
    btn1 = get_button_texts(kbd1)
    assert "ğŸ‘‘â• ĞĞ°Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ¼" in btn1
    assert "ğŸš« Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ" in btn1
    assert "ğŸ‘‘â– Ğ Ğ°Ğ·Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°" not in btn1

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 2: Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ½Ğ° Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°
    kbd2 = inline.get_user_management_keyboard(
        target_user_id=1, target_user_role='admin', viewer_role='main_admin', is_blocked=False
    )
    btn2 = get_button_texts(kbd2)
    assert "ğŸ‘‘â– Ğ Ğ°Ğ·Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°" in btn2
    assert "ğŸ‘‘â• ĞĞ°Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ¼" not in btn2

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 3: ĞĞ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ½Ğ° Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ° (Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°Ğ¼Ğ¸/Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°Ğ¼Ğ¸)
    kbd3 = inline.get_user_management_keyboard(
        target_user_id=1, target_user_role='volunteer', viewer_role='admin', is_blocked=False
    )
    btn3 = get_button_texts(kbd3)
    assert "ğŸ§‘â€ğŸ“ Ğ¡Ğ½ÑÑ‚ÑŒ Ñ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°" in btn3
    assert "ğŸ‘‘â• ĞĞ°Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ¼" not in btn3
    assert "ğŸš« Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ" not in btn3
    
    
def test_admin_panel_keyboard_for_admin():
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ Ğ²Ğ¸Ğ´Ğ¸Ñ‚ ÑĞ²Ğ¾Ñ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ‘Ğ•Ğ— ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ°.
    """
    keyboard = inline.get_admin_panel_keyboard(viewer_role='admin')
    
    # ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ² Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº callback_data Ğ´Ğ»Ñ ÑƒĞ´Ğ¾Ğ±ÑÑ‚Ğ²Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
    callbacks = []
    for row in keyboard.inline_keyboard:
        for button in row:
            callbacks.append(button.callback_data)

    assert "admin_manage_users" in callbacks
    assert "ma_export_data" not in callbacks # Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°

def test_admin_panel_keyboard_for_main_admin():
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ Ğ²Ğ¸Ğ´Ğ¸Ñ‚ ÑĞ²Ğ¾Ñ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ¡ ĞºĞ½Ğ¾Ğ¿ĞºĞ¾Ğ¹ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ°.
    """
    keyboard = inline.get_admin_panel_keyboard(viewer_role='main_admin')
    
    callbacks = []
    for row in keyboard.inline_keyboard:
        for button in row:
            callbacks.append(button.callback_data)

    assert "admin_manage_users" in callbacks
    assert "ma_export_data" in callbacks # Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°

def test_user_management_keyboard_roles():
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ€Ğ¾Ğ»ÑĞ¼Ğ¸ Ğ¸ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ Ğ¿Ğ¾ÑĞ²Ğ»ÑÑÑ‚ÑÑ/Ğ¸ÑÑ‡ĞµĞ·Ğ°ÑÑ‚ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾.
    """
    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ½Ğ° Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°
    kb1 = inline.get_user_management_keyboard(
        target_user_id=1, target_user_role='admin', viewer_role='main_admin', is_blocked=False
    )
    cb1 = {b.callback_data for r in kb1.inline_keyboard for b in r}
    assert "ma_demote_admin_1" in cb1
    assert "ma_promote_admin_1" not in cb1
    assert "ma_block_user_1" in cb1

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 2: Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ½Ğ° Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ°
    kb2 = inline.get_user_management_keyboard(
        target_user_id=2, target_user_role='volunteer', viewer_role='main_admin', is_blocked=False
    )
    cb2 = {b.callback_data for r in kb2.inline_keyboard for b in r}
    assert "ma_promote_admin_2" in cb2
    assert "admin_demote_volunteer_2" in cb2

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 3: ĞĞ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ Ğ°Ğ´Ğ¼Ğ¸Ğ½ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ Ğ½Ğ° Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ğ° (Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ²Ğ¸Ğ´ĞµÑ‚ÑŒ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ³Ğ». Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°)
    kb3 = inline.get_user_management_keyboard(
        target_user_id=3, target_user_role='volunteer', viewer_role='admin', is_blocked=False
    )
    cb3 = {b.callback_data for r in kb3.inline_keyboard for b in r}
    assert "ma_promote_admin_3" not in cb3
    assert "ma_block_user_3" not in cb3
    assert "admin_demote_volunteer_3" in cb3

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_keyboards.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_mailing_logic.py ---

# tests/test_mailing_logic.py

import pytest
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db.models import User
from bot.db import user_requests, admin_requests

# ĞœĞ°Ñ€ĞºĞ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑĞµ Ñ‚ĞµÑÑ‚Ñ‹ Ğ² ÑÑ‚Ğ¾Ğ¼ Ñ„Ğ°Ğ¹Ğ»Ğµ Ğ´Ğ»Ñ pytest-asyncio
pytestmark = pytest.mark.asyncio

# Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
users_data = [
    # ... (Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹) ...
    {"id": 1, "university": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", "faculty": "Ğ˜Ğ˜ĞšĞ¡", "role": "student"},
    {"id": 2, "university": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", "faculty": "Ğ˜Ğ˜ĞšĞ¡", "role": "student"},
    {"id": 3, "university": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", "faculty": "Ğ˜Ğ¤Ğ˜Ğ‘", "role": "volunteer"},
    {"id": 4, "university": "ĞœĞ“Ğ£", "faculty": "Ğ’ĞœĞš", "role": "student"},
    {"id": 5, "university": "ĞœĞ“Ğ£", "faculty": "Ğ’ĞœĞš", "role": "admin"},
    {"id": 6, "university": "Ğ”Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ’Ğ£Ğ—", "faculty": None, "role": "student"},
    {"id": 7, "university": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜", "faculty": "ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ", "role": "main_admin"},
]

# --- Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ• Ğ¤Ğ˜ĞšĞ¡Ğ¢Ğ£Ğ Ğ« ---
@pytest.fixture(scope="function", autouse=True)
async def setup_users(session: AsyncSession):
    """
    Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ¿ĞµÑ€ĞµĞ´ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ¼ Ğ² ÑÑ‚Ğ¾Ğ¼ Ñ„Ğ°Ğ¹Ğ»Ğµ.
    Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¸Ğ¼ĞµĞµÑ‚ scope="function" Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ñƒ session.
    """
    users_to_add = [
        User(
            id=u["id"], phone_number=f"+{u['id']}", telegram_id=u["id"],
            full_name=f"User {u['id']}", university=u["university"],
            faculty=u.get("faculty"), role=u.get("role")
        ) for u in users_data
    ]
    session.add_all(users_to_add)
    await session.commit()
    yield # ĞŸĞµÑ€ĞµĞ´Ğ°ĞµĞ¼ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ñƒ
# --- ĞšĞĞĞ•Ğ¦ Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™ Ğ’ Ğ¤Ğ˜ĞšĞ¡Ğ¢Ğ£Ğ Ğ• ---


@pytest.mark.parametrize(
    "filters, expected_user_ids",
    [
        # --- ĞŸĞ ĞĞ¡Ğ¢Ğ«Ğ• Ğ¤Ğ˜Ğ›Ğ¬Ğ¢Ğ Ğ« ---
        ({}, {1, 2, 3, 4, 5, 6, 7}), # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ 'all' Ğ¸Ğ»Ğ¸ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ -> Ğ²ÑĞµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸
        ({"role": "all"}, {1, 2, 3, 4, 5, 6, 7}),
        ({"university": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜"}, {1, 2, 3, 7}),
        ({"faculty": "Ğ˜Ğ˜ĞšĞ¡"}, {1, 2}),
        
        # --- Ğ ĞĞ›Ğ•Ğ’Ğ«Ğ• Ğ¤Ğ˜Ğ›Ğ¬Ğ¢Ğ Ğ« ---
        ({"role": "volunteers"}, {3, 5, 7}), # volunteer, admin, main_admin
        ({"role": "admins"}, {5, 7}), # admin, main_admin
        
        # --- ĞšĞĞœĞŸĞ›Ğ•ĞšĞ¡ĞĞ«Ğ• Ğ¤Ğ˜Ğ›Ğ¬Ğ¢Ğ Ğ« Ğ¡ Ğ ĞĞ›Ğ¯ĞœĞ˜ ---
        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ñ‹ Ğ¸Ğ· ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜
        ({"role": "volunteers", "university": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜"}, {3, 7}),

        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 3: Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€Ñ‹ Ñ Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ğ° Ğ’ĞœĞš -> Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ 5 (Ñ‚.Ğº. Ğ°Ğ´Ğ¼Ğ¸Ğ½ - Ñ‚Ğ¾Ğ¶Ğµ Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€)
        ({"role": "volunteers", "faculty": "Ğ’ĞœĞš"}, {5}),

        # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 5: ĞĞ´Ğ¼Ğ¸Ğ½Ñ‹ Ğ¸Ğ· ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜
        ({"role": "admins", "university": "ĞĞ˜Ğ¯Ğ£ ĞœĞ˜Ğ¤Ğ˜"}, {7}),
    ]
)
# --- Ğ’ĞĞ–ĞĞ: Ğ£Ğ‘Ğ˜Ğ ĞĞ•Ğœ session Ğ˜Ğ— ĞŸĞĞ ĞĞœĞ•Ğ¢Ğ ĞĞ’ Ğ¢Ğ•Ğ¡Ğ¢Ğ, Ğ¢.Ğš. ĞĞ ĞĞ• Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ•Ğ¢Ğ¡Ğ¯ ĞĞĞŸĞ Ğ¯ĞœĞ£Ğ®, Ğ ĞĞ£Ğ–Ğ•Ğ Ğ¤Ğ˜ĞšĞ¡Ğ¢Ğ£Ğ Ğ• ---
async def test_get_users_for_mailing_complex_with_roles(session: AsyncSession, filters, expected_user_ids):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ñ ĞºĞ¾Ğ¼Ğ¿Ğ»ĞµĞºÑĞ½Ñ‹Ğ¼Ğ¸ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ğ¼Ğ¸, Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Ñ€Ğ¾Ğ»Ğ¸.
    """
    # Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° setup_users ÑƒĞ¶Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ğ»Ğ°ÑÑŒ Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ»Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    users = await user_requests.get_users_for_mailing(session, filters)
    actual_user_ids = {user.id for user in users}
    assert actual_user_ids == expected_user_ids

# Ğ­Ñ‚Ğ¾Ñ‚ Ñ‚ĞµÑÑ‚ Ñ‚Ğ°ĞºĞ¶Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ñƒ setup_users
async def test_get_distinct_faculties(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ñ„Ğ°ĞºÑƒĞ»ÑŒÑ‚ĞµÑ‚Ğ¾Ğ², Ğ¸ÑĞºĞ»ÑÑ‡Ğ°Ñ None."""
    faculties = await admin_requests.get_distinct_faculties(session)
    assert sorted(faculties) == ["ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ", "Ğ’ĞœĞš", "Ğ˜Ğ˜ĞšĞ¡", "Ğ˜Ğ¤Ğ˜Ğ‘"]

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_mailing_logic.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_middlewares.py ---

# tests/test_middlewares.py

import pytest
from unittest.mock import AsyncMock, Mock

from sqlalchemy.ext.asyncio import AsyncSession
# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Message, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞµĞ³Ğ¾ ĞºĞ°Ğº ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Mock
from aiogram.types import Message, CallbackQuery 

from bot.db.models import User
from bot.middlewares.block import BlockUserMiddleware
from bot.middlewares.db import DbSessionMiddleware

# ĞŸĞ¾Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ñ‚ĞµÑÑ‚Ñ‹ ĞºĞ°Ğº Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ
pytestmark = pytest.mark.asyncio


# --- Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ ---

@pytest.fixture
async def blocked_user(session: AsyncSession) -> User:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Ğ‘Ğ”."""
    user = User(
        phone_number="+7-blocked", telegram_id=9001, full_name="Blocked User",
        university="Test", is_blocked=True
    )
    session.add(user)
    await session.commit()
    await session.refresh(user)
    return user

@pytest.fixture
async def active_user(session: AsyncSession) -> User:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ (Ğ½Ğµ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾) Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Ğ‘Ğ”."""
    user = User(
        phone_number="+7-active", telegram_id=9002, full_name="Active User",
        university="Test", is_blocked=False
    )
    session.add(user)
    await session.commit()
    await session.refresh(user)
    return user


# --- Ğ¢ĞµÑÑ‚Ñ‹ Middleware (Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯) ---

async def test_block_middleware_for_blocked_user(session: AsyncSession, blocked_user: User):
    """
    Ğ¢ĞµÑÑ‚: Middleware Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ Ğ´Ğ»Ñ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.
    """
    block_mw = BlockUserMiddleware()
    handler_mock = AsyncMock()
    
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ mock, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ "Ğ¿Ğ¾Ñ…Ğ¾Ğ¶Ğ¸Ğ¼" Ğ½Ğ° Message
    # Ğ¸ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ isinstance(event, Message)
    event = Mock(spec=Message)
    event.from_user = Mock(id=blocked_user.telegram_id)
    event.answer = AsyncMock()

    await block_mw(
        handler=handler_mock, 
        event=event, 
        data={"session": session}
    )
    
    # Ğ¢ĞµĞ¿ĞµÑ€ÑŒ handler Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½
    handler_mock.assert_not_called()
    # Ğ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ
    event.answer.assert_called_once()
    assert "Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹" in event.answer.call_args.args[0]


async def test_block_middleware_for_active_user(session: AsyncSession, active_user: User):
    """
    Ğ¢ĞµÑÑ‚: Middleware Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ Ğ´Ğ»Ñ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ.
    """
    block_mw = BlockUserMiddleware()
    handler_mock = AsyncMock()

    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ‚Ğ¾Ñ‚ Ğ¶Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ mock
    event = Mock(spec=Message)
    event.from_user = Mock(id=active_user.telegram_id)
    event.answer = AsyncMock()
    
    await block_mw(
        handler=handler_mock, 
        event=event, 
        data={"session": session}
    )
    
    # Handler Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½, Ñ‚.Ğº. Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ°ĞºÑ‚Ğ¸Ğ²ĞµĞ½
    handler_mock.assert_called_once()
    # Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ Ğ½Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ÑÑ
    event.answer.assert_not_called()


async def test_block_middleware_for_unregistered_user(session: AsyncSession):
    """
    Ğ¢ĞµÑÑ‚: Middleware Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ³Ğ¾ ĞµÑ‰Ğµ Ğ½ĞµÑ‚ Ğ² Ğ‘Ğ”.
    """
    block_mw = BlockUserMiddleware()
    handler_mock = AsyncMock()
    
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ‚Ğ¾Ñ‚ Ğ¶Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ mock
    event = Mock(spec=Message)
    event.from_user = Mock(id=999999) # ID, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ³Ğ¾ Ğ½ĞµÑ‚ Ğ² Ğ‘Ğ”
    event.answer = AsyncMock()
    
    await block_mw(
        handler=handler_mock, 
        event=event, 
        data={"session": session}
    )
    
    # Handler Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½, Ñ‚.Ğº. Ğ½ĞµĞ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½
    handler_mock.assert_called_once()
    event.answer.assert_not_called()


async def test_db_middleware_adds_session(session_pool):  # <--- Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ• Ğ—Ğ”Ğ•Ğ¡Ğ¬
    """
    Ğ¢ĞµÑÑ‚ Ğ´Ğ»Ñ DbSessionMiddleware: Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ¾Ğ½ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞµÑÑĞ¸Ñ Ğ² Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ.
    """
    # session_maker Ğ·Ğ°Ğ¼ĞµĞ½ĞµĞ½ Ğ½Ğ° session_pool
    db_mw = DbSessionMiddleware(session_pool=session_pool)  # <--- Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ• Ğ—Ğ”Ğ•Ğ¡Ğ¬
    handler_mock = AsyncMock()
    event = Mock()
    data = {}

    await db_mw(handler=handler_mock, event=event, data=data)

    handler_mock.assert_called_once()
    data_passed_to_handler = handler_mock.call_args.args[1]
    assert 'session' in data_passed_to_handler
    assert isinstance(data_passed_to_handler['session'], AsyncSession)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_middlewares.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_registration_logic.py ---

import pytest
import pytest_asyncio
import datetime
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession

from bot.db.models import Base, User, Event, EventRegistration, Donation, MedicalWaiver
from bot.db.event_requests import check_registration_eligibility, add_event_registration
from bot.db.models import Event as DbEvent # Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ»Ğ¸ĞºÑ‚Ğ° Ğ¸Ğ¼ĞµĞ½

# --- ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ¹ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ ---

TEST_DATABASE_URL = "sqlite+aiosqlite:///file:memdb1?mode=memory&cache=shared&uri=true"
test_engine = create_async_engine(TEST_DATABASE_URL, echo=False)
test_async_session_maker = async_sessionmaker(test_engine, class_=AsyncSession, expire_on_commit=False)

@pytest_asyncio.fixture(scope="function")
async def db_session() -> AsyncSession:
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    async with test_async_session_maker() as session:
        yield session
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

# --- Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ---

@pytest_asyncio.fixture
async def male_user(db_session: AsyncSession) -> User:
    user = User(
        phone_number="+79991112233",
        telegram_id=1,
        full_name="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ĞœÑƒĞ¶Ñ‡Ğ¸Ğ½Ğ°",
        gender="male",
        university="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ’Ğ£Ğ—"  # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
    )
    db_session.add(user)
    await db_session.commit()
    return user

@pytest_asyncio.fixture
async def female_user(db_session: AsyncSession) -> User:
    user = User(
        phone_number="+79994445566",
        telegram_id=2,
        full_name="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ–ĞµĞ½Ñ‰Ğ¸Ğ½Ğ°",
        gender="female",
        university="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ’Ğ£Ğ—" # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
    )
    db_session.add(user)
    await db_session.commit()
    return user

# --- Ğ¢ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸ ---

@pytest.mark.asyncio
async def test_successful_registration(db_session: AsyncSession, male_user: User):
    """Ğ¢ĞµÑÑ‚: Ğ£ÑĞ¿ĞµÑˆĞ½Ğ°Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²Ğ¸Ğ¸ ĞºĞ¾Ğ½Ñ„Ğ»Ğ¸ĞºÑ‚Ğ¾Ğ²."""
    event_date = datetime.date.today() + datetime.timedelta(days=10)
    event = DbEvent(  # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ¯Ğ²Ğ½Ğ¾Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸
        name="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ",
        event_datetime=datetime.datetime.combine(event_date, datetime.time(10, 0)), # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        donation_type="whole_blood",
        participant_limit=10,
        location="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ",
        points_per_donation=100
    )
    db_session.add(event)
    await db_session.commit()

    is_eligible, reason = await check_registration_eligibility(db_session, male_user, event)
    
    assert is_eligible is True
    assert reason == "Ğ’ÑĞµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ñ‹."

@pytest.mark.asyncio
async def test_blocked_by_potential_waiver(db_session: AsyncSession, male_user: User):
    """
    Ğ¢ĞµÑÑ‚: Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¸Ğ·-Ğ·Ğ° ĞŸĞĞ¢Ğ•ĞĞ¦Ğ˜ĞĞ›Ğ¬ĞĞĞ“Ğ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ° Ğ¾Ñ‚ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞ¹ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸.
    """
    event_A_date = datetime.date.today() + datetime.timedelta(days=10)
    event_B_date = datetime.date.today() + datetime.timedelta(days=15)
    
    event_A = DbEvent(
        name="Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ",
        event_datetime=datetime.datetime.combine(event_A_date, datetime.time(10, 0)), # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        donation_type="whole_blood",
        participant_limit=10,
        location="Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ",
        points_per_donation=100
    )
    event_B = DbEvent(
        name="Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ‘",
        event_datetime=datetime.datetime.combine(event_B_date, datetime.time(10, 0)), # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        donation_type="plasma",
        participant_limit=10,
        location="Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ‘",
        points_per_donation=50
    )
    db_session.add_all([event_A, event_B])
    await db_session.commit()
    
    await add_event_registration(db_session, male_user.id, event_A.id)

    is_eligible, reason = await check_registration_eligibility(db_session, male_user, event_B)
    
    assert is_eligible is False
    assert "Ğ·Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ" in reason
    assert "Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ" in reason

@pytest.mark.asyncio
async def test_not_blocked_if_waiver_ends(db_session: AsyncSession, male_user: User):
    """
    Ğ¢ĞµÑÑ‚: Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ°, ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ñ‚ĞµĞ½Ñ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ñ‚ÑÑ.
    """
    event_A_date = datetime.date.today() + datetime.timedelta(days=10)
    event_C_date = datetime.date.today() + datetime.timedelta(days=80)

    event_A = DbEvent(
        name="Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ",
        event_datetime=datetime.datetime.combine(event_A_date, datetime.time(10, 0)), # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        donation_type="whole_blood",
        participant_limit=10,
        location="Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ",
        points_per_donation=100
    )
    event_C = DbEvent(
        name="Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ¡",
        event_datetime=datetime.datetime.combine(event_C_date, datetime.time(10, 0)), # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        donation_type="plasma",
        participant_limit=10,
        location="Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ C",
        points_per_donation=50
    )
    db_session.add_all([event_A, event_C])
    await db_session.commit()
    
    await add_event_registration(db_session, male_user.id, event_A.id)

    is_eligible, reason = await check_registration_eligibility(db_session, male_user, event_C)
    
    assert is_eligible is True

@pytest.mark.asyncio
async def test_blocked_by_yearly_limit_combined(db_session: AsyncSession, female_user: User):
    """
    Ğ¢ĞµÑÑ‚: Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¸Ğ·-Ğ·Ğ° Ğ³Ğ¾Ğ´Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ°, ÑƒÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ñ Ğ¿Ñ€Ğ¾ÑˆĞ»Ñ‹Ğµ Ğ¸ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸.
    """
    # 2 Ğ¿Ñ€Ğ¾ÑˆĞ»Ñ‹Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸
    db_session.add_all([
        Donation(user_id=female_user.id, donation_date=datetime.date.today() - datetime.timedelta(days=200), donation_type="whole_blood", points_awarded=10),
        Donation(user_id=female_user.id, donation_date=datetime.date.today() - datetime.timedelta(days=300), donation_type="whole_blood", points_awarded=10)
    ])

    # 1 Ğ±ÑƒĞ´ÑƒÑ‰Ğ°Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ (Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ â„–3)
    future_event_1_date = datetime.date.today() + datetime.timedelta(days=20)
    future_event_1 = DbEvent(
        name="Ğ‘ÑƒĞ´ÑƒÑ‰Ğ°Ñ 1", event_datetime=datetime.datetime.combine(future_event_1_date, datetime.time(10,0)), # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        donation_type="whole_blood", participant_limit=10, location="Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ 1", points_per_donation=100
    )
    db_session.add(future_event_1)
    await db_session.commit()
    await add_event_registration(db_session, female_user.id, future_event_1.id)

    # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ÑÑ Ğ½Ğ° 4-Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ. Ğ”Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾.
    event_ok_date = datetime.date.today() + datetime.timedelta(days=120)
    event_to_register_ok = DbEvent(
        name="Ğ‘ÑƒĞ´ÑƒÑ‰Ğ°Ñ 2 (OK)", event_datetime=datetime.datetime.combine(event_ok_date, datetime.time(10,0)), # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        donation_type="whole_blood", participant_limit=10, location="Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ 2", points_per_donation=100
    )
    db_session.add(event_to_register_ok)
    await db_session.commit()

    is_eligible, reason = await check_registration_eligibility(db_session, female_user, event_to_register_ok)
    assert is_eligible is True, f"Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° 4-Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ğ»Ğ° Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸. ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° Ğ¾Ñ‚ĞºĞ°Ğ·Ğ°: {reason}"
    
    await add_event_registration(db_session, female_user.id, event_to_register_ok.id)

    # ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° 5-Ñ. Ğ”Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚ĞºĞ°Ğ· Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ Ğ¿Ğ¾ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğµ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ°.
    event_fail_date = datetime.date.today() + datetime.timedelta(days=220)
    event_to_register_fail = DbEvent(
        name="Ğ‘ÑƒĞ´ÑƒÑ‰Ğ°Ñ 3 (FAIL)", event_datetime=datetime.datetime.combine(event_fail_date, datetime.time(10,0)), # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        donation_type="whole_blood", participant_limit=10, location="Ğ›Ğ¾ĞºĞ°Ñ†Ğ¸Ñ 3", points_per_donation=100
    )
    db_session.add(event_to_register_fail)
    await db_session.commit()

    is_eligible_fail, reason_fail = await check_registration_eligibility(db_session, female_user, event_to_register_fail)
    
    assert is_eligible_fail is False
    assert "Ğ³Ğ¾Ğ´Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ°" in reason_fail, f"ĞĞ¶Ğ¸Ğ´Ğ°Ğ»Ğ°ÑÑŒ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ°, Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾: '{reason_fail}'"

@pytest.mark.asyncio
async def test_yearly_limit_not_blocked_by_other_type(db_session: AsyncSession, male_user: User):
    """
    Ğ¢ĞµÑÑ‚: Ğ“Ğ¾Ğ´Ğ¾Ğ²Ğ¾Ğ¹ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ, ĞµÑĞ»Ğ¸ Ñ‚Ğ¸Ğ¿Ñ‹ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¹ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ.
    """
    for i in range(5):
         db_session.add(Donation(user_id=male_user.id, donation_date=datetime.date.today() - datetime.timedelta(days=30*(i+1)), donation_type="plasma", points_awarded=10))
    await db_session.commit()

    blood_event_date = datetime.date.today() + datetime.timedelta(days=10)
    blood_event = DbEvent(
        name="Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ ĞºÑ€Ğ¾Ğ²Ğ¸",
        event_datetime=datetime.datetime.combine(blood_event_date, datetime.time(10,0)), # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
        donation_type="whole_blood",
        participant_limit=10,
        location="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ",
        points_per_donation=100
    )
    db_session.add(blood_event)
    await db_session.commit()

    is_eligible, reason = await check_registration_eligibility(db_session, male_user, blood_event)

    assert is_eligible is True

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_registration_logic.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_scheduler_config.py ---

from unittest.mock import Mock, patch
from bot.utils.scheduler import setup_scheduler

def test_setup_scheduler_adds_all_jobs():
    """
    Ğ¢ĞµÑÑ‚: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ setup_scheduler Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ
    ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°Ğ´Ğ°Ñ‡ Ñ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ñ‹Ğ¼Ğ¸ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼Ğ¸.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°: ĞœĞ¾ĞºĞ°ĞµĞ¼ AsyncIOScheduler Ğ¸ ĞµĞ³Ğ¾ Ğ¼ĞµÑ‚Ğ¾Ğ´ add_job
    with patch('bot.utils.scheduler.AsyncIOScheduler') as mock_scheduler_class:
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ Ğ¼Ğ¾ĞºĞ°, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ±ÑƒĞ´ĞµÑ‚ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ñ‚ÑŒÑÑ Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğµ AsyncIOScheduler()
        mock_scheduler_instance = mock_scheduler_class.return_value
        mock_scheduler_instance.add_job = Mock()

        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¼Ğ¾ĞºĞ¸ Ğ´Ğ»Ñ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
        mock_bot = Mock()
        mock_session_pool = Mock()
        mock_storage = Mock()

        # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ: Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ÑƒÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ
        scheduler = setup_scheduler(mock_bot, mock_session_pool, mock_storage)

        # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ° Ğ±Ñ‹Ğ» ÑĞ¾Ğ·Ğ´Ğ°Ğ½
        mock_scheduler_class.assert_called_once_with(timezone="Europe/Moscow")
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ scheduler.start() Ğ±Ñ‹Ğ» Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½ (Ñ…Ğ¾Ñ‚Ñ Ğ² setup Ğ¾Ğ½ Ğ½Ğµ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ, Ğ½Ğ¾ ÑÑ‚Ğ¾ Ñ…Ğ¾Ñ€Ğ¾ÑˆĞ°Ñ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ°)
        # Ğ’ Ğ²Ğ°ÑˆĞµĞ¼ ĞºĞ¾Ğ´Ğµ start() Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ ÑĞ½Ğ°Ñ€ÑƒĞ¶Ğ¸, Ñ‚Ğ°Ğº Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾Ñ‚ assert Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½
        # mock_scheduler_instance.start.assert_called_once()
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°Ğ´Ğ°Ñ‡
        # Ğ’ Ğ²Ğ°ÑˆĞµĞ¼ ĞºĞ¾Ğ´Ğµ 9 Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ² add_job
        assert mock_scheduler_instance.add_job.call_count == 9

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ¸Ğ· ĞºĞ»ÑÑ‡ĞµĞ²Ñ‹Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ÑÑ‚ĞµÑ‡ĞµĞ½Ğ¸Ñ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ²)
        found_waiver_job_call = False
        for call in mock_scheduler_instance.add_job.call_args_list:
            # call.args - Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹, call.kwargs - Ğ¸Ğ¼ĞµĞ½Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ
            func_arg = call.args[0]
            if func_arg.__name__ == "check_waiver_expirations":
                found_waiver_job_call = True
                assert call.kwargs['trigger'] == 'cron'
                assert call.kwargs['hour'] == 9
                assert call.kwargs['minute'] == 0
                break
        
        assert found_waiver_job_call, "Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° check_waiver_expirations Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ° Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ² Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº"
        
        # ĞĞ½Ğ°Ğ»Ğ¾Ğ³Ğ¸Ñ‡Ğ½Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ´Ğ»Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ²Ğ°Ğ¶Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡
        found_feedback_job_call = False
        for call in mock_scheduler_instance.add_job.call_args_list:
            if call.args[0].__name__ == "send_post_donation_feedback":
                found_feedback_job_call = True
                assert call.kwargs['hour'] == 11
                break
        
        assert found_feedback_job_call, "Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ° send_post_donation_feedback Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ° Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ°"

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_scheduler_config.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_scheduler_logic.py ---

import pytest
import datetime
from unittest.mock import AsyncMock, Mock
from aiogram import Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from sqlalchemy.ext.asyncio import AsyncSession

from bot.utils.scheduler import send_reminders_for_interval, send_post_donation_feedback
from bot.db.models import User, Event, EventRegistration, Donation
from bot.states.states import FeedbackSurvey
from bot.utils.text_messages import Text
from bot.keyboards import inline

pytestmark = pytest.mark.asyncio

@pytest.mark.parametrize(
    "time_delta_to_event, check_interval, check_window, expected_text_template, should_be_called",
    [
        (datetime.timedelta(days=7), datetime.timedelta(days=7), datetime.timedelta(days=1), Text.REMINDER_WEEK, True),
        (datetime.timedelta(days=2), datetime.timedelta(days=2), datetime.timedelta(days=1), Text.REMINDER_2_DAYS, True),
        (datetime.timedelta(hours=2), datetime.timedelta(hours=2), datetime.timedelta(hours=1), Text.REMINDER_2_HOURS, True),
        (datetime.timedelta(days=3), datetime.timedelta(days=2), datetime.timedelta(days=1), None, False),
        (datetime.timedelta(days=8), datetime.timedelta(days=7), datetime.timedelta(days=1), None, False),
        (datetime.timedelta(hours=3), datetime.timedelta(hours=2), datetime.timedelta(hours=1), None, False),
        (datetime.timedelta(days=-1), datetime.timedelta(days=2), datetime.timedelta(days=1), None, False),
    ]
)
async def test_send_event_reminders_multi_interval(
    session: AsyncSession,
    session_pool,
    mocker,
    time_delta_to_event,
    check_interval,
    check_window,
    expected_text_template,
    should_be_called
):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºÑƒ Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğ¹ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ¾Ğ².
    """
    fixed_now = datetime.datetime(2024, 1, 1, 12, 0, 0)
    mocker.patch('datetime.datetime', Mock(now=lambda: fixed_now))

    mock_send_message = mocker.patch('aiogram.Bot.send_message', new_callable=AsyncMock)
    mock_bot = Mock(spec=Bot)
    mock_bot.send_message = mock_send_message

    user = User(phone_number="+1", telegram_id=101, full_name="UserToRemind", university="TestUni")
    event_time = fixed_now + time_delta_to_event
    event = Event(name="Test-Event", event_datetime=event_time, location="Test Location", donation_type="plasma", points_per_donation=10, participant_limit=5, is_active=True)
    session.add_all([user, event])
    await session.commit()
    registration = EventRegistration(user_id=user.id, event_id=event.id)
    session.add(registration)
    await session.commit()

    await send_reminders_for_interval(
        bot=mock_bot,
        session_pool=session_pool,  
        time_from_now=check_interval,
        time_window=check_window,
        text_template=expected_text_template or "dummy"
    )
    
    if should_be_called:
        mock_send_message.assert_called_once()
        call_args = mock_send_message.call_args.kwargs
        sent_text = call_args['text']
        
        assert call_args['parse_mode'] == "HTML"
        assert "<b>ĞĞ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğµ" in sent_text or "<b>Ğ”Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ ÑƒĞ¶Ğµ ÑĞºĞ¾Ñ€Ğ¾" in sent_text
        assert "Test-Event" in sent_text
        assert "Test Location" in sent_text
    else:
        mock_send_message.assert_not_called()

async def test_send_post_donation_feedback(session: AsyncSession, session_pool, mocker):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºÑƒ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½ÑƒÑ ÑĞ²ÑĞ·ÑŒ Ğ½Ğ° ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ğ´ĞµĞ½ÑŒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°
    fixed_today = datetime.date(2024, 10, 27)
    fixed_yesterday = fixed_today - datetime.timedelta(days=1)
    fixed_day_before = fixed_today - datetime.timedelta(days=2)
    mocker.patch('datetime.date', Mock(today=lambda: fixed_today))

    mock_send_message = mocker.patch('aiogram.Bot.send_message', new_callable=AsyncMock)
    mock_bot = Mock(spec=Bot)
    mock_bot.send_message = mock_send_message

    user_to_notify = User(phone_number="+1", telegram_id=101, full_name="Feedback User", university="TestUni")
    user_to_ignore_old = User(phone_number="+2", telegram_id=102, full_name="Old Donor", university="TestUni")
    user_to_ignore_duplicate = User(phone_number="+3", telegram_id=103, full_name="Duplicate", university="TestUni")
    session.add_all([user_to_notify, user_to_ignore_old, user_to_ignore_duplicate])
    await session.commit()
    
    donation_to_notify = Donation(user_id=user_to_notify.id, event_id=1, donation_date=fixed_yesterday, donation_type="plasma", points_awarded=1)
    donation_to_ignore_old = Donation(user_id=user_to_ignore_old.id, event_id=2, donation_date=fixed_day_before, donation_type="plasma", points_awarded=1)
    donation_to_ignore_duplicate = Donation(user_id=user_to_ignore_duplicate.id, event_id=3, donation_date=fixed_yesterday, donation_type="plasma", points_awarded=1, feedback_requested=True)
    session.add_all([donation_to_notify, donation_to_ignore_old, donation_to_ignore_duplicate])
    await session.commit()

    # 2. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
    await send_post_donation_feedback(
        bot=mock_bot,
        session_pool=session_pool, 
        storage=MemoryStorage()
    )

    # 3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
    mock_send_message.assert_called_once_with(
        chat_id=user_to_notify.telegram_id,
        text=Text.FEEDBACK_START,
        reply_markup=inline.get_feedback_well_being_keyboard()
    )
    
    await session.refresh(donation_to_notify)
    await session.refresh(donation_to_ignore_old)
    await session.refresh(donation_to_ignore_duplicate)
    
    assert donation_to_notify.feedback_requested is True
    assert donation_to_ignore_old.feedback_requested is False
    assert donation_to_ignore_duplicate.feedback_requested is True

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_scheduler_logic.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_security.py ---

# tests/test_security.py

import pytest
import hmac
import hashlib
import json
from urllib.parse import urlencode
from fastapi import HTTPException

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ÑƒÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¸ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³
from main import validate_telegram_data
from bot.config_reader import config

# --- Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ ---
def generate_test_auth_data(user_data_dict: dict, bot_token: str) -> str:
    """Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½ÑƒÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ initData Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²."""
    
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ json.dumps Ğ´Ğ»Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ¹ ÑĞµÑ€Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Python-ÑĞ»Ğ¾Ğ²Ğ°Ñ€Ñ Ğ² JSON-ÑÑ‚Ñ€Ğ¾ĞºÑƒ.
    # separators ÑƒĞ±Ğ¸Ñ€Ğ°ĞµÑ‚ Ğ»Ğ¸ÑˆĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹, sort_keys Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ¾Ğ´Ğ¸Ğ½Ğ°ĞºĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº ĞºĞ»ÑÑ‡ĞµĞ¹.
    user_data_str = json.dumps(user_data_dict, separators=(',', ':'), sort_keys=True)
    
    # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ñ…ĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ (ĞºÑ€Ğ¾Ğ¼Ğµ ÑĞ°Ğ¼Ğ¾Ğ³Ğ¾ Ñ…ĞµÑˆĞ°)
    data_to_sign = {
        'auth_date': '1700000000',
        'query_id': 'AAg123456789',
        'user': user_data_str
    }
    
    # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸ Ñ„Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ (data_check_string)
    sorted_items = sorted(data_to_sign.items())
    data_check_string = "\n".join([f"{k}={v}" for k, v in sorted_items])
    
    # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ñ…ĞµÑˆ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ñ‚Ğ°Ğº Ğ¶Ğµ, ĞºĞ°Ğº ÑÑ‚Ğ¾ Ğ´ĞµĞ»Ğ°ĞµÑ‚ Telegram
    secret_key = hmac.new("WebAppData".encode(), bot_token.encode(), hashlib.sha256).digest()
    calculated_hash = hmac.new(secret_key, data_check_string.encode(), hashlib.sha256).hexdigest()
    
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ…ĞµÑˆ Ğº Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼ Ğ¸ Ñ„Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½ÑƒÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
    data_to_sign['hash'] = calculated_hash
    
    return urlencode(data_to_sign)


# --- Ğ¢ĞµÑÑ‚Ñ‹ ---

def test_validate_telegram_data_success():
    """Ğ¢ĞµÑÑ‚ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¹ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸."""
    bot_token = config.bot_token.get_secret_value()
    user_data = {
        "id": 12345678,
        "first_name": "John",
        "last_name": "Doe",
        "username": "johndoe",
        "language_code": "en",
        "is_premium": True
    }
    
    auth_string = generate_test_auth_data(user_data, bot_token)
    
    # Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ
    validated_user_data = validate_telegram_data(auth_string)
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚ Ñ Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
    assert validated_user_data['id'] == user_data['id']
    assert validated_user_data['username'] == user_data['username']
    assert validated_user_data['is_premium'] is True


def test_validate_telegram_data_invalid_hash():
    """Ğ¢ĞµÑÑ‚ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ»Ğ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ğ¸Ğ·-Ğ·Ğ° Ğ½ĞµĞ²ĞµÑ€Ğ½Ğ¾Ğ³Ğ¾ Ñ…ĞµÑˆĞ°."""
    bot_token = config.bot_token.get_secret_value()
    user_data = {"id": 123, "username": "test"}
    
    auth_string = generate_test_auth_data(user_data, bot_token)
    
    # Ğ˜ÑĞºĞ°Ğ¶Ğ°ĞµĞ¼ Ñ…ĞµÑˆ
    tampered_auth_string = auth_string[:-10] + "abcdefghij"
    
    with pytest.raises(HTTPException) as excinfo:
        validate_telegram_data(tampered_auth_string)
        
    assert excinfo.value.status_code == 403
    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ, Ğ° Ğ½Ğµ Ğ¾Ğ±Ñ‰ĞµĞµ
    assert "Invalid hash" in str(excinfo.value.detail)


def test_validate_telegram_data_missing_hash():
    """Ğ¢ĞµÑÑ‚ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ»Ğ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ğ¸Ğ·-Ğ·Ğ° Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²Ğ¸Ñ Ñ…ĞµÑˆĞ°."""
    auth_string = "user=%7B%22id%22%3A+123%7D&auth_date=1700000000"
    
    with pytest.raises(HTTPException) as excinfo:
        validate_telegram_data(auth_string)
        
    assert excinfo.value.status_code == 403
    assert "Hash not found" in str(excinfo.value.detail)


def test_validate_telegram_data_tampered_data():
    """Ğ¢ĞµÑÑ‚ Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ»Ğ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸, ĞµÑĞ»Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ±Ñ‹Ğ»Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ñ‹ Ğ±ĞµĞ· Ğ¿ĞµÑ€ĞµÑÑ‡ĞµÑ‚Ğ° Ñ…ĞµÑˆĞ°."""
    bot_token = config.bot_token.get_secret_value()
    user_data = {"id": 123}
    
    auth_string = generate_test_auth_data(user_data, bot_token)
    
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ½Ğµ ÑƒÑ‡Ğ°ÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ» Ğ² Ñ…ĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸
    tampered_auth_string = auth_string + "&new_param=hacker"
    
    with pytest.raises(HTTPException) as excinfo:
        validate_telegram_data(tampered_auth_string)
        
    assert excinfo.value.status_code == 403
    assert "Invalid hash" in str(excinfo.value.detail)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_security.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_survey_logic.py ---

# Ğ¤ĞĞ™Ğ›: tests/test_survey_logic.py

import pytest
import datetime
from unittest.mock import AsyncMock, Mock

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

# ĞœÑ‹ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ process_survey_rules Ğ¸Ğ· main, Ñ‚Ğ°Ğº Ñ‡Ñ‚Ğ¾ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ñ‚Ñ‚ÑƒĞ´Ğ°
from main import process_survey_rules, SurveyAnswers
# Ğ Ğ²Ğ¾Ñ‚ submit_survey_logic Ğ¼Ñ‹ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾-Ğ½Ğ¾Ğ²Ğ¾Ğ¼Ñƒ
from main import submit_survey_logic, SurveyPayload 
from bot.db.models import User, Survey, MedicalWaiver, UserBlock

# ĞœĞ°Ñ€ĞºĞ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑĞµ Ñ‚ĞµÑÑ‚Ñ‹ Ğ² ÑÑ‚Ğ¾Ğ¼ Ñ„Ğ°Ğ¹Ğ»Ğµ Ğ´Ğ»Ñ pytest-asyncio
pytestmark = pytest.mark.asyncio

# Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ½Ğ°Ğ±Ğ¾Ñ€ "Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²Ñ‹Ñ…" Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¾Ğ², ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸
full_healthy_answers = {
    "age": "yes",
    "weight": "yes",
    "health_issues_last_month": "no",
    "symptoms": "no",
    "pressure": "ok",
    "hemoglobin_level": "ok",
    "diet_followed": "yes",
    "alcohol_last_48h": "no",
    "medication_last_72h": "no",
    "sleep_last_night": "yes",
    "smoking_last_hour": "no",
    "tattoo_or_piercing": "no",
    "tooth_removal_last_10_days": "no",
    "antibiotics_last_2_weeks": "no",
    "analgesics_last_3_days": "no",
    "has_hiv_or_hepatitis": "no",
    "has_cancer_or_blood_disease": "no",
    "has_chronic_disease": "no",
}

# --- Ğ¢ĞµÑÑ‚ 1: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° "Ğ´Ğ²Ğ¸Ğ¶ĞºĞ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»" ---
@pytest.mark.parametrize("modified_answer, user_gender, expected_status, expected_days, expected_reason_part", [
    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ "OK"
    ({}, "male", "ok", 0, "ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹ Ğ½Ğµ Ğ²Ñ‹ÑĞ²Ğ»ĞµĞ½Ğ¾"),
    
    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ²
    ({"age": "no"}, "male", "temp_waiver", 365000, "Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚"),
    ({"weight": "no"}, "male", "temp_waiver", 365000, "Ğ’ĞµÑ Ğ¼ĞµĞ½ĞµĞµ 50 ĞºĞ³"),
    ({"health_issues_last_month": "yes"}, "male", "temp_waiver", 30, "ĞĞ Ğ’Ğ˜"),
    ({"symptoms": "yes"}, "male", "temp_waiver", 30, "ĞĞ Ğ’Ğ˜"),
    ({"tooth_removal_last_10_days": "yes"}, "male", "temp_waiver", 10, "Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ·ÑƒĞ±Ğ°"),
    ({"tattoo_or_piercing": "yes"}, "male", "temp_waiver", 120, "Ñ‚Ğ°Ñ‚ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸/Ğ¿Ğ¸Ñ€ÑĞ¸Ğ½Ğ³Ğ°"),
    ({"antibiotics_last_2_weeks": "yes"}, "male", "temp_waiver", 14, "Ğ°Ğ½Ñ‚Ğ¸Ğ±Ğ¸Ğ¾Ñ‚Ğ¸ĞºĞ¾Ğ²"),
    ({"analgesics_last_3_days": "yes"}, "male", "temp_waiver", 3, "Ğ°Ğ½Ğ°Ğ»ÑŒĞ³ĞµÑ‚Ğ¸ĞºĞ¾Ğ²"),
    ({"medication_last_72h": "yes"}, "male", "temp_waiver", 3, "Ğ»ĞµĞºĞ°Ñ€ÑÑ‚Ğ²"),
    ({"alcohol_last_48h": "yes"}, "male", "temp_waiver", 2, "Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»Ñ"),

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸ "Ğ¼ÑĞ³ĞºĞ¸Ñ…" Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¹ (ÑÑ‚Ğ°Ñ‚ÑƒÑ 'ok')
    ({"diet_followed": "no"}, "male", "ok", 0, "Ğ´Ğ¸ĞµÑ‚Ñ‹"),
    ({"sleep_last_night": "no"}, "male", "ok", 0, "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ ÑĞ¾Ğ½"),
    ({"smoking_last_hour": "yes"}, "male", "ok", 0, "ĞšÑƒÑ€ĞµĞ½Ğ¸Ğµ"),

    # Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹ (Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ½Ğ° 1000 Ğ»ĞµÑ‚)
    ({"has_hiv_or_hepatitis": "yes"}, "male", "temp_waiver", 365000, "ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ"),
    ({"has_cancer_or_blood_disease": "yes"}, "male", "temp_waiver", 365000, "ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ"),
    ({"has_chronic_disease": "yes"}, "male", "temp_waiver", 365000, "ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ"),
])
async def test_process_survey_rules(modified_answer, user_gender, expected_status, expected_days, expected_reason_part):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ´Ğ²Ğ¸Ğ¶Ğ¾Ğº Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ» Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒÑ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…."""
    answers_dict = full_healthy_answers.copy()
    answers_dict.update(modified_answer)
    answers_obj = SurveyAnswers(**answers_dict)
    
    status, days, reason = await process_survey_rules(answers_obj, user_gender)
    
    assert status == expected_status
    assert days == expected_days
    assert expected_reason_part in reason


# --- Ğ¢ĞµÑÑ‚Ñ‹ 2: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸ submit_survey_logic ---

async def create_test_user(session: AsyncSession, tg_id=123, is_blocked=False, gender="male"):
    """Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
    user = User(
        phone_number=f"+{tg_id}", telegram_id=tg_id, full_name="Test User",
        university="Test", is_blocked=is_blocked, gender=gender
    )
    session.add(user)
    await session.commit()
    return user

async def test_api_submit_survey_ok(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑƒÑĞ¿ĞµÑˆĞ½Ñ‹Ğ¹ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹: submit_survey_logic Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ."""
    user = await create_test_user(session)
    answers = SurveyAnswers(**full_healthy_answers) # Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ•Ğœ ĞĞĞ’Ğ«Ğ™ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬
    payload = SurveyPayload(survey_data=answers, auth_string="valid_auth_string")
    
    # ĞœĞ¾ĞºĞ°ĞµĞ¼ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑ‚ÑŒ Ñ…ĞµÑˆĞ¸ Ğ² ÑÑ‚Ğ¾Ğ¼ ÑĞ½Ğ¸Ñ‚-Ñ‚ĞµÑÑ‚Ğµ
    with pytest.MonkeyPatch.context() as m:
        m.setattr("main.validate_telegram_data", lambda auth_data: {'id': user.telegram_id})
        
        # Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
        chat_id, text, markup = await submit_survey_logic(session, payload)

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ² Ğ‘Ğ” Ğ¿Ğ¾ÑĞ²Ğ¸Ğ»Ğ°ÑÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾Ğ± Ğ¾Ğ¿Ñ€Ğ¾ÑĞµ
    survey_record = (await session.execute(select(Survey).where(Survey.user_id == user.id))).scalar_one()
    assert survey_record.passed is True
    assert "ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹ Ğ½Ğµ Ğ²Ñ‹ÑĞ²Ğ»ĞµĞ½Ğ¾" in survey_record.verdict_text
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ½Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ»ÑÑ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one_or_none()
    assert waiver is None
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ²ĞµÑ€Ğ½ÑƒĞ»Ğ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸
    assert chat_id == user.telegram_id
    assert "ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğ¹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾" in text
    assert "Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ ÑĞµĞ¹Ñ‡Ğ°Ñ Ğ½ĞµÑ‚" in text # Ñ‚.Ğº. Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹ Ğ¼Ñ‹ Ğ½Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ğ»Ğ¸
    assert markup is None # ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñ‹ Ğ½ĞµÑ‚, Ñ‚.Ğº. Ğ½ĞµÑ‚ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğ¹

async def test_api_submit_survey_temp_waiver(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ°: submit_survey_logic Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´."""
    user = await create_test_user(session)
    answers_dict = full_healthy_answers.copy()
    answers_dict["symptoms"] = "yes"
    answers = SurveyAnswers(**answers_dict) # Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ•Ğœ ĞĞĞ’Ğ«Ğ™ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬
    payload = SurveyPayload(survey_data=answers, auth_string="valid_auth_string")

    with pytest.MonkeyPatch.context() as m:
        m.setattr("main.validate_telegram_data", lambda auth_data: {'id': user.telegram_id})
        chat_id, text, markup = await submit_survey_logic(session, payload)
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ»ÑÑ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ½Ğ° 30 Ğ´Ğ½ĞµĞ¹
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one()
    expected_end_date = datetime.date.today() + datetime.timedelta(days=30)
    assert waiver is not None
    assert waiver.user_id == user.id
    assert waiver.end_date == expected_end_date
    assert "ĞĞ Ğ’Ğ˜" in waiver.reason
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    assert chat_id == user.telegram_id
    assert "Ğ²Ñ‹ÑĞ²Ğ»ĞµĞ½Ğ¾ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ" in text
    assert expected_end_date.strftime('%d.%m.%Y') in text

async def test_api_submit_survey_perm_waiver_is_now_temp(session: AsyncSession):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ ĞºĞ°Ğº Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ½Ğ° 1000 Ğ»ĞµÑ‚."""
    user = await create_test_user(session)
    answers_dict = full_healthy_answers.copy()
    answers_dict["has_hiv_or_hepatitis"] = "yes"
    answers = SurveyAnswers(**answers_dict) # Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ•Ğœ ĞĞĞ’Ğ«Ğ™ Ğ¡Ğ›ĞĞ’ĞĞ Ğ¬
    payload = SurveyPayload(survey_data=answers, auth_string="valid_auth_string")

    with pytest.MonkeyPatch.context() as m:
        m.setattr("main.validate_telegram_data", lambda auth_data: {'id': user.telegram_id})
        chat_id, text, markup = await submit_survey_logic(session, payload)

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ĞĞ• ÑĞ¾Ğ·Ğ´Ğ°Ğ»Ğ°ÑÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ
    block_record = (await session.execute(select(UserBlock).where(UserBlock.user_id == user.id))).scalar_one_or_none()      
    assert block_record is None

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ĞĞ• Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½
    await session.refresh(user)
    assert user.is_blocked is False

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ»ÑÑ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´ Ğ½Ğ° 365000 Ğ´Ğ½ĞµĞ¹
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one()
    expected_end_date = datetime.date.today() + datetime.timedelta(days=365000)
    assert waiver is not None
    assert "ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ" in waiver.reason
    assert waiver.end_date == expected_end_date

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    assert "ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ğ»Ğ¸ Ğ²Ğ°Ğ¼ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´" in text
    assert expected_end_date.strftime('%d.%m.%Y') in text

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_survey_logic.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_utils.py ---

import pytest
import datetime
from unittest.mock import AsyncMock, Mock, patch

import datetime
from sqlalchemy import select 
from aiogram import Bot

from bot.utils.qr_service import create_secure_payload, verify_secure_payload
from bot.utils.scheduler import check_waiver_expirations
from bot.db.models import User, Event, EventRegistration, MedicalWaiver


# --- Ğ¢ĞµÑÑ‚Ñ‹ QR-ĞºĞ¾Ğ´Ğ¾Ğ² (Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹) ---
def test_qr_payload_creation_and_verification():
    original_data = {"user_id": 12345, "event_id": 678}
    payload = create_secure_payload(original_data)
    verified_data = verify_secure_payload(payload)
    assert isinstance(payload, str)
    assert verified_data is not None
    assert verified_data == original_data

def test_qr_verification_failure_with_bad_hash():
    original_data = {"user_id": 999}
    payload = create_secure_payload(original_data)
    tampered_payload = payload[:-5] + "abcde"
    verified_data = verify_secure_payload(tampered_payload)
    assert verified_data is None

def test_qr_verification_failure_with_bad_format():
    bad_payload = "this_is_not_a_valid_payload"
    verified_data = verify_secure_payload(bad_payload)
    assert verified_data is None


@pytest.mark.asyncio
async def test_check_waiver_expirations(mocker, session_pool): # <-- Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ñƒ session
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºÑƒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹ Ğ¾Ğ± Ğ¸ÑÑ‚ĞµÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ¼ĞµĞ´Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ¾Ğ²."""
    
    fixed_today = datetime.date(2024, 5, 20)
    
    # ĞœĞ¾ĞºĞ¸Ñ€ÑƒĞµĞ¼ `datetime.date` ĞºĞ°Ğº Ğ¸ Ñ€Ğ°Ğ½ÑŒÑˆĞµ
    with patch('bot.utils.scheduler.datetime.date') as mock_date:
        
        mock_date.today.return_value = fixed_today
        yesterday_in_test = fixed_today - datetime.timedelta(days=1)
    
        # --- Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ ÑĞµÑÑĞ¸Ğ¸, ĞºĞ°Ğº ÑÑ‚Ğ¾ ÑĞ´ĞµĞ»Ğ°Ğ»Ğ° Ğ±Ñ‹ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ---
        async with session_pool() as session:
            user_expired = User(phone_number="+7771", telegram_id=7771, full_name="Expired", university="TestUni")
            user_active = User(phone_number="+7772", telegram_id=7772, full_name="Active", university="TestUni")
            session.add_all([user_expired, user_active])
            await session.flush()
    
            waiver_expired = MedicalWaiver(
                user_id=user_expired.id, 
                start_date=yesterday_in_test - datetime.timedelta(days=30),
                end_date=yesterday_in_test,
                reason="test", created_by="system"
            )
            waiver_active = MedicalWaiver(
                user_id=user_active.id,
                start_date=fixed_today - datetime.timedelta(days=10),
                end_date=fixed_today,
                reason="test", created_by="system"
            )
            session.add_all([waiver_expired, waiver_active])
            await session.commit() # Ğ—Ğ´ĞµÑÑŒ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸ÑÑŒ Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¹ ÑĞµÑÑĞ¸Ğ¸

        # ĞĞ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¼Ğ¾ĞºĞ¸ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ°
        mock_send_message = mocker.patch('aiogram.Bot.send_message', new_callable=AsyncMock)
        mock_bot = Mock(spec=Bot)
        mock_bot.send_message = mock_send_message

        # Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ÑƒÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ
        await check_waiver_expirations(mock_bot, session_pool)
    
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
        mock_send_message.assert_called_once()
        call_args = mock_send_message.call_args
        assert call_args.kwargs['chat_id'] == 7771
        
        expected_phrase = "ÑÑ€Ğ¾Ğº Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ¼ĞµĞ´Ğ¸Ñ†Ğ¸Ğ½ÑĞºĞ¾Ğ³Ğ¾ Ğ¾Ñ‚Ğ²Ğ¾Ğ´Ğ° Ğ¸ÑÑ‚ĞµĞº"
        actual_text = call_args.kwargs['text']
        assert expected_phrase.lower() in actual_text.lower()

        # Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°, Ñ‡Ñ‚Ğ¾ Ğ² Ğ‘Ğ” Ğ²ÑĞµ Ñ‡Ğ¸ÑÑ‚Ğ¾ Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ñ‚ĞµÑÑ‚Ğ°
        async with session_pool() as session:
            res = await session.execute(select(User))
            assert len(res.scalars().all()) > 0 # Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ĞµÑÑ‚ÑŒ
    # ĞŸĞ¾ÑĞ»Ğµ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ° Ğ¸Ğ· async with Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° session Ğ² conftest.py Ğ¾Ñ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_utils.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: tests/test_volunteer_fsm.py ---

import pytest
import datetime
from unittest.mock import AsyncMock, Mock

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select 
from aiogram import Bot

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ğµ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸ Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹
from bot.db.models import User, Event, EventRegistration, Donation, MedicalWaiver
from bot.db import event_requests

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¸ Ñ…ĞµĞ½Ğ´Ğ»ĞµÑ€Ñ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ±ÑƒĞ´ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
from bot.states.states import VolunteerActions
from bot.handlers.volunteer import (
    start_qr_confirmation, 
    process_qr_photo, 
    process_donation_confirmation,
    process_qr_invalid_input
)
from bot.utils.text_messages import Text

# ĞŸĞ¾Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ñ‚ĞµÑÑ‚Ñ‹ ĞºĞ°Ğº Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ
pytestmark = pytest.mark.asyncio

# --- Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºĞ»Ğ°ÑÑÑ‹-Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ¸ (Mocks) ---

class MockMessage:
    """Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ° Ğ´Ğ»Ñ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ° Message."""
    def __init__(self, text=None, from_user_id=1, photo=None):
        self.text = text
        self.from_user = Mock(id=from_user_id)
        # Ğ˜Ğ¼Ğ¸Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ F.photo (ÑĞ¿Ğ¸ÑĞ¾Ğº Ñ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¼ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ¼ Ğ»ÑƒÑ‡ÑˆĞµĞ³Ğ¾ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°)
        self.photo = [Mock(file_id="photo_file_id_123")] if photo else None
        self.answer = AsyncMock()
        self.edit_text = AsyncMock()

class MockCallbackQuery:
    """Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ° Ğ´Ğ»Ñ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ° CallbackQuery."""
    def __init__(self, data, from_user_id=1, message=None):
        self.data = data
        self.from_user = Mock(id=from_user_id)
        self.message = message if message else MockMessage(from_user_id=from_user_id)
        self.answer = AsyncMock()

class MockFSMContext:
    """Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ° Ğ´Ğ»Ñ FSMContext."""
    def __init__(self):
        self._state = None
        self._data = {}
    async def get_state(self): return self._state
    async def set_state(self, state): self._state = state
    async def get_data(self): return self._data.copy()
    async def update_data(self, **kwargs): self._data.update(kwargs)
    async def clear(self):
        self._state = None
        self._data = {}

# --- Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ² Ğ‘Ğ” ---

@pytest.fixture
async def volunteer_user(session: AsyncSession) -> User:
    user = User(
        phone_number="+7-volunteer", telegram_id=1001, full_name="Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€ Ğ¢ĞµÑÑ‚Ğ¾Ğ²", 
        role="volunteer", university="TestUni"
    )
    session.add(user)
    await session.commit()
    return user

@pytest.fixture
async def donor_user(session: AsyncSession) -> User:
    user = User(
        phone_number="+7-donor", telegram_id=2002, full_name="Ğ”Ğ¾Ğ½Ğ¾Ñ€ Ğ¢ĞµÑÑ‚Ğ¾Ğ²", 
        role="student", university="TestUni", gender="male", points=0
    )
    session.add(user)
    await session.commit()
    return user

@pytest.fixture
async def today_event(session: AsyncSession) -> Event:
    event = Event(
        name="Ğ¡ĞµĞ³Ğ¾Ğ´Ğ½ÑÑˆĞ½ĞµĞµ ĞœĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ", 
        event_datetime=datetime.datetime.now(), 
        location="Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ", donation_type="whole_blood", 
        points_per_donation=50, participant_limit=10
    )
    session.add(event)
    await session.commit()
    return event

@pytest.fixture
async def future_event(session: AsyncSession) -> Event:
    event = Event(
        name="Ğ‘ÑƒĞ´ÑƒÑ‰ĞµĞµ ĞœĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ", 
        event_datetime=datetime.datetime.now() + datetime.timedelta(days=5), 
        location="Ğ”Ñ€ÑƒĞ³Ğ°Ñ Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ", donation_type="plasma", 
        points_per_donation=20, participant_limit=5
    )
    session.add(event)
    await session.commit()
    return event

@pytest.fixture
async def registration(session: AsyncSession, donor_user: User, today_event: Event) -> EventRegistration:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ° Ğ½Ğ° ÑĞµĞ³Ğ¾Ğ´Ğ½ÑÑˆĞ½ĞµĞµ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ."""
    reg = EventRegistration(user_id=donor_user.id, event_id=today_event.id)
    session.add(reg)
    await session.commit()
    return reg



async def test_volunteer_fsm_happy_path(
    session: AsyncSession, mocker, volunteer_user: User, donor_user: User, today_event: Event, registration: EventRegistration
):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ ÑƒÑĞ¿ĞµÑˆĞ½Ñ‹Ğ¹ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹: Ğ¾Ñ‚ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ QR Ğ´Ğ¾ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸.
    """
    state = MockFSMContext()
    
    # ĞœĞ¾ĞºĞ°ĞµĞ¼ Bot Ğ¸ ĞµĞ³Ğ¾ Ğ¼ĞµÑ‚Ğ¾Ğ´ download, Ñ‚.Ğº. Ğ¼Ñ‹ Ğ½Ğµ Ğ±ÑƒĞ´ĞµĞ¼ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾ ÑĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»
    mock_bot = Mock(spec=Bot)
    mock_bot.download.return_value = AsyncMock(read=AsyncMock(return_value=b'fake_photo_bytes'))

    # ĞœĞ¾ĞºĞ°ĞµĞ¼ `read_qr`, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ğ½ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ» Ğ½ÑƒĞ¶Ğ½Ñ‹Ğµ Ğ½Ğ°Ğ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ±ĞµĞ· Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ QR
    qr_data = {"user_id": donor_user.telegram_id, "event_id": today_event.id}
    mocker.patch('bot.handlers.volunteer.read_qr', new_callable=AsyncMock, return_value=qr_data)
    
    # 2. ACT & ASSERT (Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¸ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°)
    
    # --- Ğ¨Ğ°Ğ³ 1: Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ ---
    callback_start = MockCallbackQuery(data="confirm_donation_qr", from_user_id=volunteer_user.telegram_id)
    await start_qr_confirmation(callback_start, state)
    
    assert await state.get_state() == VolunteerActions.awaiting_qr_photo
    callback_start.message.edit_text.assert_called_once_with(Text.VOLUNTEER_SEND_QR_PROMPT)

    # --- Ğ¨Ğ°Ğ³ 2: Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ñ„Ğ¾Ñ‚Ğ¾ Ñ QR ---
    message_photo = MockMessage(from_user_id=volunteer_user.telegram_id, photo=True)
    await process_qr_photo(message_photo, state, session, mock_bot)

    assert await state.get_state() == VolunteerActions.awaiting_confirmation
    message_photo.answer.assert_called_once()
    
    # --- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ğ—Ğ”Ğ•Ğ¡Ğ¬ ---
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ° mock'Ğ°
    args, kwargs = message_photo.answer.call_args
    # Ğ¢ĞµĞºÑÑ‚ Ğ¿ĞµÑ€ĞµĞ´Ğ°ĞµÑ‚ÑÑ ĞºĞ°Ğº Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚
    sent_text = args[0] 
    
    assert donor_user.full_name in sent_text
    assert today_event.name in sent_text
    assert kwargs['parse_mode'] == "HTML"
    
    # --- Ğ¨Ğ°Ğ³ 3: Ğ’Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´Ğ°ĞµÑ‚ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ñ ---
    callback_confirm = MockCallbackQuery(
        data=f"confirm_donation_{donor_user.id}_{today_event.id}",
        from_user_id=volunteer_user.telegram_id
    )
    await process_donation_confirmation(callback_confirm, state, session, mock_bot)
    
    assert await state.get_state() is None # Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒÑÑ
    callback_confirm.message.edit_text.assert_called_with(
        Text.DONATION_CONFIRM_SUCCESS.format(
            donor_name=donor_user.full_name,
            event_name=today_event.name,
            points=today_event.points_per_donation
        ),
        reply_markup=mocker.ANY, # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ğ° Ğ±Ñ‹Ğ»Ğ°, Ğ½Ğµ Ğ²Ğ°Ğ¶ĞµĞ½ ĞµĞµ Ñ‚Ğ¸Ğ¿
        parse_mode="HTML"
    )

    # --- Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹ Ğ² Ğ‘Ğ” ---
    await session.refresh(donor_user)
    await session.refresh(registration)
    
    assert donor_user.points == today_event.points_per_donation
    
    # Ğ¢ĞµĞ¿ĞµÑ€ÑŒ ÑÑ‚Ğ¾Ñ‚ ĞºĞ¾Ğ´ Ğ±ÑƒĞ´ĞµÑ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ, Ñ‚Ğ°Ğº ĞºĞ°Ğº select Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½
    donation_record_query = await session.execute(
        select(Donation).where(
            Donation.user_id == donor_user.id,
            Donation.event_id == today_event.id
        )
    )
    donation_record = donation_record_query.scalar_one_or_none()
    
    waiver_record_query = await session.execute(
        select(MedicalWaiver).where(MedicalWaiver.user_id == donor_user.id)
    )
    waiver_record = waiver_record_query.scalar_one_or_none()

    assert donation_record is not None
    assert donation_record.user_id == donor_user.id
    
    assert waiver_record is not None
    assert waiver_record.user_id == donor_user.id

# --- Ğ¢ĞµÑÑ‚Ñ‹ "Ğ½ĞµÑÑ‡Ğ°ÑÑ‚Ğ»Ğ¸Ğ²Ñ‹Ñ…" Ğ¿ÑƒÑ‚ĞµĞ¹ ---

async def test_volunteer_fsm_invalid_input(volunteer_user: User):
    """Ğ¢ĞµÑÑ‚: Ğ²Ğ¾Ğ»Ğ¾Ğ½Ñ‚ĞµÑ€ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ñ‚ĞµĞºÑÑ‚ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ñ„Ğ¾Ñ‚Ğ¾."""
    message = MockMessage(text="ÑÑ‚Ğ¾ Ğ½Ğµ Ñ„Ğ¾Ñ‚Ğ¾", from_user_id=volunteer_user.telegram_id)
    await process_qr_invalid_input(message)
    message.answer.assert_called_once_with(Text.VOLUNTEER_INVALID_INPUT_QR)


async def test_volunteer_fsm_qr_read_fails(mocker, session, volunteer_user: User):
    """Ğ¢ĞµÑÑ‚: QR-ĞºĞ¾Ğ´ Ğ½Ğµ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ğ½."""
    state = MockFSMContext()
    mocker.patch('bot.handlers.volunteer.read_qr', new_callable=AsyncMock, return_value=None)
    mock_bot = Mock(spec=Bot)
    mock_bot.download.return_value = AsyncMock(read=AsyncMock(return_value=b''))

    message_photo = MockMessage(from_user_id=volunteer_user.telegram_id, photo=True)
    await process_qr_photo(message_photo, state, session, mock_bot)

    assert await state.get_state() is None # Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ ÑĞ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ¿Ñ€Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞµ
    message_photo.answer.assert_called_once_with(Text.QR_READ_ERROR)


async def test_volunteer_fsm_donor_not_registered(mocker, session, volunteer_user, donor_user, today_event):
    """Ğ¢ĞµÑÑ‚: Ğ”Ğ¾Ğ½Ğ¾Ñ€ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ğ½Ğ° ÑÑ‚Ğ¾ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ."""
    # Ğ’Ğ°Ğ¶Ğ½Ğ¾: Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° 'registration' Ğ·Ğ´ĞµÑÑŒ Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ, Ñ‚.Ğµ. Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ² Ğ‘Ğ” Ğ½ĞµÑ‚
    state = MockFSMContext()
    qr_data = {"user_id": donor_user.telegram_id, "event_id": today_event.id}
    mocker.patch('bot.handlers.volunteer.read_qr', new_callable=AsyncMock, return_value=qr_data)
    mock_bot = Mock(spec=Bot)
    mock_bot.download.return_value = AsyncMock(read=AsyncMock(return_value=b''))

    message_photo = MockMessage(from_user_id=volunteer_user.telegram_id, photo=True)
    await process_qr_photo(message_photo, state, session, mock_bot)

    assert await state.get_state() is None
    message_photo.answer.assert_called_once_with(
        Text.QR_DONOR_NOT_REGISTERED_ERROR.format(donor_name=donor_user.full_name),
        parse_mode="HTML"
    )

async def test_volunteer_fsm_wrong_day(mocker, session, volunteer_user, donor_user, future_event):
    """Ğ¢ĞµÑÑ‚: QR-ĞºĞ¾Ğ´ Ğ¾Ñ‚ Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğµ ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ."""
    state = MockFSMContext()
    # Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ° Ğ½Ğ° Ğ‘Ğ£Ğ”Ğ£Ğ©Ğ•Ğ• Ğ¼ĞµÑ€Ğ¾Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ
    reg = EventRegistration(user_id=donor_user.id, event_id=future_event.id)
    session.add(reg)
    await session.commit()

    qr_data = {"user_id": donor_user.telegram_id, "event_id": future_event.id}
    mocker.patch('bot.handlers.volunteer.read_qr', new_callable=AsyncMock, return_value=qr_data)
    mock_bot = Mock(spec=Bot)
    mock_bot.download.return_value = AsyncMock(read=AsyncMock(return_value=b''))

    message_photo = MockMessage(from_user_id=volunteer_user.telegram_id, photo=True)
    await process_qr_photo(message_photo, state, session, mock_bot)

    assert await state.get_state() is None
    message_photo.answer.assert_called_once_with(Text.QR_WRONG_DAY_ERROR)

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: tests/test_volunteer_fsm.py ---

--- ĞĞĞ§ĞĞ›Ğ Ğ¤ĞĞ™Ğ›Ğ: webapp/index.html ---

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ĞĞ¿Ñ€Ğ¾Ñ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ°</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --tg-theme-bg-color: #ffffff;
            --tg-theme-text-color: #000000;
            --tg-theme-button-color: #007bff;
            --tg-theme-button-text-color: #ffffff;
            --tg-theme-hint-color: #999999;
            --tg-theme-secondary-bg-color: #f4f4f4;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--tg-theme-bg-color);
            color: var(--tg-theme-text-color);
            margin: 0;
            padding: 15px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .container { max-width: 600px; margin: 0 auto; }
        h1 { font-size: 24px; margin-bottom: 20px; text-align: center; }
        .question-block {
            background-color: var(--tg-theme-secondary-bg-color);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .question-block h2 {
            font-size: 18px; margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid var(--tg-theme-hint-color); padding-bottom: 10px;
        }
        .question { margin-bottom: 15px; }
        .question p { margin: 0 0 10px 0; font-weight: 500; font-size: 16px; line-height: 1.4; }
        .options { display: flex; gap: 10px; }
        .options label {
            display: flex; align-items: center; gap: 5px; padding: 10px; border-radius: 8px;
            border: 1px solid var(--tg-theme-hint-color); flex-grow: 1; justify-content: center; cursor: pointer; transition: all 0.2s ease;
        }
        input[type="radio"] { display: none; }
        input[type="radio"]:checked + label {
            background-color: var(--tg-theme-button-color); color: var(--tg-theme-button-text-color); border-color: var(--tg-theme-button-color);
        }
        .content-spacer { height: 80px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ĞĞ¿Ñ€Ğ¾Ñ Ğ¿ĞµÑ€ĞµĞ´ Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸ĞµĞ¹</h1>
        <p style="text-align: center; color: var(--tg-theme-hint-color); margin-top: -15px; margin-bottom: 25px;">ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ğ¹Ñ‚Ğµ Ñ‡ĞµÑÑ‚Ğ½Ğ¾. Ğ­Ñ‚Ğ¾ Ğ²Ğ°Ğ¶Ğ½Ğ¾ Ğ´Ğ»Ñ Ğ²Ğ°ÑˆĞµĞ¹ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸ Ñ€ĞµÑ†Ğ¸Ğ¿Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ².</p>
        
        <form id="survey-form">
            <div class="question-block">
                <h2>ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ</h2>
                <div class="question"> <p>1. Ğ’Ğ°Ğ¼ ĞµÑÑ‚ÑŒ 18 Ğ»ĞµÑ‚?</p> <div class="options"> <input type="radio" id="age-no" name="age" value="no"><label for="age-no">ĞĞµÑ‚</label> <input type="radio" id="age-yes" name="age" value="yes" required><label for="age-yes">Ğ”Ğ°</label> </div> </div>
                <div class="question"> <p>2. Ğ’Ğ°Ñˆ Ğ²ĞµÑ 50 ĞºĞ³ Ğ¸Ğ»Ğ¸ Ğ±Ğ¾Ğ»ĞµĞµ?</p> <div class="options"> <input type="radio" id="weight-no" name="weight" value="no"><label for="weight-no">ĞĞµÑ‚</label> <input type="radio" id="weight-yes" name="weight" value="yes" required><label for="weight-yes">Ğ”Ğ°</label> </div> </div>
            </div>

            <div class="question-block">
                <h2>Ğ’Ğ°ÑˆĞµ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒĞµ</h2>
                <div class="question"> <p>3. Ğ‘Ğ¾Ğ»ĞµĞ»Ğ¸ Ğ»Ğ¸ Ğ’Ñ‹ ĞĞ Ğ’Ğ˜, Ğ³Ñ€Ğ¸Ğ¿Ğ¿Ğ¾Ğ¼ Ğ¸Ğ»Ğ¸ Ğ°Ğ½Ğ³Ğ¸Ğ½Ğ¾Ğ¹ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ¼ĞµÑÑÑ†Ğ°?</p> <div class="options"> <input type="radio" id="health_issues-yes" name="health_issues_last_month" value="yes"><label for="health_issues-yes">Ğ”Ğ°</label> <input type="radio" id="health_issues-no" name="health_issues_last_month" value="no" required><label for="health_issues-no">ĞĞµÑ‚</label> </div> </div>
                <div class="question"> <p>4. Ğ•ÑÑ‚ÑŒ Ğ»Ğ¸ Ñƒ Ğ²Ğ°Ñ ÑĞµĞ¹Ñ‡Ğ°Ñ ÑĞ¸Ğ¼Ğ¿Ñ‚Ğ¾Ğ¼Ñ‹ Ğ¿Ñ€Ğ¾ÑÑ‚ÑƒĞ´Ñ‹ (Ğ½Ğ°ÑĞ¼Ğ¾Ñ€Ğº, ĞºĞ°ÑˆĞµĞ»ÑŒ, Ñ‚ĞµĞ¼Ğ¿ĞµÑ€Ğ°Ñ‚ÑƒÑ€Ğ°, Ğ±Ğ¾Ğ»ÑŒ Ğ² Ğ³Ğ¾Ñ€Ğ»Ğµ)?</p> <div class="options"> <input type="radio" id="symptoms-yes" name="symptoms" value="yes"><label for="symptoms-yes">Ğ”Ğ°</label> <input type="radio" id="symptoms-no" name="symptoms" value="no" required><label for="symptoms-no">ĞĞµÑ‚</label> </div> </div>
                <div class="question"> <p>5. Ğ£Ğ´Ğ°Ğ»ÑĞ»Ğ¸ Ğ»Ğ¸ Ğ’Ğ°Ğ¼ Ğ·ÑƒĞ± Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ñ… 10 Ğ´Ğ½ĞµĞ¹?</p> <div class="options"> <input type="radio" id="tooth-yes" name="tooth_removal_last_10_days" value="yes"><label for="tooth-yes">Ğ”Ğ°</label> <input type="radio" id="tooth-no" name="tooth_removal_last_10_days" value="no" required><label for="tooth-no">ĞĞµÑ‚</label> </div> </div>
            </div>

            <div class="question-block">
                <h2>ĞŸÑ€Ğ¾Ñ†ĞµĞ´ÑƒÑ€Ñ‹ Ğ¸ Ğ»ĞµĞºĞ°Ñ€ÑÑ‚Ğ²Ğ°</h2>
                <div class="question"> <p>7. Ğ”ĞµĞ»Ğ°Ğ»Ğ¸ Ğ»Ğ¸ Ğ’Ñ‹ Ñ‚Ğ°Ñ‚ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºÑƒ, Ğ¿Ğ¸Ñ€ÑĞ¸Ğ½Ğ³ Ğ¸Ğ»Ğ¸ ÑĞ½Ğ´Ğ¾ÑĞºĞ¾Ğ¿Ğ¸Ñ Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 4-12 Ğ¼ĞµÑÑÑ†ĞµĞ²?</p> <div class="options"> <input type="radio" id="tattoo-yes" name="tattoo_or_piercing" value="yes"><label for="tattoo-yes">Ğ”Ğ°</label> <input type="radio" id="tattoo-no" name="tattoo_or_piercing" value="no" required><label for="tattoo-no">ĞĞµÑ‚</label> </div> </div>
                <div class="question"> <p>8. ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ¸ Ğ»Ğ¸ Ğ’Ñ‹ Ğ°Ğ½Ñ‚Ğ¸Ğ±Ğ¸Ğ¾Ñ‚Ğ¸ĞºĞ¸ Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 2 Ğ½ĞµĞ´ĞµĞ»Ğ¸?</p> <div class="options"> <input type="radio" id="antibiotics-yes" name="antibiotics_last_2_weeks" value="yes"><label for="antibiotics-yes">Ğ”Ğ°</label> <input type="radio" id="antibiotics-no" name="antibiotics_last_2_weeks" value="no" required><label for="antibiotics-no">ĞĞµÑ‚</label> </div> </div>
                <div class="question"> <p>9. ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ¸ Ğ»Ğ¸ Ğ’Ñ‹ Ğ°Ğ½Ğ°Ğ»ÑŒĞ³ĞµÑ‚Ğ¸ĞºĞ¸ (Ğ¾Ğ±ĞµĞ·Ğ±Ğ¾Ğ»Ğ¸Ğ²Ğ°ÑÑ‰Ğ¸Ğµ) Ğ¸Ğ»Ğ¸ Ğ°ÑĞ¿Ğ¸Ñ€Ğ¸Ğ½ Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 3 Ğ´Ğ½Ñ?</p> <div class="options"> <input type="radio" id="analgesics-yes" name="analgesics_last_3_days" value="yes"><label for="analgesics-yes">Ğ”Ğ°</label> <input type="radio" id="analgesics-no" name="analgesics_last_3_days" value="no" required><label for="analgesics-no">ĞĞµÑ‚</label> </div> </div>
                 <div class="question"> <p>10. ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ¸ Ğ»Ğ¸ Ğ’Ñ‹ ĞºĞ°ĞºĞ¸Ğµ-Ğ»Ğ¸Ğ±Ğ¾ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ»ĞµĞºĞ°Ñ€ÑÑ‚Ğ²Ğ° Ğ·Ğ° Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 72 Ñ‡Ğ°ÑĞ°?</p> <div class="options"> <input type="radio" id="meds-yes" name="medication_last_72h" value="yes"><label for="meds-yes">Ğ”Ğ°</label> <input type="radio" id="meds-no" name="medication_last_72h" value="no" required><label for="meds-no">ĞĞµÑ‚</label> </div> </div>
            </div>

            <div class="question-block">
                <h2>ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğº Ğ´Ğ¾Ğ½Ğ°Ñ†Ğ¸Ğ¸</h2>
                <div class="question"> <p>11. Ğ¡Ğ¾Ğ±Ğ»ÑĞ´Ğ°Ğ»Ğ¸ Ğ»Ğ¸ Ğ’Ñ‹ Ğ´Ğ¸ĞµÑ‚Ñƒ Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 2-3 Ğ´Ğ½Ñ (Ğ¸ÑĞºĞ»ÑÑ‡Ğ°Ğ»Ğ¸ Ğ¶Ğ¸Ñ€Ğ½Ğ¾Ğµ, Ğ¼Ğ¾Ğ»Ğ¾Ñ‡Ğ½Ğ¾Ğµ, ÑĞ¹Ñ†Ğ°, Ğ¾Ñ€ĞµÑ…Ğ¸)?</p> <div class="options"> <input type="radio" id="diet-no" name="diet_followed" value="no"><label for="diet-no">ĞĞµÑ‚</label> <input type="radio" id="diet-yes" name="diet_followed" value="yes" required><label for="diet-yes">Ğ”Ğ°</label> </div> </div>
                <div class="question"> <p>12. Ğ£Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ»ÑĞ»Ğ¸ Ğ»Ğ¸ Ğ’Ñ‹ Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»ÑŒ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ñ… 48 Ñ‡Ğ°ÑĞ¾Ğ²?</p> <div class="options"> <input type="radio" id="alcohol-yes" name="alcohol_last_48h" value="yes"><label for="alcohol-yes">Ğ”Ğ°</label> <input type="radio" id="alcohol-no" name="alcohol_last_48h" value="no" required><label for="alcohol-no">ĞĞµÑ‚</label> </div> </div>
                <div class="question"> <p>13. Ğ’Ñ‹ ÑĞ¿Ğ°Ğ»Ğ¸ Ğ½Ğµ Ğ¼ĞµĞ½ĞµĞµ 8 Ñ‡Ğ°ÑĞ¾Ğ² Ğ¿Ñ€Ğ¾ÑˆĞ»Ğ¾Ğ¹ Ğ½Ğ¾Ñ‡ÑŒÑ?</p> <div class="options"> <input type="radio" id="sleep-no" name="sleep_last_night" value="no"><label for="sleep-no">ĞĞµÑ‚</label> <input type="radio" id="sleep-yes" name="sleep_last_night" value="yes" required><label for="sleep-yes">Ğ”Ğ°</label> </div> </div>
                <div class="question"> <p>14. ĞšÑƒÑ€Ğ¸Ğ»Ğ¸ Ğ»Ğ¸ Ğ’Ñ‹ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ñ‡Ğ°ÑĞ°?</p> <div class="options"> <input type="radio" id="smoking-yes" name="smoking_last_hour" value="yes"><label for="smoking-yes">Ğ”Ğ°</label> <input type="radio" id="smoking-no" name="smoking_last_hour" value="no" required><label for="smoking-no">ĞĞµÑ‚</label> </div> </div>
            </div>

            <div class="question-block">
                <h2>ĞĞ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ñ</h2>
                <p style="font-size: 14px; color: var(--tg-theme-hint-color); margin-bottom: 15px;">ĞŸĞ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ½Ğ° Ğ»ÑĞ±Ğ¾Ğ¹ Ğ¸Ğ· ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ñ… Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ²Ñ‹ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ±Ñ‹Ñ‚ÑŒ Ğ´Ğ¾Ğ½Ğ¾Ñ€Ğ¾Ğ¼ ĞºÑ€Ğ¾Ğ²Ğ¸.</p>
                <div class="question"> <p>15. Ğ”Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ»Ğ¸ Ñƒ Ğ’Ğ°Ñ Ğ’Ğ˜Ğ§/Ğ¡ĞŸĞ˜Ğ”, ÑĞ¸Ñ„Ğ¸Ğ»Ğ¸Ñ, Ğ²Ğ¸Ñ€ÑƒÑĞ½Ñ‹Ğµ Ğ³ĞµĞ¿Ğ°Ñ‚Ğ¸Ñ‚Ñ‹ B Ğ¸Ğ»Ğ¸ C, Ñ‚ÑƒĞ±ĞµÑ€ĞºÑƒĞ»ĞµĞ·?</p> <div class="options"> <input type="radio" id="hiv-yes" name="has_hiv_or_hepatitis" value="yes"><label for="hiv-yes">Ğ”Ğ°</label> <input type="radio" id="hiv-no" name="has_hiv_or_hepatitis" value="no" required><label for="hiv-no">ĞĞµÑ‚</label> </div> </div>
                <div class="question"> <p>16. Ğ”Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ»Ğ¸ Ñƒ Ğ’Ğ°Ñ Ğ¾Ğ½ĞºĞ¾Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ·Ğ°Ğ±Ğ¾Ğ»ĞµĞ²Ğ°Ğ½Ğ¸Ñ Ğ¸Ğ»Ğ¸ Ğ±Ğ¾Ğ»ĞµĞ·Ğ½Ğ¸ ĞºÑ€Ğ¾Ğ²Ğ¸?</p> <div class="options"> <input type="radio" id="cancer-yes" name="has_cancer_or_blood_disease" value="yes"><label for="cancer-yes">Ğ”Ğ°</label> <input type="radio" id="cancer-no" name="has_cancer_or_blood_disease" value="no" required><label for="cancer-no">ĞĞµÑ‚</label> </div> </div>
                <div class="question"> <p>17. Ğ•ÑÑ‚ÑŒ Ğ»Ğ¸ Ñƒ Ğ’Ğ°Ñ ÑĞµÑ€ÑŒĞµĞ·Ğ½Ñ‹Ğµ Ñ…Ñ€Ğ¾Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ·Ğ°Ğ±Ğ¾Ğ»ĞµĞ²Ğ°Ğ½Ğ¸Ñ (Ğ³Ğ¸Ğ¿ĞµÑ€Ñ‚Ğ¾Ğ½Ğ¸Ñ II-III ÑÑ‚., Ğ¸ÑˆĞµĞ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ±Ğ¾Ğ»ĞµĞ·Ğ½ÑŒ, Ğ±Ñ€Ğ¾Ğ½Ñ…Ğ¸Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ°ÑÑ‚Ğ¼Ğ°, Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ğ¾Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ¦ĞĞ¡)?</p> <div class="options"> <input type="radio" id="chronic-yes" name="has_chronic_disease" value="yes"><label for="chronic-yes">Ğ”Ğ°</label> <input type="radio" id="chronic-no" name="has_chronic_disease" value="no" required><label for="chronic-no">ĞĞµÑ‚</label> </div> </div>
            </div>

            <!-- Ğ¡ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ´Ğ»Ñ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ½Ğµ Ğ·Ğ°Ğ´Ğ°ÑÑ‚ÑÑ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ -->
            <input type="hidden" name="pressure" value="unknown">
            <input type="hidden" name="hemoglobin_level" value="unknown">

            <div class="content-spacer"></div>
        </form>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const tg = window.Telegram.WebApp;
            const form = document.getElementById('survey-form');
            
            const applyTheme = () => {
                document.body.style.setProperty('--tg-theme-bg-color', tg.themeParams.bg_color || '#ffffff');
                document.body.style.setProperty('--tg-theme-text-color', tg.themeParams.text_color || '#000000');
                document.body.style.setProperty('--tg-theme-button-color', tg.themeParams.button_color || '#007bff');
                document.body.style.setProperty('--tg-theme-button-text-color', tg.themeParams.button_text_color || '#ffffff');
                document.body.style.setProperty('--tg-theme-hint-color', tg.themeParams.hint_color || '#999999');
                document.body.style.setProperty('--tg-theme-secondary-bg-color', tg.themeParams.secondary_bg_color || '#f4f4f4');
            };

            const sendData = async () => {
                const authString = tg.initData;
                
                if (!authString) {
                    tg.showAlert('ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ Ğ±Ğ¾Ñ‚Ğ° Ğ¸ Ğ¾Ğ¿Ñ€Ğ¾Ñ.');
                    return;
                }
                
                if (!form.checkValidity()) {
                    tg.showAlert('ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚Ğ²ĞµÑ‚ÑŒÑ‚Ğµ Ğ½Ğ° Ğ²ÑĞµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹.');
                    const firstInvalid = form.querySelector(':invalid');
                    if (firstInvalid) {
                        firstInvalid.closest('.question-block')?.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                    return;
                }

                tg.MainButton.showProgress();
                tg.MainButton.disable();

                const formData = new FormData(form);
                const surveyData = {};
                for (const [key, value] of formData.entries()) {
                    surveyData[key] = value;
                }

                try {
                    const response = await fetch('/api/submit_survey', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            survey_data: surveyData,
                            auth_string: authString
                        })
                    });
                    
                    if (response.ok) {
                        tg.close();
                    } else {
                        const errorData = await response.json();
                        tg.showAlert(`ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ½Ğ° ÑĞµÑ€Ğ²ĞµÑ€Ğµ: ${errorData.detail || 'ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°.'}`, () => {
                            tg.close();
                        });
                    }
                } catch (error) {
                    tg.showAlert('ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞµÑ‚Ğ¸. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ²Ğ°ÑˆĞµ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚-ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°.');
                    tg.MainButton.hideProgress();
                    tg.MainButton.enable();
                }
            };

            tg.ready();
            tg.expand();
            applyTheme();

            
            tg.MainButton.setText('ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ²ĞµÑ‚Ñ‹');
            tg.MainButton.onClick(sendData);
            tg.MainButton.show();
        });
    </script>
</body>
</html>

--- ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ: webapp/index.html ---

