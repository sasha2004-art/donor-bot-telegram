==================== СТРУКТУРА ПРОЕКТА ====================

.
├── Dockerfile
├── README.md
├── all_code.txt
├── bot
│   ├── __init__.py
│   ├── config_reader.py
│   ├── db
│   │   ├── __init__.py
│   │   ├── admin_requests.py
│   │   ├── analytics_requests.py
│   │   ├── engine.py
│   │   ├── event_requests.py
│   │   ├── info_requests.py
│   │   ├── merch_requests.py
│   │   ├── models.py
│   │   ├── qa_management.py
│   │   ├── question_requests.py
│   │   └── user_requests.py
│   ├── filters
│   │   └── role.py
│   ├── handlers
│   │   ├── __init__.py
│   │   ├── admin
│   │   │   ├── __init__.py
│   │   │   ├── analytics.py
│   │   │   ├── event_management.py
│   │   │   ├── info_management.py
│   │   │   ├── mailing.py
│   │   │   ├── merch_management.py
│   │   │   ├── qa_management.py
│   │   │   ├── system.py
│   │   │   └── user_management.py
│   │   ├── common.py
│   │   ├── main_admin.py
│   │   ├── other.py
│   │   ├── student.py
│   │   └── volunteer.py
│   ├── keyboards
│   │   ├── __init__.py
│   │   ├── inline.py
│   │   └── reply.py
│   ├── middlewares
│   │   ├── __init__.py
│   │   ├── block.py
│   │   └── db.py
│   ├── states
│   │   ├── __init__.py
│   │   └── states.py
│   └── utils
│       ├── __init__.py
│       ├── analytics_service.py
│       ├── calendar_service.py
│       ├── data_import.py
│       ├── graduation.py
│       ├── qr_service.py
│       ├── scheduler.py
│       └── text_messages.py
├── cold_tests.md
├── collector.py
├── docker-compose.yml
├── donor_bot_telegram.egg-info
│   ├── PKG-INFO
│   ├── SOURCES.txt
│   ├── dependency_links.txt
│   └── top_level.txt
├── logs
│   └── pytest-logs.txt
├── main.py
├── output.log
├── populate_db.py
├── pyproject.toml
├── pytest.ini
├── requirements.txt
├── tests
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_admin_fsm.py
│   ├── test_analytics.py
│   ├── test_calendar_service.py
│   ├── test_db_requests.py
│   ├── test_filters.py
│   ├── test_graduation.py
│   ├── test_handlers_logic.py
│   ├── test_keyboards.py
│   ├── test_mailing_logic.py
│   ├── test_middlewares.py
│   ├── test_registration_logic.py
│   ├── test_scheduler_logic.py
│   ├── test_security.py
│   ├── test_survey_logic.py
│   ├── test_utils.py
│   └── test_volunteer_fsm.py
├── webapp
│   └── index.html
└── финальна версия.7z

14 directories, 82 files


==================== СОДЕРЖИМОЕ ФАЙЛОВ ====================

--- НАЧАЛО ФАЙЛА: .env ---

BOT_TOKEN=7404235730:AAHqEYpQpI7c9XY2Qwj-KGhpLr_yl9-s4j0
SUPER_ADMIN_ID=1031233699

NGROK_AUTHTOKEN=1qZfvDIREz2QtiVo9UL6yNY8v0B_5N2XU9ZjX2DoXpPe8tUae

DB_HOST=db
DB_PORT=5432
DB_NAME=donor_bot_db
DB_USER=donor_user
DB_PASS=strong123321
QR_SECRET_KEY=a_very_secret_key_for_hashing_qr_codes_!@#$

--- КОНЕЦ ФАЙЛА: .env ---

--- НАЧАЛО ФАЙЛА: .gitignore ---

__pycache__/ 
*.py[cod] 
*$py.class 
venv/ 
.venv/ 
.env 
.idea/ 
.vscode/ 
*.pyc
db_volume/

--- КОНЕЦ ФАЙЛА: .gitignore ---

--- НАЧАЛО ФАЙЛА: cold_tests.md ---

## Холодные тесты для новой функциональности

### Тест-кейс 1: Успешное создание мероприятия с выбором существующего центра крови

**Шаги:**

1.  Запустить бота и перейти в админ-панель.
2.  Нажать кнопку "Создать мероприятие".
3.  Ввести валидное название мероприятия.
4.  Ввести валидную дату и время.
5.  Ввести валидное местоположение.
6.  Отправить геоточку.
7.  Выбрать существующий центр крови из списка.
8.  Выбрать тип донации.
9.  Ввести количество баллов.
10. Ввести лимит участников.
11. Подтвердить создание мероприятия.

**Ожидаемый результат:**

*   Мероприятие успешно создано.
*   В сообщении с подтверждением о создании мероприятия отображается корректное название выбранного центра крови.
*   В базе данных, в таблице `events`, для созданного мероприятия в поле `blood_center_id` сохранен `id` выбранного центра крови.

### Тест-кейс 2: Успешное создание мероприятия с добавлением нового центра крови

**Шаги:**

1.  Запустить бота и перейти в админ-панель.
2.  Нажать кнопку "Создать мероприятие".
3.  ... (шаги 3-6 как в Тест-кейсе 1)
4.  Нажать кнопку "Добавить новый".
5.  Ввести название нового центра крови.
6.  ... (шаги 8-11 как в Тест-кейсе 1)

**Ожидаемый результат:**

*   Новый центр крови успешно добавлен в таблицу `blood_centers`.
*   Мероприятие успешно создано.
*   В сообщении с подтверждением о создании мероприятия отображается корректное название нового центра крови.
*   В базе данных, в таблице `events`, для созданного мероприятия в поле `blood_center_id` сохранен `id` нового центра крови.

### Тест-кейс 3: Просмотр информации о мероприятии

**Шаги:**

1.  Создать мероприятие с указанием центра крови (как в Тест-кейсе 1 или 2).
2.  Перейти в админ-панели в раздел "Просмотр мероприятий".
3.  Выбрать созданное мероприятие.

**Ожидаемый результат:**

*   В карточке мероприятия должна отображаться информация о центре крови.

### Тест-кейс 4: Редактирование центра крови у мероприятия

**Шаги:**

1.  Создать мероприятие с указанием центра крови.
2.  Перейти в режим редактирования мероприятия.
3.  Выбрать для редактирования поле "Центр крови".
4.  Выбрать другой центр крови из списка.
5.  Сохранить изменения.

**Ожидаемый результат:**

*   Центр крови у мероприятия успешно изменен.
*   В карточке мероприятия и в базе данных отображается новый центр крови.

### Тест-кейс 5: Редактирование центра крови у мероприятия с добавлением нового

**Шаги:**

1.  Создать мероприятие с указанием центра крови.
2.  Перейти в режим редактирования мероприятия.
3.  Выбрать для редактирования поле "Центр крови".
4.  Нажать кнопку "Добавить новый".
5.  Ввести название нового центра крови.
6.  Сохранить изменения.

**Ожидаемый результат:**

*   Новый центр крови успешно добавлен в таблицу `blood_centers`.
*   Центр крови у мероприятия успешно изменен на новый.
*   В карточке мероприятия и в базе данных отображается новый центр крови.


--- КОНЕЦ ФАЙЛА: cold_tests.md ---

--- НАЧАЛО ФАЙЛА: docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15-alpine
    container_name: donor_db_container
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
    volumes:
      - db_volume:/var/lib/postgresql/data
    ports:
      - "5432:5432" 
    restart: always
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
      interval: 10s
      timeout: 5s
      retries: 5

  bot:
    build: .
    container_name: donor_bot_container
    env_file: .env
    depends_on:
      - db
    restart: always
    volumes:
      - .:/app
    expose:
      - "8000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"] 
      interval: 1m
      timeout: 10s
      retries: 3

  ngrok:
    image: ngrok/ngrok:latest
    container_name: donor_ngrok_container
    restart: always
    depends_on:
      - bot 
    environment:
      NGROK_AUTHTOKEN: ${NGROK_AUTHTOKEN}
    command: http bot:8000 --log=stdout
    ports:
      - "4040:4040"
  redis:
    image: redis:7-alpine
    container_name: donor_redis_container
    restart: always
    volumes:
      - redis_volume:/data

volumes:
  db_volume:
  redis_volume:

--- КОНЕЦ ФАЙЛА: docker-compose.yml ---

--- НАЧАЛО ФАЙЛА: Dockerfile ---

FROM python:3.11-slim
RUN apt-get update && apt-get install -y libzbar0 && rm -rf /var/lib/apt/lists/*
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
CMD ["python", "main.py"]

--- КОНЕЦ ФАЙЛА: Dockerfile ---

--- НАЧАЛО ФАЙЛА: main.py ---

import asyncio
import logging
import uvicorn
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request, HTTPException
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, ValidationError
import json
import hmac
import hashlib
from urllib.parse import unquote, parse_qs
import datetime
import aiohttp
import time

import redis.asyncio as redis
from aiogram import Bot, Dispatcher, types
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.client.default import DefaultBotProperties
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.storage.redis import RedisStorage
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from bot.middlewares.block import BlockUserMiddleware
from bot.middlewares.db import DbSessionMiddleware
from bot.config_reader import config
from bot.db.engine import create_db_and_tables, async_session_maker
from bot.db import admin_requests, user_requests, event_requests
from bot.db.models import Survey, UserBlock, InfoText   
from bot.utils.scheduler import setup_scheduler
from bot.handlers import common, student, volunteer, other
from bot.handlers.admin import admin_router
from bot.handlers.student import feedback_router
from bot.utils.text_messages import Text




logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(name)s - %(message)s")
logger = logging.getLogger(__name__)


redis_client = redis.Redis(host='redis', port=6379, db=0) # host='redis' - имя сервиса из docker-compose
storage = RedisStorage(redis=redis_client)
bot = Bot(token=config.bot_token.get_secret_value(), default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher(storage=storage)



class SurveyAnswers(BaseModel):
    feeling: str
    weight: str
    symptoms: str
    tattoo: str
    tooth: str
    vaccine: str
    vaccine_type: str | None = None
    antibiotics: str
    aspirin: str
    contact_hepatitis: str
    diseases_absolute: str
    diseases_chronic: str
    travel: str
    alcohol: str

class SurveyPayload(BaseModel):
    survey_data: SurveyAnswers
    auth_string: str

def validate_telegram_data(auth_data: str) -> dict:
    """
    Проверяет строку initData, полученную от Telegram Web App.
    """
    bot_token = config.bot_token.get_secret_value()
    if not auth_data:
        raise HTTPException(status_code=403, detail="auth_data is empty.")
    try:
        parsed_data = parse_qs(auth_data)
        received_hash = parsed_data.pop('hash', [None])[0]
        if not received_hash:
            raise ValueError("Hash not found in auth data")
        data_check_string = "\n".join(
            f"{key}={value[0]}" for key, value in sorted(parsed_data.items())
        )
        secret_key = hmac.new("WebAppData".encode(), bot_token.encode(), hashlib.sha256).digest()
        calculated_hash = hmac.new(secret_key, data_check_string.encode(), hashlib.sha256).hexdigest()
        if calculated_hash != received_hash:
            raise ValueError("Invalid hash")
        user_data_str = parsed_data.get('user', [None])[0]
        if not user_data_str:
            raise ValueError("User data not found")
        return json.loads(user_data_str)
    except Exception as e:
        logger.error(f"Telegram WebApp data validation failed: {e}. Raw auth_data: '{auth_data}'")
        raise HTTPException(status_code=403, detail=str(e))

async def process_survey_rules(answers: SurveyAnswers) -> tuple[str, int | None, str]:
    if answers.diseases_absolute == 'yes' or answers.diseases_chronic == 'yes':
        return ('temp_waiver', 365000, "Абсолютное противопоказание (хронические/инфекционные заболевания).")
    if answers.feeling == 'bad':
        return ('temp_waiver', 3, "Плохое самочувствие.")
    if answers.symptoms == 'yes':
        return ('temp_waiver', 14, "Симптомы ОРВИ (включая насморк, кашель).")
    if answers.weight == 'yes':
        return ('temp_waiver', 365000, "Вес менее 50 кг.")
    if answers.tattoo == 'yes':
        return ('temp_waiver', 120, "Наличие свежей татуировки/пирсинга.")
    if answers.tooth == 'yes':
        return ('temp_waiver', 10, "Недавнее удаление зуба.")
    if answers.vaccine == 'yes':
        days = 30 if answers.vaccine_type == 'live' else 10
        return ('temp_waiver', days, "Недавняя вакцинация.")
    if answers.antibiotics == 'yes':
        return ('temp_waiver', 14, "Прием антибиотиков.")
    if answers.aspirin == 'yes':
        return ('temp_waiver', 5, "Прием анальгетиков/аспирина.")
    if answers.contact_hepatitis == 'yes':
        return ('temp_waiver', 90, "Контакт с больным гепатитом A.")
    if answers.travel == 'yes':
        return ('temp_waiver', 30, "Длительное пребывание в эндемичных странах.")
    if answers.alcohol == 'yes':
        return ('temp_waiver', 2, "Употребление алкоголя за последние 48 часов.")
    return ('ok', 0, "Противопоказаний не выявлено.")

async def get_ngrok_url():
    for _ in range(10):
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get("http://ngrok:4040/api/tunnels") as response:
                    if response.status == 200:
                        data = await response.json()
                        for tunnel in data['tunnels']:
                            if tunnel['proto'] == 'https':
                                return tunnel['public_url']
        except aiohttp.ClientConnectorError:
            logger.warning("Ngrok is not ready yet, retrying in 3 seconds...")
        await asyncio.sleep(3)
    return None

async def initial_admin_and_texts_setup(): 
    logger.info("Checking for initial admin and texts setup...")
    async with async_session_maker() as session:
        users_exist = await admin_requests.check_if_users_exist(session)
        if not users_exist:
            super_admin_id = config.super_admin_id
            logger.warning(f"Users table is empty. Creating main admin with ID: {super_admin_id}")
            try:
                await admin_requests.create_main_admin(session=session, tg_id=super_admin_id, tg_username="main_admin", full_name="Главный Администратор")
                await session.commit()
                logger.info(f"Main admin user created successfully for TG ID {super_admin_id}.")
            except Exception as e:
                logger.error(f"Failed to create main admin: {e}", exc_info=True)
        else:
            logger.info("Users table is not empty. Skipping admin creation.")
        
        info_texts_in_db = (await session.execute(select(func.count(InfoText.section_key)))).scalar()
        if info_texts_in_db == 0:
            logger.warning("InfoTexts table is empty. Populating from Text class.")
            texts_to_add = [
                InfoText(section_key="prepare", section_title="Как подготовиться?", section_text=Text.INFO_PREPARE),
                InfoText(section_key="contraindications", section_title="Противопоказания", section_text=Text.INFO_CONTRAINDICATIONS),
                InfoText(section_key="after", section_title="Что делать после?", section_text=Text.INFO_AFTER),
                InfoText(section_key="dkm", section_title="О донорстве костного мозга (ДКМ)", section_text=Text.INFO_DKM),
                InfoText(section_key="mifi_process", section_title="О донациях в МИФИ", section_text=Text.INFO_MIFI_PROCESS),
                InfoText(section_key="contacts", section_title="Связаться с организаторами", section_text=Text.INFO_CONTACTS)
            ]
            session.add_all(texts_to_add)
            await session.commit()
            logger.info("InfoTexts table populated successfully.")
        else:
            logger.info("InfoTexts table already populated. Skipping.")
            
def setup_aiogram_routers():
    dp.update.middleware(DbSessionMiddleware(session_pool=async_session_maker)) 
    dp.update.middleware(BlockUserMiddleware())
    dp.include_router(common.router)
    dp.include_router(student.router)
    dp.include_router(feedback_router)
    dp.include_router(volunteer.router)
    dp.include_router(admin_router)
    dp.include_router(other.router)

async def submit_survey_logic(session: AsyncSession, payload: SurveyPayload) -> tuple[int, str, types.InlineKeyboardMarkup | None]:
    """
    Основная логика обработки опросника.
    Теперь возвращает данные для отправки сообщения.
    """
    logger.info("submit_survey_logic: Starting survey processing.")
    try:
        user_data = validate_telegram_data(payload.auth_string)
        user_tg_id = user_data['id']
        user_username = user_data.get('username')
        logger.info(f"submit_survey_logic: Validation successful for user_tg_id: {user_tg_id}, username: {user_username}")
    except HTTPException as e:
        logger.error(f"Survey validation failed: {e.detail}")
        raise

    answers = payload.survey_data
    status, days, reason = await process_survey_rules(answers)
    logger.info(f"submit_survey_logic: Survey rules processed. Status: {status}, Reason: {reason}")
    
    user = await user_requests.get_user_by_tg_id(session, user_tg_id)
    if not user and user_username:
        logger.warning(f"User with tg_id {user_tg_id} not found. Trying to find by username '{user_username}'.")
        found_users = await admin_requests.find_user_for_admin(session, user_username)
        if found_users:
            user = found_users[0]
            logger.info(f"Found user by username: '{user.full_name}'. Updating their tg_id from {user.telegram_id} to {user_tg_id}.")
            user.telegram_id = user_tg_id
            session.add(user)

    if not user:
        logger.error(f"submit_survey_logic: User with tg_id {user_tg_id} or username {user_username} not found in DB.")
        raise HTTPException(status_code=404, detail="User not found in DB")

    logger.info(f"submit_survey_logic: Found user '{user.full_name}' (ID: {user.id}) in DB.")
    survey_record = Survey(user_id=user.id, passed=(status == 'ok'), answers_json=answers.model_dump(), verdict_text=reason)
    session.add(survey_record)

    chat_id_to_send = user_tg_id 
    message_text = ""
    reply_markup = None

    if status == 'ok':
        logger.info(f"submit_survey_logic: Status is OK. Preparing 'success' message.")
        events = await event_requests.get_active_events_for_user(session, user.id)
        message_text = "✅ Спасибо за ответы! Противопоказаний не найдено.\n\n"
        if not events:
            message_text += "К сожалению, активных мероприятий для записи сейчас нет."
        else:
            message_text += "Вот список доступных мероприятий:"
            builder = InlineKeyboardBuilder() 
            for event in events:
                builder.row(types.InlineKeyboardButton(
                    text=f"{event.event_datetime.strftime('%d.%m.%Y')} - {event.name}",
                    callback_data=f"reg_event_{event.id}"
                ))
            reply_markup = builder.as_markup()
            
    elif status == 'temp_waiver':
        logger.info(f"submit_survey_logic: Status is TEMP_WAIVER. Creating waiver for {days} days.")
        end_date = datetime.date.today() + datetime.timedelta(days=days)
        await admin_requests.create_manual_waiver(session, user.id, end_date, reason, admin_id=0)
        message_text = f"Спасибо за честность. У вас выявлено противопоказание: <b>{reason}</b>\n\nМы автоматически установили вам медотвод до <b>{end_date.strftime('%d.%m.%Y')}</b>. Если вы считаете, что произошла ошибка, свяжитесь с организаторами."
    
    return chat_id_to_send, message_text, reply_markup

async def submit_survey_endpoint(request: Request):
    """
    API эндпоинт, который вызывает логику и затем отправляет сообщение.
    """
    try:
        body = await request.json()
        payload = SurveyPayload.model_validate(body)
    except Exception as e:
        logger.error(f"Error processing survey submission: {e}")
        raise HTTPException(status_code=400, detail="Invalid payload")

    chat_id, text, markup = None, None, None
    async with async_session_maker() as session:
        chat_id, text, markup = await submit_survey_logic(session, payload)
        await session.commit()
    
    if chat_id and text:
        try:
            logger.info(f"Endpoint: Attempting to send message to chat_id: {chat_id}")
            await bot.send_message(chat_id, text, reply_markup=markup, parse_mode="HTML")
            logger.info(f"Endpoint: Successfully sent message to chat_id: {chat_id}")
        except Exception as e:
            logger.error(f"Endpoint: FAILED to send message to chat_id {chat_id}. Error: {e}", exc_info=True)
    else:
        logger.warning("Endpoint: No chat_id or text returned from logic, nothing to send.")
            
    return {"ok": True}

app = FastAPI()
app.mount("/webapp", StaticFiles(directory="webapp"), name="webapp")

@app.get("/health")
async def health_check():
    return {"status": "ok"}

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting up...")
    app.state.ngrok_url = await get_ngrok_url()

    if app.state.ngrok_url:
        logger.info(f"Successfully fetched ngrok URL: {app.state.ngrok_url}")
        dp["ngrok_url"] = app.state.ngrok_url
    else:
        logger.error("Could not get ngrok URL after several attempts. WebApp will not work.")
        dp["ngrok_url"] = None
    
    await create_db_and_tables()
    await initial_admin_and_texts_setup()
    scheduler = setup_scheduler(bot, async_session_maker, storage)
    scheduler.start()
    asyncio.create_task(dp.start_polling(bot, dp=dp))
    yield
    logger.info("Shutting down...")
    scheduler.shutdown()
    await dp.storage.close()
    await bot.session.close()

app.router.lifespan_context = lifespan
app.add_api_route("/api/submit_survey", submit_survey_endpoint, methods=["POST"])

if __name__ == "__main__":
    setup_aiogram_routers()
    uvicorn.run(app, host="0.0.0.0", port=8000)

--- КОНЕЦ ФАЙЛА: main.py ---

--- НАЧАЛО ФАЙЛА: populate_db.py ---

import asyncio
import datetime
import random
import logging
from faker import Faker
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy import delete, select

# Загружаем переменные окружения, чтобы получить доступ к БД
import os
from dotenv import load_dotenv

load_dotenv()

# Импортируем модели и конфигурацию из вашего проекта
try:
    # ФИНАЛЬНАЯ ВЕРСИЯ ИМПОРТОВ
    from bot.db.models import (
        Base, User, Event, EventRegistration, Donation, MedicalWaiver,
        UserBlock, MerchItem, MerchOrder, Survey, Feedback
    )
    from bot.config_reader import config
except ImportError as e:
    print(f"Ошибка импорта: {e}")
    print("Убедитесь, что скрипт 'populate_db.py' находится в корневой папке вашего проекта.")
    exit()

# ПЕРЕОПРЕДЕЛЯЕМ ХОСТ БД СПЕЦИАЛЬНО ДЛЯ ЭТОГО СКРИПТА
config.db_host = "localhost"


# Настройка логирования
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# --- Константы для генерации данных ---
USER_COUNT = 1000
VOLUNTEER_COUNT = 5
ADMIN_COUNT = 1
PAST_EVENTS_COUNT = 5
FUTURE_EVENTS_COUNT = 3
REGISTRATION_CHANCE = 0.4
DONATION_CHANCE = 0.7
MANUAL_WAIVER_CHANCE = 0.05

# Создаем экземпляр Faker для генерации русскоязычных данных
faker = Faker('ru_RU')

# --- Настройка соединения с БД (аналогично вашему engine.py) ---
engine = create_async_engine(
    url=config.database_url,
    echo=False
)
async_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

# --- Вспомогательные данные ---
UNIVERSITIES = ["НИЯУ МИФИ"] * 8 + ["Другой ВУЗ"] * 2
FACULTIES_MIFI = ["ИИКС", "ФИБС", "ИФТЭБ", "ИФИБ", "а", "ИнЯз", "ИПТИС"]
GENDERS = ["male", "female"]
DONATION_TYPES = ['whole_blood', 'plasma', 'platelets']

async def clear_database(session: AsyncSession):
    """Очищает все данные из таблиц в правильном порядке, чтобы избежать ошибок внешних ключей."""
    logger.info("Очистка базы данных...")
    # ФИНАЛЬНЫЙ ПОРЯДОК ОЧИСТКИ
    tables_to_clear = [
        Survey, Feedback, Donation, EventRegistration, MedicalWaiver, UserBlock, MerchOrder,
        Event, MerchItem, User
    ]
    for table in tables_to_clear:
        stmt = delete(table)
        await session.execute(stmt)
    await session.commit()
    logger.info("База данных очищена.")


async def create_users(session: AsyncSession) -> list[User]:
    """Создает пачку пользователей, включая волонтеров и админов."""
    logger.info(f"Создание {USER_COUNT} пользователей...")
    users_to_create = []

    for i in range(USER_COUNT):
        role = 'student'
        if i < ADMIN_COUNT:
            role = 'admin'
        elif i < ADMIN_COUNT + VOLUNTEER_COUNT:
            role = 'volunteer'

        university = random.choice(UNIVERSITIES)
        faculty = random.choice(FACULTIES_MIFI) if university == "НИЯУ МИФИ" else "Не указан"
        gender = random.choice(GENDERS)

        user = User(
            phone_number=f"+79{random.randint(100000000, 999999999)}",
            telegram_id=1000000000 + i,
            telegram_username=faker.user_name(),
            full_name=faker.name_male() if gender == 'male' else faker.name_female(),
            university=university,
            faculty=faculty,
            study_group=f"{random.choice(['Б', 'М', 'С'])}{random.randint(20, 23)}-{random.randint(101, 515)}",
            gender=gender,
            points=random.randint(0, 500),
            role=role,
            is_blocked=False,
            created_at=faker.date_time_between(start_date='-2y', end_date='now')
        )
        users_to_create.append(user)

    session.add_all(users_to_create)
    await session.commit()
    logger.info("Пользователи успешно созданы.")
    
    result = await session.execute(select(User))
    return result.scalars().all()


async def create_events(session: AsyncSession) -> tuple[list[Event], list[Event]]:
    """Создает прошедшие и будущие мероприятия."""
    logger.info(f"Создание {PAST_EVENTS_COUNT} прошедших и {FUTURE_EVENTS_COUNT} будущих мероприятий...")
    past_events = []
    future_events = []
    today = datetime.datetime.now()

    for i in range(PAST_EVENTS_COUNT):
        event_date = today - datetime.timedelta(days=random.randint(15, 365))
        event = Event(
            name=f"Прошедшая акция №{i+1}",
            event_datetime=event_date,
            location="г. Москва, ул. Щукинская, д. 6, корп. 2",
            latitude=55.807920,
            longitude=37.491633,
            donation_type=random.choice(DONATION_TYPES),
            points_per_donation=random.randint(100, 250),
            participant_limit=random.randint(50, 100),
            is_active=False,
            registration_is_open=False
        )
        past_events.append(event)

    for i in range(FUTURE_EVENTS_COUNT):
        event_date = today + datetime.timedelta(days=random.randint(10, 60))
        event = Event(
            name=f"Будущая акция №{i+1}",
            event_datetime=event_date,
            location="г. Москва, Каширское шоссе, 31",
            latitude=55.649917,
            longitude=37.662128,
            donation_type=random.choice(DONATION_TYPES),
            points_per_donation=random.randint(100, 250),
            participant_limit=random.randint(60, 120),
            is_active=True,
            registration_is_open=True
        )
        future_events.append(event)

    session.add_all(past_events + future_events)
    await session.commit()
    logger.info("Мероприятия успешно созданы.")
    return past_events, future_events


async def create_registrations_and_donations(session: AsyncSession, users: list[User], events: list[Event]):
    """Создает регистрации на мероприятия, а для прошедших - донации и медотводы."""
    logger.info("Создание регистраций, донаций и системных медотводов...")
    regs_to_create = []
    donations_to_create = []
    waivers_to_create = []
    user_updates = {}

    for event in events:
        for user in users:
            if random.random() < REGISTRATION_CHANCE:
                regs_to_create.append(EventRegistration(user_id=user.id, event_id=event.id))
                if not event.is_active and random.random() < DONATION_CHANCE:
                    donation_date = event.event_datetime.date()
                    points_awarded = event.points_per_donation
                    donations_to_create.append(Donation(
                        user_id=user.id,
                        event_id=event.id,
                        donation_date=donation_date,
                        donation_type=event.donation_type,
                        points_awarded=points_awarded
                    ))
                    user_updates[user.id] = user_updates.get(user.id, 0) + points_awarded
                    days_waiver = (90 if user.gender == 'female' else 60) if event.donation_type == 'whole_blood' else 14
                    end_date = donation_date + datetime.timedelta(days=days_waiver)
                    waivers_to_create.append(MedicalWaiver(
                        user_id=user.id,
                        start_date=donation_date,
                        end_date=end_date,
                        reason=f"Сдача «{event.donation_type}»",
                        created_by='system'
                    ))

    session.add_all(regs_to_create)
    session.add_all(donations_to_create)
    session.add_all(waivers_to_create)
    await session.commit()

    logger.info(f"Обновление баллов для {len(user_updates)} пользователей...")
    for user_id, points in user_updates.items():
        user = await session.get(User, user_id)
        if user:
            user.points += points
    await session.commit()
    logger.info("Регистрации и донации успешно созданы.")


async def create_manual_waivers(session: AsyncSession, users: list[User]):
    """Создает случайные медотводы, установленные 'пользователем'."""
    logger.info("Создание случайных пользовательских медотводов...")
    waivers_to_create = []
    users_with_waiver = random.sample(users, int(len(users) * MANUAL_WAIVER_CHANCE))
    today = datetime.date.today()

    for user in users_with_waiver:
        start_date = today - datetime.timedelta(days=random.randint(0, 10))
        end_date = today + datetime.timedelta(days=random.randint(5, 30))
        waiver = MedicalWaiver(
            user_id=user.id,
            start_date=start_date,
            end_date=end_date,
            reason=random.choice(["Простуда", "Плохое самочувствие", "Прием лекарств"]),
            created_by='user'
        )
        waivers_to_create.append(waiver)

    session.add_all(waivers_to_create)
    await session.commit()
    logger.info(f"Создано {len(waivers_to_create)} пользовательских медотводов.")


async def main():
    """Главная функция для запуска всех этапов заполнения БД."""
    async with async_session_maker() as session:
        await clear_database(session)
        users = await create_users(session)
        past_events, future_events = await create_events(session)
        all_events = past_events + future_events
        await create_registrations_and_donations(session, users, all_events)
        await create_manual_waivers(session, users)

    logger.info("🎉 Готово! База данных успешно заполнена тестовыми данными.")


if __name__ == "__main__":
    asyncio.run(main())

--- КОНЕЦ ФАЙЛА: populate_db.py ---

--- НАЧАЛО ФАЙЛА: pytest.ini ---

[pytest]
asyncio_mode = auto
log_file = logs/pytest-logs.txt

--- КОНЕЦ ФАЙЛА: pytest.ini ---

--- НАЧАЛО ФАЙЛА: README.md ---

# Проект "Донор-бот МИФИ" (Donor Bot)

Телеграм-бот для автоматизации и геймификации донорского движения в НИЯУ МИФИ.

## 🚀 Основные возможности

*   **Регистрация и аутентификация** пользователей по номеру телефона.
*   **Система ролей**: Студент, Волонтер, Администратор, Главный Администратор.
*   **Запись на мероприятия**: Проверка противопоказаний через Web App, проверка интервалов между донациями и годовых лимитов.
*   **Геймификация**: Начисление баллов за донации, магазин мерча для обмена баллов.
*   **Управление для волонтеров**: Подтверждение донаций по QR-коду.
*   **Панель администратора**: Управление пользователями, мероприятиями, мерчем, заказами, рассылками.
*   **Аналитика**: Сбор и визуализация KPI, анализ эффективности мероприятий.
*   **Автоматические уведомления**: Напоминания о предстоящих донациях, уведомления об отмене мероприятий и истечении медотводов.

## 🏛️ Архитектура проекта

Проект построен на асинхронном стеке Python и состоит из нескольких ключевых компонентов, работающих в Docker-контейнерах.

*   **`main.py`**: Точка входа. Использует веб-фреймворк **FastAPI** для обработки вебхуков от Telegram и для работы **Telegram Web App**.
*   **Aiogram 3**: Ядро телеграм-бота, отвечает за обработку обновлений, FSM (машину состояний) и взаимодействие с Telegram Bot API.
*   **SQLAlchemy 2.0 (async)**: Асинхронная работа с базой данных. В качестве драйвера используется `asyncpg`.
*   **PostgreSQL**: Основная база данных для хранения всей информации о пользователях, мероприятиях, донациях и т.д.
*   **Alembic**: Система миграций для управления изменениями схемы базы данных.
*   **Docker / Docker Compose**: Контейнеризация и оркестрация всех сервисов проекта (бот, БД, Redis).

### Структура директорий

```
.
├── bot/                # Основной код бота
│   ├── db/             # Модули для работы с БД (модели, запросы)
│   ├── handlers/       # Обработчики сообщений и колбэков, разделенные по ролям
│   ├── keyboards/      # Генераторы клавиатур (inline и reply)
│   ├── middlewares/    # Промежуточные слои (проверка блокировки, сессия БД)
│   ├── states/         # Определения состояний FSM
│   └── utils/          # Вспомогательные сервисы (QR, календарь, планировщик)
├── tests/              # Каталог с тестами Pytest
├── webapp/             # Файлы для Telegram Web App (HTML, CSS, JS)
├── alembic/            # Файлы миграций Alembic
├── Dockerfile          # Инструкция по сборке Docker-образа
├── docker-compose.yml  # Файл для запуска dev-окружения
├── main.py             # Точка входа (FastAPI + Aiogram)
├── requirements.txt    # Зависимости проекта
└── README.md           # Этот файл
```

## 🛠️ Установка и запуск для разработки

Для запуска проекта в режиме разработки вам понадобится **Docker** и **Docker Compose**.

1.  **Клонируйте репозиторий:**
    ```bash
    git clone <URL вашего репозитория>
    cd <название папки проекта>
    ```

2.  **Создайте файл окружения:**
    Скопируйте файл `.env.example` (если он есть) или создайте новый файл с именем `.env` в корне проекта. Заполните его необходимыми данными. Для разработки можно использовать следующие значения:
    ```dotenv
    # Токен вашего тестового бота от @BotFather
    BOT_TOKEN=12345:ABC-DEF12345
    # Ваш личный Telegram ID для прав Главного Администратора
    SUPER_ADMIN_ID=123456789

    # Данные для локальной БД (Docker Compose подставит их в контейнер postgres)
    DB_HOST=db
    DB_PORT=5432
    DB_NAME=donor_bot_db
    DB_USER=donor_user
    DB_PASS=strong123321

    # Данные для Redis
    REDIS_HOST=redis
    REDIS_PORT=6379

    # Секретный ключ для подписи QR-кодов
    QR_SECRET_KEY=a_very_secret_key_for_testing
    
    # URL для вебхука (в dev-режиме можно использовать ngrok или аналог)
    # ВАЖНО: для работы Web App этот URL должен быть доступен извне
    WEBHOOK_HOST=https://your-ngrok-url.ngrok.io
    ```

3.  **Запустите проект:**
    Используйте Docker Compose для сборки образов и запуска всех сервисов.
    ```bash
    docker-compose up --build
    ```
    Ключ `--build` пересобирает образ бота, если в коде были изменения. Для обычного запуска достаточно `docker-compose up`. Чтобы запустить в фоновом режиме, добавьте ключ `-d`.

## ✅ Тестирование

Проект покрыт тестами с использованием `pytest`. Тесты используют изолированную базу данных SQLite в памяти.

Для запуска всех тестов выполните команду из корневой директории проекта:
```bash
pytest
```

Для получения подробного вывода и сохранения его в файл (удобно для анализа больших логов ошибок):
```bash
pytest > test_log.txt 2>&1
```
Эта команда перенаправит стандартный вывод (`stdout`) и вывод ошибок (`stderr`) в файл `test_log.txt`.

## ⚙️ Вспомогательные скрипты

В проекте есть два скрипта, которые **не являются частью основного приложения**, но полезны для разработки и отладки. **Они не должны находиться в релизной ветке `main`.**

### `populate_db.py`
Этот скрипт наполняет базу данных большим количеством фейковых данных (пользователи, мероприятия, донации и т.д.) с помощью библиотеки `Faker`. Это крайне полезно для тестирования производительности, UI и логики на больших объемах данных.

**Внимание:** Скрипт полностью **очищает** базу данных перед заполнением!

**Использование:**
1.  Убедитесь, что ваше dev-окружение запущено (`docker-compose up`).
2.  Выполните скрипт из корневой папки проекта:
    ```bash
    python populate_db.py
    ```

### `collector.py`
Скрипт предназначен для сбора всей кодовой базы проекта в один текстовый файл `all_code.txt`. Это может быть полезно для:
*   Передачи кода на ревью одним файлом.
*   Анализа кода с помощью LLM-моделей.
*   Быстрого поиска по всему проекту.

**Использование:**
```bash
python collector.py
```

## 🔄 Процесс разработки (Git Flow)

1.  Вся новая разработка ведется в ветках `feature/*`, которые создаются от `develop`.
2.  После завершения работы над задачей создается Pull Request из `feature/*` в `develop`.
3.  После успешного Code Review и прохождения всех тестов ветка вливается в `develop`.
4.  Для релиза создается Pull Request из `develop` в `main`. Ветка `main` содержит только стабильные, готовые к развертыванию версии.

---

--- КОНЕЦ ФАЙЛА: README.md ---

--- НАЧАЛО ФАЙЛА: requirements.txt ---

aiogram==3.4.1
aiogram[redis]==3.4.1
redis==5.0.1 
sqlalchemy[asyncio]==2.0.27
asyncpg==0.29.0
python-dotenv==1.0.1
qrcode[pil]==7.4.2
pyzbar==0.1.9
pillow==10.2.0
apscheduler==3.10.4
alembic==1.13.1
pydantic-settings==2.2.1
ics==0.7.2
greenlet==3.0.3
aiohttp==3.9.1
aiosignal==1.3.1
attrs==23.2.0
frozenlist==1.4.1
multidict==6.0.5
yarl==1.9.4
pytz
fastapi==0.111.0
uvicorn[standard]==0.29.0
python-jose[cryptography]==3.3.0
python-multipart==0.0.9
matplotlib==3.8.4
pandas==2.2.2
openpyxl==3.1.2

--- КОНЕЦ ФАЙЛА: requirements.txt ---

--- НАЧАЛО ФАЙЛА: .pytest_cache/.gitignore ---

# Created by pytest automatically.
*


--- КОНЕЦ ФАЙЛА: .pytest_cache/.gitignore ---

--- НАЧАЛО ФАЙЛА: .pytest_cache/README.md ---

# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


--- КОНЕЦ ФАЙЛА: .pytest_cache/README.md ---

--- НАЧАЛО ФАЙЛА: bot/config_reader.py ---

from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import SecretStr, StrictStr

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')
    bot_token: SecretStr
    super_admin_id: int
    ngrok_authtoken: SecretStr 
    db_host: StrictStr
    db_port: int
    db_name: StrictStr
    db_user: StrictStr
    db_pass: SecretStr
    qr_secret_key: SecretStr
    @property
    def database_url(self) -> str:
        return (f"postgresql+asyncpg://{self.db_user}:{self.db_pass.get_secret_value()}"
                f"@{self.db_host}:{self.db_port}/{self.db_name}")


config = Settings()

--- КОНЕЦ ФАЙЛА: bot/config_reader.py ---

--- НАЧАЛО ФАЙЛА: bot/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/db/admin_requests.py ---

import datetime
import logging # <-- ДОБАВИТЬ ЭТУ СТРОКУ
from sqlalchemy import select, update, or_, func, String, delete, distinct, extract
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload, selectinload
from .models import (
    User, Event, EventRegistration, Donation, MedicalWaiver, 
    MerchItem, MerchOrder, UserBlock, BloodCenter
)
from .models import Feedback
from .event_requests import find_specific_registration, add_event_registration, confirm_donation_transaction
import math

logger = logging.getLogger(__name__) 

async def check_if_users_exist(session: AsyncSession) -> bool:
    user_count = await session.scalar(select(func.count(User.id)))
    return user_count > 0


# --- User Management ---
async def find_user_for_admin(session: AsyncSession, query: str) -> User | None:
    stmt = select(User).where(
        or_(
            User.full_name.ilike(f"%{query}%"),
            User.telegram_username.ilike(f"%{query}%"),
            User.telegram_id.cast(String).ilike(f"%{query}%"),
            User.phone_number.ilike(f"%{query}%")
        )
    ).order_by(User.full_name)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_users_page(session: AsyncSession, page: int = 1, page_size: int = 10) -> tuple[list[User], int]:
    offset = (page - 1) * page_size
    total_count = (await session.execute(select(func.count(User.id)))).scalar_one()
    items_result = await session.execute(select(User).order_by(User.full_name).offset(offset).limit(page_size))
    items = items_result.scalars().all()
    total_pages = math.ceil(total_count / page_size) if total_count > 0 else 1
    return items, total_pages

async def get_all_users(session: AsyncSession) -> list[User]:
    stmt = select(User).order_by(User.full_name)
    result = await session.execute(stmt)
    return result.scalars().all()

async def change_user_role(session: AsyncSession, user_id: int, new_role: str):
    stmt = update(User).where(User.id == user_id).values(role=new_role)
    await session.execute(stmt)
    await session.commit()

async def add_points_to_user(session: AsyncSession, user_id: int, points: int, reason: str):
    user = await session.get(User, user_id)
    user.points += points
    # log: # Здесь можно добавить логирование этой операции в отдельную таблицу
    await session.commit()

async def block_user(session: AsyncSession, user_id: int, admin_id: int, reason: str):
    user = await session.get(User, user_id)
    user.is_blocked = True
    block_record = UserBlock(user_id=user_id, admin_id=admin_id, reason=reason, is_active=True)
    session.add(block_record)
    # log: # Можно добавить логирование блокировки
    await session.commit()

async def unblock_user(session: AsyncSession, user_id: int):
    user = await session.get(User, user_id)
    user.is_blocked = False
    stmt = update(UserBlock).where(UserBlock.user_id == user_id, UserBlock.is_active == True).values(is_active=False)
    await session.execute(stmt)
    # log: # Можно добавить логирование разблокировки
    await session.commit()

# --- Event Management ---
async def create_event(session: AsyncSession, data: dict) -> Event:
    event = Event(**data)
    session.add(event)
    await session.commit()
    return event

async def update_event_field(session: AsyncSession, event_id: int, field_name: str, new_value: any):
    if not hasattr(Event, field_name):
        return
    stmt = update(Event).where(Event.id == event_id).values({field_name: new_value})
    await session.execute(stmt)
    await session.commit()


async def get_all_blood_centers(session: AsyncSession) -> list[BloodCenter]:
    stmt = select(BloodCenter).order_by(BloodCenter.name)
    result = await session.execute(stmt)
    return result.scalars().all()


async def create_blood_center(session: AsyncSession, name: str) -> BloodCenter:
    blood_center = BloodCenter(name=name)
    session.add(blood_center)
    await session.commit()
    return blood_center


async def get_blood_center_by_id(session: AsyncSession, blood_center_id: int) -> BloodCenter | None:
    return await session.get(BloodCenter, blood_center_id)

# --- Merch Management ---
async def create_merch_item(session: AsyncSession, data: dict) -> MerchItem:
    item = MerchItem(**data)
    session.add(item)
    await session.commit()
    return item

# --- Order Processing ---
async def get_pending_orders(session: AsyncSession) -> list[MerchOrder]:
    stmt = select(MerchOrder).options(joinedload(MerchOrder.user), joinedload(MerchOrder.item)).where(MerchOrder.status == 'pending_pickup').order_by(MerchOrder.order_date)
    result = await session.execute(stmt)
    return result.scalars().all()

async def complete_order(session: AsyncSession, order_id: int, admin_id: int):
    order = await session.get(MerchOrder, order_id)
    if order:
        order.status = 'completed'
        order.completed_by_admin_id = admin_id
        order.completion_date = datetime.datetime.now()
        # log: # Можно добавить логирование подтверждения заказа
        await session.commit()

# --- Manual Waiver ---
async def create_manual_waiver(session: AsyncSession, user_id: int, end_date: datetime.date, reason: str, admin_id: int):
    waiver = MedicalWaiver(
        user_id=user_id,
        start_date=datetime.date.today(),
        end_date=end_date,
        reason=reason,
        created_by=str(admin_id)
    )
    session.add(waiver)
    # log: # Можно добавить логирование создания медотвода
    await session.commit()

# --- Export Functions ---
async def get_all_donations(session: AsyncSession) -> list:
    stmt = select(Donation).options(
        joinedload(Donation.user),
        joinedload(Donation.event)
    ).order_by(Donation.donation_date.desc())
    result = await session.execute(stmt)
    return result.scalars().all()

# --- Main Admin Setup ---
async def create_main_admin(session: AsyncSession, tg_id: int, tg_username: str, full_name: str):
    new_admin = User(
        phone_number=f"admin_{tg_id}",
        telegram_id=tg_id,
        telegram_username=tg_username,
        full_name=full_name,
        role='main_admin',
        university="Администрация"  # <-- ИСПРАВЛЕНО
    )
    session.add(new_admin)

async def update_main_admin_data(session: AsyncSession, tg_id: int, tg_username: str, full_name: str):
    stmt = (
        update(User)
        .where(User.telegram_id == tg_id)
        .values(
            role='main_admin',
            telegram_username=tg_username,
            full_name=full_name
        )
    )
    await session.execute(stmt)
    await session.commit()

async def get_event_registrations_count(session: AsyncSession, event_id: int) -> int:
    stmt = select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event_id)
    result = await session.execute(stmt)
    return result.scalar_one()

async def get_event_with_participants(session: AsyncSession, event_id: int):
    stmt = select(Event).options(selectinload(Event.registrations).joinedload(EventRegistration.user)).where(Event.id == event_id)
    result = await session.execute(stmt)
    event = result.scalar_one_or_none()
    if not event:
        return None, []
    return event, event.registrations

async def deactivate_event(session: AsyncSession, event_id: int):
    stmt = update(Event).where(Event.id == event_id).values(is_active=False)
    await session.execute(stmt)
    await session.commit()

async def get_all_merch_items(session: AsyncSession) -> list[MerchItem]:
    stmt = select(MerchItem).order_by(MerchItem.id)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_merch_item_by_id(session: AsyncSession, item_id: int) -> MerchItem | None:
    return await session.get(MerchItem, item_id)

async def update_merch_item_field(session: AsyncSession, item_id: int, field_name: str, new_value: any):
    if not hasattr(MerchItem, field_name):
        return
    stmt = update(MerchItem).where(MerchItem.id == item_id).values({field_name: new_value})
    await session.execute(stmt)
    await session.commit()

async def toggle_merch_item_availability(session: AsyncSession, item_id: int) -> bool:
    item = await session.get(MerchItem, item_id)
    if not item:
        return False
    item.is_available = not item.is_available
    await session.commit()
    return item.is_available

async def delete_merch_item_by_id(session: AsyncSession, item_id: int):
    item = await session.get(MerchItem, item_id)
    if item:
        await session.delete(item)
        await session.commit()

# --- Export Functions ---
async def get_all_data_for_export(session: AsyncSession) -> dict:
    data_to_export = {
        "users": (await session.execute(select(User))).scalars().all(),
        "events": (await session.execute(select(Event))).scalars().all(),
        "event_registrations": (await session.execute(select(EventRegistration))).scalars().all(),
        "donations": (await session.execute(select(Donation))).scalars().all(),
        "medical_waivers": (await session.execute(select(MedicalWaiver))).scalars().all(),
        "merch_items": (await session.execute(select(MerchItem))).scalars().all(),
        "merch_orders": (await session.execute(select(MerchOrder))).scalars().all(),
        "user_blocks": (await session.execute(select(UserBlock))).scalars().all(),
    }
    return data_to_export



async def toggle_event_registration_status(session: AsyncSession, event_id: int) -> bool:
    """Переключает статус регистрации на мероприятие (открыта/закрыта)."""
    event = await session.get(Event, event_id)
    if not event:
        return False
    event.registration_is_open = not event.registration_is_open
    await session.commit()
    return event.registration_is_open



async def get_user_registrations(session: AsyncSession, user_id: int) -> list[EventRegistration]:
    """Получает все активные регистрации пользователя на будущие мероприятия."""
    stmt = (
        select(EventRegistration)
        .join(EventRegistration.event)
        .where(
            EventRegistration.user_id == user_id,
            Event.event_date >= datetime.date.today(),
            EventRegistration.status == 'registered'
        )
        .options(joinedload(EventRegistration.event))
        .order_by(Event.event_date)
    )
    result = await session.execute(stmt)
    return result.scalars().all()


async def manually_register_user(session: AsyncSession, user: User, event: Event) -> tuple[bool, str]:
    """
    Регистрирует пользователя на мероприятие вручную от имени администратора.
    Проверяет все условия, кроме статуса открытой регистрации.
    """
    # 1. Проверка на блокировку
    if user.is_blocked:
        return False, "Пользователь заблокирован."

    # 2. Проверка на существующую регистрацию
    existing_reg = await find_specific_registration(session, user.id, event.id)
    if existing_reg:
        return False, "Пользователь уже зарегистрирован на это мероприятие."

    # 3. Проверка на медотводы (частично используем логику из check_registration_eligibility)
    waiver_stmt = select(MedicalWaiver).where(MedicalWaiver.user_id == user.id, MedicalWaiver.end_date >= event.event_date)
    active_waiver = (await session.execute(waiver_stmt)).scalar_one_or_none()
    if active_waiver:
        return False, f"У пользователя действует отвод до {active_waiver.end_date.strftime('%d.%m.%Y')}."

    # Если все проверки пройдены, регистрируем
    await add_event_registration(session, user.id, event.id)
    return True, f"Пользователь {user.full_name} успешно записан на {event.name}."


async def get_all_user_active_waivers(session: AsyncSession, user_id: int) -> list[MedicalWaiver]:
    """Получает ВСЕ активные медотводы пользователя (и системные, и личные)."""
    stmt = select(MedicalWaiver).where(
        MedicalWaiver.user_id == user_id,
        MedicalWaiver.end_date >= datetime.date.today()
    ).order_by(MedicalWaiver.end_date)
    result = await session.execute(stmt)
    return result.scalars().all()


async def force_delete_waiver(session: AsyncSession, waiver_id: int) -> bool:
    """Принудительно удаляет медотвод по его ID. Возвращает True в случае успеха."""
    stmt = delete(MedicalWaiver).where(MedicalWaiver.id == waiver_id)
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0


async def get_feedback_for_event(session: AsyncSession, event_id: int) -> list[Feedback]:
    stmt = (
        select(Feedback)
        .options(joinedload(Feedback.user))
        .where(Feedback.event_id == event_id)
        .order_by(Feedback.created_at.desc())
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_distinct_universities(session: AsyncSession) -> list[str]:
    """Возвращает список уникальных названий университетов из таблицы users."""
    stmt = select(distinct(User.university)).order_by(User.university)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_distinct_faculties(session: AsyncSession) -> list[str]:
    """Возвращает список уникальных названий факультетов из таблицы users, исключая NULL."""
    stmt = (
        select(distinct(User.faculty))
        .where(User.faculty.is_not(None)) 
        .order_by(User.faculty)
    )
    result = await session.execute(stmt)
    return result.scalars().all()


async def manually_confirm_donation(session: AsyncSession, user_id: int, event_id: int, became_dkm_donor: bool) -> tuple[bool, str]:
    """
    Вручную подтверждает донацию для пользователя на мероприятии.
    Возвращает (успех, сообщение).
    """
    user = await session.get(User, user_id)
    event = await session.get(Event, event_id)
    if not user or not event:
        return False, "Пользователь или мероприятие не найдены."

    registration = await find_specific_registration(session, user_id, event_id)
    if not registration:    
        registration = EventRegistration(user_id=user_id, event_id=event_id)
        session.add(registration)
        await session.flush()

    if registration.status == 'attended':
        return False, f"Донация для {user.full_name} уже была подтверждена."

    try:
        await confirm_donation_transaction(session, user, registration)
        if became_dkm_donor and not user.is_dkm_donor:
            user.is_dkm_donor = True
            
        await session.commit()
        return True, f"Донация для {user.full_name} подтверждена."
    except Exception as e:
        await session.rollback()
        logger.error(f"Error in manually_confirm_donation for user {user_id}: {e}")
        return False, f"Ошибка при подтверждении для {user.full_name}: {e}"


async def get_min_user_id(session: AsyncSession) -> int:
    """
    Gets the minimum user ID from the database.
    """
    result = await session.execute(select(func.min(User.telegram_id)))
    min_id = result.scalar_one_or_none()
    return min_id if min_id is not None else 0

--- КОНЕЦ ФАЙЛА: bot/db/admin_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/analytics_requests.py ---

import datetime
from sqlalchemy import select, func, and_, distinct, text
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload, selectinload

from .models import User, Event, Donation, EventRegistration, Survey, MedicalWaiver

async def get_main_kpi(session: AsyncSession) -> dict:
    """Собирает ключевые показатели для главного дашборда."""
    
    thirty_days_ago = datetime.datetime.now() - datetime.timedelta(days=30)
    new_users_stmt = select(func.count(User.id)).where(User.created_at >= thirty_days_ago)
    new_users_count = (await session.execute(new_users_stmt)).scalar_one()

    ninety_days_ago = datetime.date.today() - datetime.timedelta(days=90)
    active_donors_stmt = select(func.count(distinct(Donation.user_id))).where(Donation.donation_date >= ninety_days_ago)
    active_donors_count = (await session.execute(active_donors_stmt)).scalar_one()
    
    waiver_stmt = select(func.count(distinct(User.id))).join(User.waivers).where(MedicalWaiver.end_date >= datetime.date.today())
    on_waiver_count = (await session.execute(waiver_stmt)).scalar_one()

    next_event_stmt = select(Event).where(Event.is_active == True, Event.event_datetime >= datetime.datetime.now()).order_by(Event.event_datetime).limit(1)
    next_event = (await session.execute(next_event_stmt)).scalar_one_or_none()
    
    next_event_info = None
    if next_event:
        regs_count = (await session.execute(select(func.count(EventRegistration.id)).where(EventRegistration.event_id == next_event.id))).scalar_one()
        next_event_info = {
            "name": next_event.name,
            "registered": regs_count,
            "limit": next_event.participant_limit,
            "date": next_event.event_datetime
        }
        
    return {
        "new_users_30d": new_users_count,
        "active_donors_90d": active_donors_count,
        "on_waiver_now": on_waiver_count,
        "next_event": next_event_info
    }

async def get_donations_by_month(session: AsyncSession, months: int = 6) -> list[tuple]:
    """
    Возвращает количество донаций по месяцам за последние N месяцев.
    ИСПОЛЬЗУЕТ date_trunc для совместимости с PostgreSQL.
    """
    today = datetime.date.today()
    start_date = (today.replace(day=1) - datetime.timedelta(days=1)).replace(day=1)
    for _ in range(months - 1):
        start_date = (start_date - datetime.timedelta(days=1)).replace(day=1)

    stmt = text("""
        SELECT
            date_trunc('month', donation_date)::DATE as month_date,
            count(id) as count
        FROM donations
        WHERE donation_date >= :start_date
        GROUP BY month_date
        ORDER BY month_date
    """)
    
    result = await session.execute(stmt, {"start_date": start_date})
    
    return [(row.month_date, row.count) for row in result]

async def get_past_events_for_analysis(session: AsyncSession) -> list[Event]:
    """Получает список прошедших мероприятий для выбора."""
    stmt = select(Event).where(Event.event_datetime < datetime.datetime.now()).order_by(Event.event_datetime.desc()).limit(15)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_event_analysis_data(session: AsyncSession, event_id: int) -> dict:
    """Собирает всю аналитику по конкретному прошедшему мероприятию."""
    event = await session.get(Event, event_id)
    if not event:
        return None

    stmt_registrations = select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event_id)
    registered_count = (await session.execute(stmt_registrations)).scalar_one()
    
    stmt_donations = select(func.count(Donation.id)).where(Donation.event_id == event_id)
    attended_count = (await session.execute(stmt_donations)).scalar_one()
    
    stmt_attended_users = (
        select(User)
        .join(Donation)
        .where(Donation.event_id == event_id)
    )
    # ЗДЕСЬ БЫЛА ОШИБКА, ТЕПЕРЬ ОНА ИСПРАВЛЕНА БЛАГОДАРЯ ИМПОРТУ
    attended_users_result = await session.execute(stmt_attended_users.options(selectinload(User.donations)))
    attended_users = attended_users_result.scalars().unique().all()
    
    newcomers_count = sum(1 for user in attended_users if len(user.donations) == 1)
    
    faculties_dist = {}
    for user in attended_users:
        faculty = user.faculty or "Не указан"
        faculties_dist[faculty] = faculties_dist.get(faculty, 0) + 1

    return {
        "event_name": event.name,
        "registered_count": registered_count,
        "attended_count": attended_count,
        "conversion_rate": (attended_count / registered_count * 100) if registered_count > 0 else 0,
        "newcomers_count": newcomers_count,
        "veterans_count": attended_count - newcomers_count,
        "faculties_distribution": faculties_dist
    }

async def get_one_time_donors(session: AsyncSession) -> list[dict]:
    """Возвращает список доноров, которые сдали кровь только один раз."""
    stmt = (
        select(User, func.count(Donation.id).label("donation_count"))
        .join(Donation)
        .group_by(User)
        .having(func.count(Donation.id) == 1)
    )
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_no_show_donors(session: AsyncSession) -> list[dict]:
    """Возвращает список доноров, которые регистрировались, но не пришли."""
    stmt = (
        select(User)
        .join(EventRegistration)
        .where(EventRegistration.status == "no_show_survey_sent")
    )
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_dkm_donors(session: AsyncSession) -> list[dict]:
    """Возвращает список доноров, которые являются донорами костного мозга."""
    stmt = select(User).where(User.is_dkm_donor == True)
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_students(session: AsyncSession) -> list[dict]:
    """Возвращает список доноров, которые являются студентами."""
    stmt = select(User).where(User.category == "student")
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_employees(session: AsyncSession) -> list[dict]:
    """Возвращает список доноров, которые являются сотрудниками."""
    stmt = select(User).where(User.category == "employee")
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_external_donors(session: AsyncSession) -> list[dict]:
    """Возвращает список доноров, которые являются внешними донорами."""
    stmt = select(User).where(User.category == "external")
    result = await session.execute(stmt)
    return [{"full_name": row.User.full_name, "telegram_username": row.User.telegram_username} for row in result]

async def get_graduated_donors(session: AsyncSession) -> list[dict]:
    """Возвращает список доноров, которые выпустились из университета."""
    # This is a placeholder. The actual implementation will depend on how graduation is determined.
    return []

async def get_churn_donors(session: AsyncSession) -> list[dict]:
    """
    Возвращает доноров-однодневок.
    Логика: Пользователи, у которых ровно 1 донация, и она была более 6 месяцев назад.
    """
    six_months_ago = datetime.datetime.now() - datetime.timedelta(days=180)

    # Подзапрос для поиска пользователей с одной донацией
    subquery = (
        select(Donation.user_id)
        .group_by(Donation.user_id)
        .having(func.count(Donation.id) == 1)
    ).alias("one_donation_users")

    # Основной запрос
    stmt = (
        select(User.full_name, User.telegram_username, Donation.donation_date)
        .join(subquery, User.id == subquery.c.user_id)
        .join(Donation, User.id == Donation.user_id)
        .where(Donation.donation_date < six_months_ago)
    )

    result = await session.execute(stmt)
    return [
        {"full_name": row.full_name, "username": row.telegram_username, "donation_date": row.donation_date}
        for row in result
    ]

async def get_lapsed_donors(session: AsyncSession) -> list[dict]:
    """
    Возвращает угасающих доноров.
    Логика: 2+ донации, последняя > 9 мес. назад, нет активных медотводов.
    """
    nine_months_ago = datetime.datetime.now() - datetime.timedelta(days=270)
    today = datetime.date.today()

    # Подзапрос: пользователи с 2+ донациями и датой последней донации
    subquery = (
        select(
            Donation.user_id,
            func.count(Donation.id).label("donations_count"),
            func.max(Donation.donation_date).label("last_donation_date")
        )
        .group_by(Donation.user_id)
        .having(func.count(Donation.id) >= 2)
        .alias("lapsed_candidates")
    )

    # Подзапрос: пользователи с активными медотводами
    active_waiver_subquery = (
        select(MedicalWaiver.user_id)
        .where(MedicalWaiver.end_date >= today)
    ).alias("active_waivers")

    # Основной запрос
    stmt = (
        select(
            User.full_name,
            User.telegram_username,
            subquery.c.donations_count,
            subquery.c.last_donation_date
        )
        .join(subquery, User.id == subquery.c.user_id)
        .outerjoin(active_waiver_subquery, User.id == active_waiver_subquery.c.user_id)
        .where(
            subquery.c.last_donation_date < nine_months_ago,
            active_waiver_subquery.c.user_id == None # Условие отсутствия в подзапросе с медотводами
        )
    )

    result = await session.execute(stmt)
    return [
        {
            "full_name": row.full_name,
            "username": row.telegram_username,
            "donation_count": row.donations_count,
            "last_donation_date": row.last_donation_date
        }
        for row in result
    ]

async def get_top_donors(session: AsyncSession) -> list[dict]:
    """
    Возвращает топ-20 доноров по количеству донаций.
    """
    # Используем оконную функцию для ранжирования
    stmt = (
        select(
            User.full_name,
            User.telegram_username,
            func.count(Donation.id).label("donation_count"),
            func.rank().over(order_by=func.count(Donation.id).desc()).label("rank")
        )
        .join(Donation, User.id == Donation.user_id)
        .group_by(User.id)
        .order_by(text("rank")) # Сортируем по рангу
        .limit(20)
    )

    result = await session.execute(stmt)
    return [
        {
            "rank": row.rank,
            "full_name": row.full_name,
            "username": row.telegram_username,
            "donation_count": row.donation_count
        }
        for row in result
    ]

async def get_rare_blood_donors(session: AsyncSession) -> list[dict]:
    """
    Возвращает доноров с редкой группой крови.
    Логика: rh_factor = '-' ИЛИ blood_type = 'AB(IV)'.
    """
    stmt = (
        select(User.full_name, User.telegram_username, User.blood_type, User.rh_factor)
        .where(
            (User.rh_factor == '-') |
            (User.blood_type == 'AB(IV)')
        )
        .order_by(User.full_name)
    )

    result = await session.execute(stmt)
    return [
        {
            "full_name": row.full_name,
            "username": row.telegram_username,
            "blood_group": f"{row.blood_type}{row.rh_factor}"
        }
        for row in result
    ]

async def get_top_faculties(session: AsyncSession) -> list[dict]:
    """
    Возвращает самые активные факультеты по количеству донаций.
    Логика: Группировка донаций по факультетам пользователей из НИЯУ МИФИ.
    """
    stmt = (
        select(User.faculty, func.count(Donation.id).label("donation_count"))
        .join(Donation, User.id == Donation.user_id)
        .where(User.university == "НИЯУ МИФИ", User.faculty != None)
        .group_by(User.faculty)
        .order_by(func.count(Donation.id).desc())
    )

    result = await session.execute(stmt)
    return [
        {"faculty_name": row.faculty, "donation_count": row.donation_count}
        for row in result
    ]

async def get_dkm_candidates(session: AsyncSession) -> list[dict]:
    """
    Возвращает кандидатов в регистр ДКМ.
    Логика: Пользователи с 2+ донациями, но is_dkm_donor = False.
    """
    subquery = (
        select(Donation.user_id, func.count(Donation.id).label("donation_count"))
        .group_by(Donation.user_id)
        .having(func.count(Donation.id) >= 2)
    ).alias("two_plus_donations")

    stmt = (
        select(User.full_name, User.telegram_username, two_plus_donations.c.donation_count)
        .join(two_plus_donations, User.id == two_plus_donations.c.user_id)
        .where(User.is_dkm_donor == False)
        .order_by(User.full_name)
    )

    result = await session.execute(stmt)
    return [
        {
            "full_name": row.full_name,
            "username": row.telegram_username,
            "donation_count": row.donation_count
        }
        for row in result
    ]

async def get_survey_dropoff(session: AsyncSession) -> list[dict]:
    """
    Возвращает пользователей, "потерянных" после опросника.
    Логика: Есть успешный опросник, но нет регистрации на мероприятие после него.
    """
    # Подзапрос: последняя регистрация для каждого пользователя
    last_reg_subquery = (
        select(
            EventRegistration.user_id,
            func.max(EventRegistration.registration_date).label("last_reg_date")
        )
        .group_by(EventRegistration.user_id)
    ).alias("last_regs")

    # Основной запрос
    stmt = (
        select(User.full_name, User.telegram_username, Survey.created_at)
        .join(Survey, User.id == Survey.user_id)
        .outerjoin(last_reg_subquery, User.id == last_reg_subquery.c.user_id)
        .where(
            (Survey.passed == True) &
            (
                (last_reg_subquery.c.last_reg_date == None) |
                (Survey.created_at > last_reg_subquery.c.last_reg_date)
            )
        )
        # Убедимся, что берем только последнюю запись о прохождении опросника для пользователя
        .distinct(User.id)
        .order_by(User.id, Survey.created_at.desc())
    )

    result = await session.execute(stmt)
    return [
        {
            "full_name": row.full_name,
            "username": row.telegram_username,
            "survey_date": row.created_at
        }
        for row in result
    ]

--- КОНЕЦ ФАЙЛА: bot/db/analytics_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/engine.py ---

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from bot.config_reader import config
from bot.db.models import Base

engine = create_async_engine(
    url=config.database_url,
    echo=False 
)

async_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def create_db_and_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

--- КОНЕЦ ФАЙЛА: bot/db/engine.py ---

--- НАЧАЛО ФАЙЛА: bot/db/event_requests.py ---

import datetime
from sqlalchemy import select, func, delete, or_
from sqlalchemy.ext.asyncio import AsyncSession
from .models import User, Event, EventRegistration, Donation, MedicalWaiver
from sqlalchemy.orm import joinedload
from bot.utils.text_messages import Text

async def get_active_events(session: AsyncSession) -> list[Event]:
    """Получает активные мероприятия."""
    stmt = (
        select(Event)
        .where(Event.is_active == True)
        .order_by(Event.event_datetime.desc())
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_active_events_for_user(session: AsyncSession, user_id: int) -> list[Event]:
    """
    Получает активные мероприятия для пользователя, включая те, на которые он уже записан,
    даже если регистрация на них закрыта.
    """
    user_registrations_subquery = select(EventRegistration.event_id).where(EventRegistration.user_id == user_id)
    stmt = (
        select(Event)
        .where(
            Event.is_active == True,
            Event.event_datetime >= datetime.datetime.now(),
            or_(
                Event.registration_is_open == True,
                Event.id.in_(user_registrations_subquery)
            )
        )
        .order_by(Event.event_datetime)
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_upcoming_events(session: AsyncSession) -> list[Event]:
    """Получает все будущие активные мероприятия (для админки)."""
    stmt = (
        select(Event)
        .where(
            Event.is_active == True,
            Event.event_datetime >= datetime.datetime.now()
        )
        .order_by(Event.event_datetime)
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_event_by_id(session: AsyncSession, event_id: int) -> Event | None:
    """Получает мероприятие по его ID."""
    stmt = select(Event).options(joinedload(Event.blood_center)).where(Event.id == event_id)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def get_today_event(session: AsyncSession) -> Event | None:
    """Получает мероприятие, которое проходит сегодня."""
    today = datetime.date.today()
    stmt = (
        select(Event)
        .where(
            Event.is_active == True,
            func.date(Event.event_datetime) == today
        )
    )
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def check_registration_eligibility(session: AsyncSession, user: User, event: Event) -> tuple[bool, str]:
    """Проверяет, может ли пользователь зарегистрироваться на мероприятие."""
    # Получаем только дату мероприятия для сравнения с медотводами
    event_date = event.event_datetime.date()

    # Проверка 1: Базовые условия мероприятия
    if not event.registration_is_open:
        return False, "Регистрация на это мероприятие закрыта."

    existing_registration = await find_specific_registration(session, user.id, event.id)
    if existing_registration:
        return False, f"Вы уже зарегистрированы на это мероприятие ({event.name})."

    reg_count = await session.scalar(select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event.id))
    if reg_count >= event.participant_limit:
        return False, f"Достигнут лимит участников ({event.participant_limit})."

    # Проверка 2: Существующие медотводы из таблицы MedicalWaiver
    active_waiver_stmt = select(MedicalWaiver).where(
        MedicalWaiver.user_id == user.id,
        MedicalWaiver.end_date >= event_date
    ).order_by(MedicalWaiver.end_date.desc()).limit(1)
    active_waiver = (await session.execute(active_waiver_stmt)).scalar_one_or_none()
    if active_waiver:
        return False, f"У вас действует отвод до {active_waiver.end_date.strftime('%d.%m.%Y')}. Причина: {active_waiver.reason}."

    # Проверка 3: Потенциальные медотводы от ДРУГИХ будущих регистраций
    future_registrations_stmt = (
        select(EventRegistration)
        .join(EventRegistration.event)
        .where(
            EventRegistration.user_id == user.id,
            EventRegistration.status == 'registered',
            Event.event_datetime < event.event_datetime
        )
        .options(joinedload(EventRegistration.event))
        .order_by(Event.event_datetime)
    )
    future_registrations = (await session.execute(future_registrations_stmt)).scalars().all()

    for reg in future_registrations:
        registered_event = reg.event
        if registered_event.donation_type == 'whole_blood':
            interval = 90 if user.gender == 'female' else 60
        else:
            interval = 14

        potential_waiver_end_date = registered_event.event_datetime.date() + datetime.timedelta(days=interval)

        if event_date <= potential_waiver_end_date:
            return False, (f"Запись невозможна. У вас запланирована донация "
                           f"«{registered_event.name}» на {registered_event.event_datetime.strftime('%d.%m.%Y')}, "
                           f"после которой будет действовать медотвод.")

    # Проверка 4: Годовой лимит донаций (с учетом будущих регистраций)
    donation_type = event.donation_type
    
    # Считаем ПРОШЕДШИЕ донации
    past_donations_stmt = select(func.count(Donation.id)).where(
        Donation.user_id == user.id,
        Donation.donation_type == donation_type
    )
    past_donations_count = (await session.execute(past_donations_stmt)).scalar_one()

    # Считаем БУДУЩИЕ запланированные донации такого же типа
    future_registrations_stmt = (
        select(func.count(EventRegistration.id))
        .join(Event)
        .where(
            EventRegistration.user_id == user.id,
            EventRegistration.status == 'registered',
            Event.donation_type == donation_type
        )
    )
    future_registrations_count = (await session.execute(future_registrations_stmt)).scalar_one()

    total_committed_donations = past_donations_count + future_registrations_count
    limit = 0
    limit_reason = ""

    if donation_type == 'whole_blood':
        limit = 4 if user.gender == 'female' else 5
        limit_reason = (f"Вы достигли годового лимита ({limit}) на сдачу цельной крови, "
                        f"учитывая прошлые и запланированные донации.")
    elif donation_type in ['plasma', 'platelets', 'erythrocytes']:
        limit = 12
        limit_reason = (f"Вы достигли годового лимита ({limit}) на сдачу компонентов, "
                        f"учитывая прошлые и запланированные донации.")

    if limit > 0 and total_committed_donations >= limit:
        return False, limit_reason

    return True, "Все проверки пройдены."


async def add_event_registration(session: AsyncSession, user_id: int, event_id: int) -> EventRegistration:
    """Добавляет регистрацию пользователя на мероприятие."""
    registration = EventRegistration(user_id=user_id, event_id=event_id)
    session.add(registration)
    await session.flush()

    event = await session.get(Event, event_id)
    if event:
        reg_count_stmt = select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event_id)
        reg_count = (await session.execute(reg_count_stmt)).scalar_one()
        if reg_count >= event.participant_limit:
            event.registration_is_open = False
            
    await session.commit()
    return registration

async def find_specific_registration(session: AsyncSession, user_id: int, event_id: int) -> EventRegistration | None:
    """Находит конкретную регистрацию пользователя на мероприятие."""
    stmt = select(EventRegistration).options(
        joinedload(EventRegistration.event)
    ).where(
        EventRegistration.user_id == user_id,
        EventRegistration.event_id == event_id,
        EventRegistration.status == 'registered'
    )
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def confirm_donation_transaction(session: AsyncSession, user: User, registration: EventRegistration) -> tuple[int, datetime.date]:
    """Проводит транзакцию подтверждения донации: начисляет баллы, создает медотвод."""
    event = await session.get(Event, registration.event_id)
    event_date = event.event_datetime.date() # Получаем только дату для донации и медотвода
            
    points_to_award = event.points_per_donation

    # Создаем запись о донации
    donation = Donation(
        user_id=user.id,
        event_id=event.id,
        donation_date=event_date,
        donation_type=event.donation_type,
        points_awarded=points_to_award
    )
    
    # Создаем системный медотвод
    days_waiver = (90 if user.gender == 'female' else 60) if event.donation_type == 'whole_blood' else 14
    end_date = event_date + datetime.timedelta(days=days_waiver)
    russian_donation_type = Text.DONATION_TYPE_RU.get(event.donation_type, event.donation_type)
    waiver = MedicalWaiver(
        user_id=user.id,
        start_date=event_date,
        end_date=end_date,
        reason=f"Сдача «{russian_donation_type}»",
        created_by='system'
    )

    # Обновляем пользователя и регистрацию
    user.points += points_to_award
    registration.status = 'attended'

    session.add_all([donation, waiver])
    await session.commit()
    return points_to_award, end_date

async def cancel_registration(session: AsyncSession, user_id: int, event_id: int) -> bool:
    """Отменяет регистрацию пользователя на мероприятие."""
    stmt = delete(EventRegistration).where(
        EventRegistration.user_id == user_id,
        EventRegistration.event_id == event_id
    )
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0

--- КОНЕЦ ФАЙЛА: bot/db/event_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/info_requests.py ---

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from .models import InfoText

async def get_info_text(session: AsyncSession, section_key: str) -> str | None:
    """Получает текст инфо-раздела по ключу."""
    text_obj = await session.get(InfoText, section_key)
    return text_obj.section_text if text_obj else "Раздел не найден."

async def get_all_info_sections(session: AsyncSession) -> list[InfoText]:
    """Получает все инфо-разделы для меню редактирования."""
    result = await session.execute(select(InfoText).order_by(InfoText.section_key))
    return result.scalars().all()

async def update_info_text(session: AsyncSession, section_key: str, new_text: str):
    """Обновляет текст инфо-раздела."""
    stmt = (
        update(InfoText)
        .where(InfoText.section_key == section_key)
        .values(section_text=new_text)
    )
    await session.execute(stmt)
    await session.commit()

--- КОНЕЦ ФАЙЛА: bot/db/info_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/merch_requests.py ---

import math
from sqlalchemy import select, func
from sqlalchemy.orm import joinedload
from sqlalchemy.ext.asyncio import AsyncSession
from .models import User, MerchItem, MerchOrder

async def get_merch_page(session: AsyncSession, page: int = 1) -> tuple[MerchItem | None, int]:
    page_size = 1
    offset = (page - 1) * page_size
    total_count_stmt = select(func.count(MerchItem.id)).where(MerchItem.is_available == True)
    total_items = (await session.execute(total_count_stmt)).scalar_one()
    
    if total_items == 0:
        return None, 0
    item_stmt = select(MerchItem).where(MerchItem.is_available == True).order_by(MerchItem.id).offset(offset).limit(page_size)
    item_result = await session.execute(item_stmt)
    item = item_result.scalar_one_or_none()
    
    return item, total_items

async def get_merch_item_by_id(session: AsyncSession, item_id: int) -> MerchItem | None:
    return await session.get(MerchItem, item_id)

async def create_merch_order(session: AsyncSession, user: User, item: MerchItem) -> tuple[bool, str]:
    if user.points < item.price:
        return False, "Недостаточно баллов."

    user.points -= item.price
    order = MerchOrder(user_id=user.id, item_id=item.id)
    session.add(order)
    return True, f"Покупка совершена! Ваш баланс: {user.points} баллов."

async def get_user_orders(session: AsyncSession, user_id: int) -> list[MerchOrder]:
    stmt = select(MerchOrder).options(joinedload(MerchOrder.item)).where(MerchOrder.user_id == user_id).order_by(MerchOrder.order_date.desc())
    result = await session.execute(stmt)
    return result.scalars().all()

--- КОНЕЦ ФАЙЛА: bot/db/merch_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/models.py ---

import datetime
from typing import List
from sqlalchemy import (
    String, BigInteger, ForeignKey,
    Integer, Boolean, DateTime, Date, Text, func, Float, JSON
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship

class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = 'users'
    id: Mapped[int] = mapped_column(primary_key=True)
    phone_number: Mapped[str] = mapped_column(String(20), unique=True, nullable=False, index=True)
    telegram_id: Mapped[int] = mapped_column(BigInteger, unique=True, nullable=False, index=True)
    telegram_username: Mapped[str] = mapped_column(String(255), nullable=True, index=True)
    full_name: Mapped[str] = mapped_column(String(255), index=True)
    university: Mapped[str] = mapped_column(String(100), nullable=True, index=True)
    faculty: Mapped[str] = mapped_column(String(100), nullable=True)
    study_group: Mapped[str] = mapped_column(String(50), nullable=True)
    gender: Mapped[str] = mapped_column(String(10), nullable=True)
    points: Mapped[int] = mapped_column(Integer, default=0)
    role: Mapped[str] = mapped_column(String(50), default='student', index=True)
    is_blocked: Mapped[bool] = mapped_column(Boolean, default=False)
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    category: Mapped[str] = mapped_column(String(50), default='student', server_default='student')
    is_dkm_donor: Mapped[bool] = mapped_column(Boolean, default=False, server_default='f')
    consent_given: Mapped[bool] = mapped_column(Boolean, default=False, server_default='f')
    graduation_year: Mapped[int] = mapped_column(Integer, nullable=True)

    donations: Mapped[List["Donation"]] = relationship(back_populates="user")
    registrations: Mapped[List["EventRegistration"]] = relationship(back_populates="user", cascade="all, delete-orphan")
    waivers: Mapped[List["MedicalWaiver"]] = relationship(back_populates="user")
    orders: Mapped[List["MerchOrder"]] = relationship(foreign_keys="MerchOrder.user_id", back_populates="user", cascade="all, delete-orphan")
    blocks_given: Mapped[List["UserBlock"]] = relationship(foreign_keys="UserBlock.admin_id", back_populates="admin")
    blocks_received: Mapped[List["UserBlock"]] = relationship(foreign_keys="UserBlock.user_id", back_populates="blocked_user")


class Event(Base):
    __tablename__ = 'events'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255))
    event_datetime: Mapped[datetime.datetime] = mapped_column(DateTime)
    location: Mapped[str] = mapped_column(Text)
    blood_center_id: Mapped[int] = mapped_column(ForeignKey('blood_centers.id'), nullable=True)
    
    latitude: Mapped[float] = mapped_column(Float, nullable=True)
    longitude: Mapped[float] = mapped_column(Float, nullable=True)
    donation_type: Mapped[str] = mapped_column(String(50))
    points_per_donation: Mapped[int] = mapped_column(Integer)
    participant_limit: Mapped[int] = mapped_column(Integer)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    registration_is_open: Mapped[bool] = mapped_column(Boolean, default=True, server_default='t')

    blood_center: Mapped["BloodCenter"] = relationship(back_populates="events")
    registrations: Mapped[List["EventRegistration"]] = relationship(back_populates="event")
    feedbacks: Mapped[List["Feedback"]] = relationship(back_populates="event")


class EventRegistration(Base):
    __tablename__ = 'event_registrations'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'), index=True)
    status: Mapped[str] = mapped_column(String(50), default='registered')
    registration_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

    user: Mapped["User"] = relationship(back_populates="registrations")
    event: Mapped["Event"] = relationship(back_populates="registrations")

class Donation(Base):
    __tablename__ = 'donations'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'), nullable=True, index=True)
    donation_date: Mapped[datetime.date] = mapped_column(Date)
    donation_type: Mapped[str] = mapped_column(String(50))
    points_awarded: Mapped[int] = mapped_column(Integer)
    feedback_requested: Mapped[bool] = mapped_column(Boolean, default=False, server_default='f', nullable=False)

    user: Mapped["User"] = relationship(back_populates="donations")
    event: Mapped["Event"] = relationship()
    
class Feedback(Base):
    __tablename__ = 'feedbacks'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'))
    
    well_being_score: Mapped[int] = mapped_column(Integer, nullable=True) # 1-5
    well_being_comment: Mapped[str] = mapped_column(Text, nullable=True)
    
    organization_score: Mapped[int] = mapped_column(Integer, nullable=True) # 1-10
    what_liked: Mapped[str] = mapped_column(Text, nullable=True)
    what_disliked: Mapped[str] = mapped_column(Text, nullable=True)
    other_suggestions: Mapped[str] = mapped_column(Text, nullable=True)
    
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

    user: Mapped["User"] = relationship()
    event: Mapped["Event"] = relationship(back_populates="feedbacks")

class MedicalWaiver(Base):
    __tablename__ = 'medical_waivers'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    start_date: Mapped[datetime.date] = mapped_column(Date)
    end_date: Mapped[datetime.date] = mapped_column(Date)
    reason: Mapped[str] = mapped_column(Text)
    created_by: Mapped[str] = mapped_column(String(50))

    user: Mapped["User"] = relationship(back_populates="waivers")

class MerchItem(Base):
    __tablename__ = 'merch_items'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255))
    description: Mapped[str] = mapped_column(Text)
    price: Mapped[int] = mapped_column(Integer)
    photo_file_id: Mapped[str] = mapped_column(String(255))
    is_available: Mapped[bool] = mapped_column(Boolean, default=True)

    orders: Mapped[List["MerchOrder"]] = relationship(back_populates="item")

class MerchOrder(Base):
    __tablename__ = 'merch_orders'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    item_id: Mapped[int] = mapped_column(ForeignKey('merch_items.id'))
    order_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    status: Mapped[str] = mapped_column(String(50), default='pending_pickup')
    completed_by_admin_id: Mapped[int] = mapped_column(ForeignKey('users.id'), nullable=True)
    completion_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), nullable=True)

    user: Mapped["User"] = relationship(foreign_keys=[user_id], back_populates="orders")
    item: Mapped["MerchItem"] = relationship(back_populates="orders")
    completed_by_admin: Mapped["User"] = relationship(foreign_keys=[completed_by_admin_id])


class UserBlock(Base):
    __tablename__ = 'user_blocks'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    admin_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    block_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    reason: Mapped[str] = mapped_column(Text)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    
    blocked_user: Mapped["User"] = relationship(foreign_keys=[user_id], back_populates="blocks_received")
    admin: Mapped["User"] = relationship(foreign_keys=[admin_id], back_populates="blocks_given")
    
class Survey(Base):
    __tablename__ = 'surveys'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    passed: Mapped[bool] = mapped_column(Boolean, nullable=False)
    answers_json: Mapped[dict] = mapped_column(JSON, nullable=False)
    verdict_text: Mapped[str] = mapped_column(Text, nullable=True)
    
    user: Mapped["User"] = relationship()
    
    
class InfoText(Base):
    __tablename__ = 'info_texts'
    section_key: Mapped[str] = mapped_column(String(50), primary_key=True)
    section_title: Mapped[str] = mapped_column(String(100))
    section_text: Mapped[str] = mapped_column(Text)
    
class Question(Base):
    __tablename__ = 'questions'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    
    question_text: Mapped[str] = mapped_column(Text)
    answer_text: Mapped[str] = mapped_column(Text, nullable=True)
    
    status: Mapped[str] = mapped_column(String(50), default='unanswered', index=True) # unanswered, answered
    
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    answered_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), nullable=True)
    answered_by_admin_id: Mapped[int] = mapped_column(ForeignKey('users.id'), nullable=True)

    user: Mapped["User"] = relationship(foreign_keys=[user_id])
    answered_by_admin: Mapped["User"] = relationship(foreign_keys=[answered_by_admin_id])
    
    
    
class NoShowReport(Base):
    __tablename__ = 'no_show_reports'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'), index=True)
    reason: Mapped[str] = mapped_column(String(100))
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    user: Mapped["User"] = relationship()
    event: Mapped["Event"] = relationship()
    
class BloodCenter(Base):
    __tablename__ = 'blood_centers'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)

    events: Mapped[List["Event"]] = relationship(back_populates="blood_center")


class Report(Base):
    __tablename__ = 'reports'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255))
    data: Mapped[dict] = mapped_column(JSON)
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

--- КОНЕЦ ФАЙЛА: bot/db/models.py ---

--- НАЧАЛО ФАЙЛА: bot/db/qa_management.py ---

from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import question_requests, user_requests
from bot.filters.role import RoleFilter
from bot.states.states import AnswerQuestion
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router(name="admin_qa_management")

@router.callback_query(F.data == "admin_answer_questions", RoleFilter('admin'))
async def show_unanswered_questions(callback: types.CallbackQuery, session: AsyncSession):
    questions = await question_requests.get_unanswered_questions(session)
    if not questions:
        await callback.answer("Новых вопросов от пользователей нет.", show_alert=True)
        return

    builder = types.InlineKeyboardBuilder()
    for q in questions:
        builder.row(types.InlineKeyboardButton(
            text=f"От {q.user.full_name}: {q.question_text[:30]}...",
            callback_data=f"answer_q_{q.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    
    await callback.message.edit_text(
        "<b>Неотвеченные вопросы:</b>\n\nВыберите вопрос, чтобы ответить:",
        reply_markup=builder.as_markup()
    )
    await callback.answer()

@router.callback_query(F.data.startswith("answer_q_"), RoleFilter('admin'))
async def start_answering_question(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    question_id = int(callback.data.split("_")[-1])
    question = await session.get(question_requests.Question, question_id)
    if not question:
        await callback.answer("Вопрос не найден.", show_alert=True)
        return
        
    await state.set_state(AnswerQuestion.awaiting_answer)
    await state.update_data(question_id=question.id, user_to_answer_id=question.user.telegram_id)
    
    await callback.message.edit_text(
        f"<b>Вопрос от:</b> {question.user.full_name}\n"
        f"<b>Текст вопроса:</b>\n<i>{Text.escape_html(question.question_text)}</i>\n\n"
        f"<b>Введите ваш ответ:</b>"
    )
    await callback.answer()

@router.message(AnswerQuestion.awaiting_answer)
async def process_answer(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    question_id = data.get("question_id")
    user_to_answer_id = data.get("user_to_answer_id")
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    
    await question_requests.answer_question(session, question_id, message.text, admin_user.id)
    
    question = await session.get(question_requests.Question, question_id)

    try:
        await bot.send_message(
            chat_id=user_to_answer_id,
            text=(
                f"📨 <b>Получен ответ на ваш вопрос!</b>\n\n"
                f"<b>Ваш вопрос:</b>\n<i>{Text.escape_html(question.question_text)}</i>\n\n"
                f"<b>Ответ организаторов:</b>\n{Text.escape_html(message.text)}"
            )
        )
    except Exception as e:
        await message.answer(f"Не удалось уведомить пользователя. Ошибка: {e}")

    await state.clear()
    await message.answer("✅ Ответ отправлен пользователю.", reply_markup=inline.get_back_to_admin_panel_keyboard())

--- КОНЕЦ ФАЙЛА: bot/db/qa_management.py ---

--- НАЧАЛО ФАЙЛА: bot/db/question_requests.py ---

import datetime
from sqlalchemy import select, update
from sqlalchemy.orm import joinedload
from sqlalchemy.ext.asyncio import AsyncSession
from .models import Question, User

async def create_question(session: AsyncSession, user_id: int, question_text: str):
    """Сохраняет новый вопрос от пользователя."""
    new_question = Question(user_id=user_id, question_text=question_text)
    session.add(new_question)
    await session.commit()

async def get_unanswered_questions(session: AsyncSession) -> list[Question]:
    """Получает список неотвеченных вопросов с информацией о пользователе."""
    stmt = (
        select(Question)
        .options(joinedload(Question.user))
        .where(Question.status == 'unanswered')
        .order_by(Question.created_at)
    )
    result = await session.execute(stmt)
    return result.scalars().all()

async def answer_question(session: AsyncSession, question_id: int, answer_text: str, admin_id: int):
    """Сохраняет ответ на вопрос и обновляет его статус."""
    stmt = (
        update(Question)
        .where(Question.id == question_id)
        .values(
            answer_text=answer_text,
            status='answered',
            answered_at=datetime.datetime.now(),
            answered_by_admin_id=admin_id
        )
    )
    await session.execute(stmt)
    await session.commit()

--- КОНЕЦ ФАЙЛА: bot/db/question_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/user_requests.py ---

import datetime
from sqlalchemy import select, func, update, delete 
from sqlalchemy.ext.asyncio import AsyncSession
from .models import User, Donation, MedicalWaiver
from sqlalchemy import and_, or_, not_
from sqlalchemy.orm import aliased, joinedload 
from .models import User, Donation, MedicalWaiver, Event, Survey
import logging
logger = logging.getLogger(__name__)


async def update_user_credentials(session: AsyncSession, user_id: int, new_tg_id: int, new_username: str | None):
    # Обновить Telegram ID и username
    stmt = update(User).where(User.id == user_id).values(
        telegram_id=new_tg_id,
        telegram_username=new_username
    )
    await session.execute(stmt)
    await session.commit()


async def get_user_by_phone(session: AsyncSession, phone: str) -> User | None:
    # Найти пользователя по телефону
    stmt = select(User).where(User.phone_number == phone)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def get_user_by_tg_id(session: AsyncSession, tg_id: int) -> User | None:
    # Найти пользователя по Telegram ID
    stmt = select(User).where(User.telegram_id == tg_id)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

# --- ИЗМЕНЕНИЕ: Убираем commit из этой функции ---
async def add_user(session: AsyncSession, data: dict) -> User:
    # Добавить пользователя
    user = User(**data)
    session.add(user)
    # await session.commit()  # <-- УБИРАЕМ ЭТУ СТРОКУ
    return user
# --- КОНЕЦ ИЗМЕНЕНИЯ ---

async def update_user_tg_id(session: AsyncSession, user_id: int, new_tg_id: int):
    # Обновить Telegram ID
    stmt = update(User).where(User.id == user_id).values(telegram_id=new_tg_id)
    await session.execute(stmt)
    await session.commit()
    
async def update_user_profile(session: AsyncSession, user_id: int, data: dict):
    # Обновить профиль пользователя
    stmt = update(User).where(User.id == user_id).values(**data)
    await session.execute(stmt)
    await session.commit()

async def get_user_profile_info(session: AsyncSession, user_id: int) -> dict | None:
    user = await session.get(User, user_id)
    if not user:
        return None

    stmt_last_donation = (
        select(Donation)
        .options(joinedload(Donation.event))
        .where(Donation.user_id == user.id)
        .order_by(Donation.donation_date.desc())
        .limit(1)
    )
    last_donation_obj = (await session.execute(stmt_last_donation)).scalar_one_or_none()

    today = datetime.date.today()
    stmt_waiver = select(MedicalWaiver.end_date).where(MedicalWaiver.user_id == user.id, MedicalWaiver.end_date >= today).order_by(MedicalWaiver.end_date.desc()).limit(1)
    active_waiver_end_date = (await session.execute(stmt_waiver)).scalar_one_or_none()
    
    next_possible_donation = today
    if active_waiver_end_date:
        next_possible_donation = active_waiver_end_date + datetime.timedelta(days=1)
    
    if last_donation_obj:
        last_date = last_donation_obj.donation_date
        last_type = last_donation_obj.donation_type
        if last_type == 'whole_blood':
            interval = 90 if user.gender == 'female' else 60
            possible_date = last_date + datetime.timedelta(days=interval)
        else:
            interval = 14
            possible_date = last_date + datetime.timedelta(days=interval)
        next_possible_donation = max(next_possible_donation, possible_date)

    total_donations = await session.scalar(select(func.count(Donation.id)).where(Donation.user_id == user.id))

    return {
        "user": user,
        "total_donations": total_donations,
        "next_possible_donation": next_possible_donation,
        "last_donation": last_donation_obj 
    }

async def get_user_donation_history(session: AsyncSession, user_id: int) -> list[Donation]:
    # История донаций пользователя
    stmt = select(Donation).where(Donation.user_id == user_id).order_by(Donation.donation_date.desc())
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_user_active_waivers(session: AsyncSession, user_id: int) -> list[MedicalWaiver]:
    # Активные медотводы пользователя
    stmt = select(MedicalWaiver).where(
        MedicalWaiver.user_id == user_id,
        MedicalWaiver.end_date >= datetime.date.today()
    ).order_by(MedicalWaiver.end_date)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_user_by_id(session: AsyncSession, user_id: int) -> User | None:
    # Найти пользователя по ID
    return await session.get(User, user_id)

async def get_all_users(session: AsyncSession) -> list[User]:
    # Все пользователи
    stmt = select(User).order_by(User.full_name)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_users_for_event_notification(session: AsyncSession, event: Event) -> list[User]:
    """
    Возвращает список пользователей, которые могут быть уведомлены о мероприятии.
    Фильтрует по активным медотводам, интервалам между донациями и годовым лимитам.
    """
    event_date_only = event.event_datetime.date()

    # 1. Получаем всех пользователей, у которых нет активных медотводов на дату мероприятия
    active_waiver_subquery = select(MedicalWaiver.user_id).where(MedicalWaiver.end_date >= event_date_only).distinct()
    query = select(User).where(not_(User.id.in_(active_waiver_subquery)))
    initial_users = (await session.execute(query)).scalars().all()
    
    final_users_to_notify = []
    one_year_ago = event_date_only - datetime.timedelta(days=365)
    
    for user in initial_users:
        # Получаем донации за год
        donations_stmt = select(Donation).where(
            Donation.user_id == user.id,
            Donation.donation_date >= one_year_ago
        ).order_by(Donation.donation_date.desc())
        user_donations = (await session.execute(donations_stmt)).scalars().all()

        # --- Проверка 1: Годовые лимиты ---
        donations_of_event_type = [d for d in user_donations if d.donation_type == event.donation_type]
        
        if event.donation_type == 'whole_blood':
            limit = 4 if user.gender == 'female' else 5
            if len(donations_of_event_type) >= limit:
                continue
        else: # для компонентов
            limit = 12
            if len(donations_of_event_type) >= limit:
                continue

        # --- Проверка 2: Интервалы ---
        if not user_donations:
            final_users_to_notify.append(user)
            continue
            
        # Правило 2.1: Проверяем отвод от последней донации ЛЮБОГО типа
        last_donation = user_donations[0]
        
        if last_donation.donation_type == 'whole_blood':
            interval = 90 if user.gender == 'female' else 60
        else:
            interval = 14
        
        # Дата, когда отвод от последней донации заканчивается.
        waiver_end_date_from_last = last_donation.donation_date + datetime.timedelta(days=interval)
        
        # Если дата мероприятия меньше или равна дате окончания отвода, то сдавать нельзя.
        if event_date_only <= waiver_end_date_from_last:
            continue

        # Правило 2.2: Если предстоит сдача ЦЕЛЬНОЙ КРОВИ, нужна доп. проверка
        if event.donation_type == 'whole_blood':
            donations_whole_blood = [d for d in user_donations if d.donation_type == 'whole_blood']
            if donations_whole_blood:
                last_whole_blood_donation = donations_whole_blood[0]
                interval_whole = 90 if user.gender == 'female' else 60
                
                waiver_end_date_from_last_whole = last_whole_blood_donation.donation_date + datetime.timedelta(days=interval_whole)
                
                if event_date_only <= waiver_end_date_from_last_whole:
                    continue
        
        final_users_to_notify.append(user)
            
    return final_users_to_notify

async def get_users_for_mailing(session: AsyncSession, filters: dict) -> list[User]:
    """
    Возвращает список пользователей для рассылки на основе набора фильтров.
    """
    stmt = select(User)
    
    # Копируем фильтры, чтобы безопасно изменять их
    filters_to_apply = filters.copy()
    
    # Сначала обрабатываем специальный фильтр по ролям
    if 'role' in filters_to_apply:
        role_filter = filters_to_apply.pop('role') # Извлекаем и удаляем, чтобы не попасть в цикл ниже
        if role_filter == 'volunteers':
            stmt = stmt.where(User.role.in_(['volunteer', 'admin', 'main_admin']))
        elif role_filter == 'admins':
            stmt = stmt.where(User.role.in_(['admin', 'main_admin']))
        # Если role_filter == 'all', то ничего не делаем, это фильтр по умолчанию

    # Применяем остальные фильтры по атрибутам
    for key, value in filters_to_apply.items():
        if hasattr(User, key):
            stmt = stmt.where(getattr(User, key) == value)

    result = await session.execute(stmt.order_by(User.id))
    return result.scalars().all()


async def add_user_waiver(session: AsyncSession, user_id: int, end_date: datetime.date, reason: str):
    """Создает медотвод от имени пользователя."""
    waiver = MedicalWaiver(
        user_id=user_id,
        start_date=datetime.date.today(),
        end_date=end_date,
        reason=reason,
        created_by='user' 
    )
    session.add(waiver)
    await session.commit()

async def delete_user_waiver(session: AsyncSession, waiver_id: int, user_id: int) -> bool:
    """
    Удаляет медотвод, если он был создан этим же пользователем.
    Возвращает True в случае успеха.
    """
    stmt = (
        delete(MedicalWaiver)
        .where(
            MedicalWaiver.id == waiver_id,
            MedicalWaiver.user_id == user_id,
            MedicalWaiver.created_by == 'user'
        )
    )
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0

async def check_recent_survey(session: AsyncSession, user_id: int) -> bool:
    """
    Проверяет, проходил ли пользователь успешно опросник за последние 24 часа.
    Возвращает True, если да, иначе False.
    """
    twenty_four_hours_ago = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(hours=24)
    
    stmt = (
        select(Survey)
        .where(
            Survey.user_id == user_id,
            Survey.passed == True,
            Survey.created_at >= twenty_four_hours_ago
        )
        .order_by(Survey.created_at.desc())
        .limit(1)
    )
    
    result = await session.execute(stmt)
    recent_survey = result.scalar_one_or_none()
    
    return recent_survey is not None


async def get_unlinked_user_by_fio(session: AsyncSession, full_name: str) -> User | None:
    """
    Ищет пользователя по ФИО среди тех, у кого telegram_id <= 0.
    """
    stmt = select(User).where(
        User.full_name == full_name,
        User.telegram_id <= 0
    )
    result = await session.execute(stmt)
    return result.scalar_one_or_none()


async def is_profile_complete(session: AsyncSession, user_id: int) -> bool:
    """
    Проверяет, все ли обязательные поля в профиле пользователя заполнены.
    """
    user = await session.get(User, user_id)
    if not user:
        return False

    required_fields = ['full_name', 'phone_number', 'university', 'faculty', 'study_group', 'gender']
    for field in required_fields:
        if not getattr(user, field):
            return False
    return True

--- КОНЕЦ ФАЙЛА: bot/db/user_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/__init__.py ---

from . import user_requests
from . import event_requests
from . import merch_requests
from . import admin_requests
from . import info_requests
from . import question_requests

__all__ = [
    "user_requests",
    "event_requests",
    "merch_requests",
    "admin_requests",
    "info_requests",
    "question_requests",
]

--- КОНЕЦ ФАЙЛА: bot/db/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/filters/role.py ---

from typing import Union
from aiogram.filters import BaseFilter
from aiogram.types import Message, CallbackQuery
from bot.db import user_requests
from sqlalchemy.ext.asyncio import AsyncSession

ROLE_HIERARCHY = {
    'student': 0,
    'volunteer': 1,
    'admin': 2,
    'main_admin': 3
}

class RoleFilter(BaseFilter):
    def __init__(self, required_role: str):
        self.required_level = ROLE_HIERARCHY.get(required_role, 0)

    async def __call__(self, event: Union[Message, CallbackQuery], session: AsyncSession) -> bool:
        user = await user_requests.get_user_by_tg_id(session, event.from_user.id)
        if not user:
            return False
        
        if user.is_blocked:
            return False
            
        user_level = ROLE_HIERARCHY.get(user.role, 0)
        return user_level >= self.required_level

--- КОНЕЦ ФАЙЛА: bot/filters/role.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/common.py ---

from aiogram import Router, F, types
from aiogram.filters import CommandStart, Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import any_state
from aiogram.types import ReplyKeyboardRemove
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.exceptions import TelegramBadRequest

from bot.db import user_requests
from bot.states.states import Registration
from bot.keyboards import reply, inline
from bot.utils.text_messages import Text
from bot.utils.graduation import calculate_graduation_year
from bot.filters.role import RoleFilter

ROLE_MENU_MAP = {
    'student': inline.get_student_main_menu,
    'volunteer': inline.get_volunteer_main_menu,
    'admin': inline.get_admin_main_menu,
    'main_admin': inline.get_main_admin_main_menu
}

router = Router()

# =============================================================================
# --- УНИВЕРСАЛЬНАЯ ФУНКЦИЯ ОТПРАВКИ/РЕДАКТИРОВАНИЯ МЕНЮ ---
# =============================================================================

async def send_or_edit_main_menu(
    event: types.Message | types.CallbackQuery, 
    session: AsyncSession, 
    welcome_text: str = None, 
    force_role: str = None
):
    """
    Универсальная функция для отправки или редактирования главного меню ОДНИМ сообщением.
    """
    user = await user_requests.get_user_by_tg_id(session, event.from_user.id)
    message_to_handle = getattr(event, 'message', event)
    
    
    if not user:
        if isinstance(event, types.CallbackQuery):
            await event.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        else:
            await message_to_handle.answer(Text.WELCOME, reply_markup=reply.get_contact_keyboard())
        return

    if user.is_blocked:
        await message_to_handle.answer(Text.USER_BLOCKED_MESSAGE, reply_markup=ReplyKeyboardRemove())
        return

    if welcome_text:
        greeting = welcome_text
    elif force_role == 'student':
        greeting = Text.SWITCH_TO_DONOR_VIEW
    else:
        greeting = Text.WELCOME_BACK.format(name=user.full_name)

    combined_text = f"{greeting}\n\n{Text.MAIN_MENU_PROMPT}"
    effective_role = force_role if force_role else user.role
    menu_func = ROLE_MENU_MAP.get(effective_role, inline.get_student_main_menu)
    inline_kbd = menu_func(viewer_role=user.role)

    if isinstance(event, types.Message):
        await message_to_handle.answer(
            combined_text,
            reply_markup=inline_kbd,
            parse_mode="HTML"
        )
    elif isinstance(event, types.CallbackQuery):
        try:
            await message_to_handle.edit_text(combined_text, reply_markup=inline_kbd, parse_mode="HTML")
        except TelegramBadRequest as e:
            if "message is not modified" in str(e):
                await event.answer()
            else:
                await message_to_handle.delete()
                await message_to_handle.answer(combined_text, reply_markup=inline_kbd, parse_mode="HTML")
        await event.answer()


@router.message(F.text == "🏠 Домой")
@router.message(CommandStart())
async def cmd_start_or_home(message: types.Message, session: AsyncSession):
    await send_or_edit_main_menu(message, session)


@router.callback_query(F.data == "back_to_main_menu")
async def handle_back_to_main_menu(callback: types.CallbackQuery, session: AsyncSession):
    await send_or_edit_main_menu(callback, session)


@router.callback_query(F.data == "switch_to_donor_view")
async def handle_switch_to_donor_view(callback: types.CallbackQuery, session: AsyncSession):
    await send_or_edit_main_menu(callback, session, force_role='student')


# =============================================================================
# --- ЛОГИКА РЕГИСТРАЦИИ (ИСПРАВЛЕННАЯ ВЕРСИЯ) ---
# =============================================================================

@router.message(F.contact)
async def handle_contact(message: types.Message, session: AsyncSession, state: FSMContext):
    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    if user:
        await send_or_edit_main_menu(message, session, welcome_text=Text.ALREADY_REGISTERED.format(name=user.full_name))
        return

    contact = message.contact
    phone_number = contact.phone_number
    if not phone_number.startswith('+'):
        phone_number = '+' + phone_number

    user_by_phone = await user_requests.get_user_by_phone(session, phone_number)
    if user_by_phone:
        if user_by_phone.is_blocked:
            await message.answer(Text.USER_BLOCKED_ON_AUTH, reply_markup=ReplyKeyboardRemove())
            return

        await user_requests.update_user_credentials(session, user_by_phone.id, message.from_user.id, message.from_user.username)
        await session.commit()

        if not await user_requests.is_profile_complete(session, user_by_phone.id):
            await message.answer("Ваш профиль был найден, но он не полон. Давайте его дозаполним.")
            await state.update_data(
                phone_number=user_by_phone.phone_number,
                telegram_id=message.from_user.id,
                telegram_username=message.from_user.username
            )
            await state.set_state(Registration.awaiting_full_name)
            await message.answer(Text.GET_FULL_NAME)
        else:
            await send_or_edit_main_menu(message, session, welcome_text=Text.AUTH_SUCCESS.format(name=user_by_phone.full_name))
    else:
        await state.update_data(
            phone_number=phone_number,
            telegram_id=message.from_user.id,
            telegram_username=message.from_user.username
        )
        await message.answer(Text.START_REGISTRATION, reply_markup=ReplyKeyboardRemove())
        await message.answer(Text.GET_FULL_NAME)
        await state.set_state(Registration.awaiting_full_name)


@router.message(Registration.awaiting_full_name)
async def process_full_name(message: types.Message, state: FSMContext, session: AsyncSession):
    full_name = message.text.strip()

    allowed_chars = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя-"
    if not all(c.lower() in allowed_chars or c.isspace() for c in full_name):
        await message.answer(Text.FIO_VALIDATION_ERROR)
        return

    name_parts = full_name.split()
    if len(name_parts) < 2:
        await message.answer("Пожалуйста, введите как минимум Фамилию и Имя.")
        return

    corrected_name = " ".join([part.strip().capitalize() for part in name_parts])

    user_by_fio = await user_requests.get_unlinked_user_by_fio(session, corrected_name)
    if user_by_fio:
        user_data = await state.get_data()
        await user_requests.update_user_credentials(session, user_by_fio.id, user_data['telegram_id'], user_data['telegram_username'])
        await session.commit()

        if not await user_requests.is_profile_complete(session, user_by_fio.id):
            await message.answer("Ваш профиль был найден, но он не полон. Давайте его дозаполним.")
            await state.update_data(full_name=corrected_name)
            await message.answer(Text.GET_CATEGORY, reply_markup=inline.get_category_keyboard())
            await state.set_state(Registration.awaiting_category)
        else:
            await state.clear()
            await send_or_edit_main_menu(message, session,
                                           welcome_text=Text.AUTH_SUCCESS.format(name=user_by_fio.full_name))
        return

    await state.update_data(full_name=corrected_name)

    await message.answer(Text.GET_CATEGORY, reply_markup=inline.get_category_keyboard())
    await state.set_state(Registration.awaiting_category)


# --- НОВЫЙ ХЕНДЛЕР: Обработка категории ---
@router.callback_query(Registration.awaiting_category, F.data.startswith('category_'))
async def process_category(callback: types.CallbackQuery, state: FSMContext):
    category = callback.data.split('_', 1)[1]
    await state.update_data(category=category)

    if category == 'external':
        await state.update_data(university="Внешний донор", faculty="Не применимо", study_group="-")
        await callback.message.edit_text(Text.GET_GENDER, reply_markup=inline.get_gender_inline_keyboard())
        await state.set_state(Registration.awaiting_gender)
    elif category == 'student':
        await state.update_data(university="НИЯУ МИФИ")
        await callback.message.edit_text(Text.GET_FACULTY, reply_markup=inline.get_faculties_keyboard())
        await state.set_state(Registration.awaiting_faculty)
    else: # employee
        await state.update_data(university="НИЯУ МИФИ", faculty="Сотрудник", study_group="-")
        await callback.message.edit_text(Text.GET_GENDER, reply_markup=inline.get_gender_inline_keyboard())
        await state.set_state(Registration.awaiting_gender)

    await callback.answer()




@router.callback_query(Registration.awaiting_faculty, F.data.startswith('faculty_'))
async def process_faculty(callback: types.CallbackQuery, state: FSMContext):
    faculty = callback.data.split('_', 1)[1]
    
    if faculty == 'Other':
        await callback.message.edit_text(Text.GET_CUSTOM_FACULTY)
        await state.set_state(Registration.awaiting_custom_faculty_name)
    else:
        await state.update_data(faculty=faculty)
        await callback.message.edit_text(Text.FACULTY_SELECTED.format(faculty=faculty))
        await callback.message.answer(Text.GET_GROUP)
        await state.set_state(Registration.awaiting_study_group)
    
    await callback.answer()


@router.message(Registration.awaiting_custom_faculty_name)
async def process_custom_faculty_name(message: types.Message, state: FSMContext):
    await state.update_data(faculty=message.text)
    await message.answer(Text.GET_GROUP)
    await state.set_state(Registration.awaiting_study_group)


@router.message(Registration.awaiting_study_group)
async def process_study_group(message: types.Message, state: FSMContext):
    group_name = message.text.strip().lower()
    if group_name and group_name[0] not in ['б', 'с', 'м', 'а']:
        await message.answer(
            "Название учебной группы некорректно.\n"
            "Первая буква должна быть одной из следующих: "
            "б - бакалавриат, с - специалитет, м - магистратура, а - аспирантура."
        )
        return

    await state.update_data(study_group=message.text)
    await message.answer(Text.GET_GENDER, reply_markup=inline.get_gender_inline_keyboard())
    await state.set_state(Registration.awaiting_gender)


@router.callback_query(Registration.awaiting_gender, F.data.startswith("gender_"))
async def process_gender(callback: types.CallbackQuery, state: FSMContext):
    gender = callback.data.split('_', 1)[1]
    gender_text = "Мужской" if gender == "male" else "Женский"
    
    await callback.message.edit_text(Text.GENDER_SELECTED.format(gender=gender_text))
    await state.update_data(gender=gender)
    
    await callback.message.answer(
        Text.CONSENT_TEXT, 
        reply_markup=inline.get_consent_keyboard(),
        parse_mode="HTML"
    )
    await state.set_state(Registration.awaiting_consent)
    await callback.answer()



@router.callback_query(Registration.awaiting_consent, F.data == "consent_given")
async def process_consent(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    user_data = await state.get_data()
    telegram_id = user_data.get('telegram_id')

    existing_user = await user_requests.get_user_by_tg_id(session, telegram_id)

    if existing_user:
        update_data = {
            'full_name': user_data.get('full_name'),
            'university': user_data.get('university'),
            'faculty': user_data.get('faculty'),
            'study_group': user_data.get('study_group'),
            'gender': user_data.get('gender'),
            'graduation_year': calculate_graduation_year(user_data.get('study_group')),
        }
        await user_requests.update_user_profile(session, existing_user.id, update_data)
        user_to_greet = await user_requests.get_user_by_id(session, existing_user.id)
    else:
        user_data['consent_given'] = True
        user_data['graduation_year'] = calculate_graduation_year(user_data.get('study_group'))
        user_to_greet = await user_requests.add_user(session, user_data)

    await session.commit()
    await state.clear()

    await callback.message.delete()

    await callback.message.answer(
        text=f"{Text.REGISTRATION_COMPLETE.format(name=user_to_greet.full_name)}\n\n{Text.MAIN_MENU_PROMPT}",
        reply_markup=ROLE_MENU_MAP.get(user_to_greet.role, inline.get_student_main_menu)(
            viewer_role=user_to_greet.role)
    )

    await callback.message.answer(
        text="Теперь вам доступно главное меню.",
        reply_markup=reply.get_home_keyboard()
    )

    await callback.answer()


# =============================================================================
# ПРОЧИЕ ОБРАБОТЧИКИ
# =============================================================================

@router.message(Command("cancel"), StateFilter(any_state))
@router.callback_query(F.data == "cancel_fsm", StateFilter(any_state))
async def cancel_fsm_handler(event: types.Message | types.CallbackQuery, state: FSMContext, session: AsyncSession):
    current_state = await state.get_state()
    if current_state is None:
        if isinstance(event, types.CallbackQuery): await event.answer()
        return

    await state.clear()
    
    message_to_use = event.message if isinstance(event, types.CallbackQuery) else event
    
    if isinstance(event, types.CallbackQuery):
        await event.message.edit_text(Text.ACTION_CANCELLED)
    else:
        await event.answer(Text.ACTION_CANCELLED)
    
    await send_or_edit_main_menu(message_to_use, session)
    if isinstance(event, types.CallbackQuery):
        await event.answer()


@router.message(Command("secret_admin_123"), RoleFilter('admin'))
async def secret_admin_panel(message: types.Message, session: AsyncSession):
    fake_callback = types.CallbackQuery(
        id=str(message.message_id),
        from_user=message.from_user,
        chat_instance="instance",
        message=message,
        data="admin_panel"
    )
    
    from .admin import show_admin_panel
    await show_admin_panel(fake_callback, session)
    await message.delete()


@router.callback_query(F.data == "switch_to_volunteer_view", RoleFilter('admin'))
async def switch_to_volunteer_view_handler(callback: types.CallbackQuery):
    from aiogram.utils.keyboard import InlineKeyboardBuilder
    builder = InlineKeyboardBuilder()
    builder.row(types.InlineKeyboardButton(text="📷 Подтвердить донацию (QR)", callback_data="confirm_donation_qr"))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад в меню донора", callback_data="switch_to_donor_view"))
    await callback.message.edit_text(
        Text.ADMIN_SWITCH_TO_VOLUNTEER_VIEW,
        reply_markup=builder.as_markup(),
        parse_mode="HTML"
    )
    await callback.answer()

--- КОНЕЦ ФАЙЛА: bot/handlers/common.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/main_admin.py ---

import io
import csv
import logging
import zipfile 
import datetime
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests, user_requests
from bot.states.states import AdminManagement, BlockUser
from bot.keyboards import inline
from bot.filters.role import RoleFilter
from .admin import show_admin_panel as show_admin_panel_logic

# logging.basicConfig(level=logging.INFO)  # Логи закомментированы

router = Router()

@router.callback_query(F.data == "main_admin_panel", RoleFilter('main_admin'))
async def show_unified_admin_panel(callback: types.CallbackQuery, session: AsyncSession):
    # Главная админ-панель с доп. кнопками для главного админа
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer: 
        await callback.answer("Ошибка: не удалось найти ваш профиль.", show_alert=True)
        return

    # ИСПРАВЛЕНО: parse_mode="HTML" и текст с HTML тегами
    await callback.message.edit_text(
        text="⚙️ <b>Панель администратора</b>",
        reply_markup=inline.get_admin_panel_keyboard(viewer.role),
        parse_mode="HTML"
    )
    await callback.answer()


# @router.callback_query(F.data == "main_admin_panel", RoleFilter('main_admin'))
# async def show_main_admin_panel(callback: types.CallbackQuery):
#     await callback.message.edit_text(
#         text="👑 *Панель Главного Администратора*",
#         reply_markup=inline.get_main_admin_panel_keyboard(),
#         parse_mode="Markdown"
#     )
#     await callback.answer()

# @router.callback_query(F.data == "admin_panel", RoleFilter('main_admin'))
# async def show_admin_panel_for_main_admin(callback: types.CallbackQuery):
#     await show_admin_panel_logic(callback)

--- КОНЕЦ ФАЙЛА: bot/handlers/main_admin.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/other.py ---

from aiogram import Router, types
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db import user_requests
from bot.keyboards import reply
from bot.utils.text_messages import Text

router = Router()

@router.message()
async def handle_unknown_message(message: types.Message, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    if not user:
        await message.answer(Text.WELCOME, reply_markup=reply.get_contact_keyboard())
    else:
        await message.answer(Text.UNKNOWN_COMMAND)

--- КОНЕЦ ФАЙЛА: bot/handlers/other.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/student.py ---

import datetime
import math
import logging
import time
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State 
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db import user_requests, event_requests, merch_requests
from bot.config_reader import config
from bot.keyboards import inline
from bot.utils.qr_service import generate_qr
from bot.utils.text_messages import Text
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.exceptions import TelegramBadRequest
from bot.db.models import MerchItem, Feedback, NoShowReport
from bot.states.states import UserWaiver, FeedbackSurvey
from aiogram.types import BufferedInputFile, WebAppInfo
from bot.utils.calendar_service import generate_ics_file
from bot.db import info_requests

from bot.states.states import UserWaiver, FeedbackSurvey, AskQuestion
from bot.db import user_requests, event_requests, merch_requests, question_requests 


router = Router()
logger = logging.getLogger(__name__)

# --- НОВАЯ УНИВЕРСАЛЬНАЯ ФУНКЦИЯ ---
async def show_events_for_registration(message: types.Message, session: AsyncSession, user_id: int):
    """
    Показывает пользователю список доступных мероприятий для регистрации.
    Эта функция будет вызываться в нескольких местах.
    """
    events = await event_requests.get_active_events_for_user(session, user_id)
    text = ""
    reply_markup = None

    if not events:
        text = "✅ Противопоказаний не найдено.\n\nК сожалению, активных мероприятий для записи сейчас нет."
        builder = InlineKeyboardBuilder()
        builder.row(types.InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_main_menu"))
        reply_markup = builder.as_markup()
    else:
        text = "✅ Противопоказаний не найдено.\n\nВот список доступных мероприятий:"
        builder = InlineKeyboardBuilder()
        for event in events:
            builder.row(types.InlineKeyboardButton(
                text=f"{event.event_datetime.strftime('%d.%m.%Y')} - {event.name}",
                callback_data=f"reg_event_{event.id}"
            ))
        builder.row(types.InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_main_menu"))
        reply_markup = builder.as_markup()
    
    # Редактируем сообщение, если это возможно, иначе отправляем новое
    try:
        await message.edit_text(text, reply_markup=reply_markup)
    except TelegramBadRequest:
        try:
            await message.delete()
        except TelegramBadRequest:
            pass # Если не удалось удалить - не страшно
        await message.answer(text, reply_markup=reply_markup)


# --- 👤 МОЙ ПРОФИЛЬ ---

@router.callback_query(F.data == "my_profile")
async def show_profile_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        text=Text.PROFILE_MENU_HEADER,
        reply_markup=inline.get_profile_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data == "profile_data")
async def show_profile_data(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    profile_data = await user_requests.get_user_profile_info(session, user.id)
    if not profile_data:
        await callback.answer(Text.PROFILE_LOAD_ERROR, show_alert=True)
        return
    
    user_obj = profile_data['user']
    last_donation = profile_data['last_donation']
    
    if last_donation:
        blood_center = last_donation.event.blood_center_name if last_donation.event else "Не указан"
        last_donation_info = f"{last_donation.donation_date.strftime('%d.%m.%Y')} ({Text.escape_html(blood_center)})"
    else:
        last_donation_info = "Еще не было"

    dkm_status = "Да" if user_obj.is_dkm_donor else "Нет"

    text = Text.PROFILE_DATA_TEMPLATE.format(
        full_name=Text.escape_html(user_obj.full_name),
        university=Text.escape_html(user_obj.university),
        faculty=Text.escape_html(user_obj.faculty or 'Не указан'),
        study_group=Text.escape_html(user_obj.study_group or 'Не указана'),
        points=user_obj.points,
        total_donations=profile_data['total_donations'],
        next_date=profile_data['next_possible_donation'].strftime('%d.%m.%Y'),
        last_donation_info=last_donation_info,
        dkm_status=dkm_status
    )
    
    await callback.message.edit_text(text, reply_markup=inline.get_back_to_profile_menu_keyboard(), parse_mode="HTML")
    await callback.answer()

@router.callback_query(F.data == "profile_history")
async def show_donation_history(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    donations = await user_requests.get_user_donation_history(session, user.id)
    if not donations:
        await callback.message.edit_text(Text.NO_DONATION_HISTORY, reply_markup=inline.get_back_to_profile_menu_keyboard())
        return
    history_text = Text.DONATION_HISTORY_HEADER
    for donation in donations:
        donation_type_ru = Text.DONATION_TYPE_RU.get(donation.donation_type, donation.donation_type)
        history_text += Text.DONATION_HISTORY_ITEM.format(
            date=donation.donation_date.strftime('%d.%m.%Y'),
            type=Text.escape_html(donation_type_ru), 
            points=donation.points_awarded
        )
    await callback.message.edit_text(history_text, reply_markup=inline.get_back_to_profile_menu_keyboard(), parse_mode="HTML")
    await callback.answer()

# --- 📅 ЗАПИСЬ НА ДОНАЦИЮ ---

@router.callback_query(F.data == "register_donation")
async def show_survey_or_events(callback: types.CallbackQuery, session: AsyncSession, ngrok_url: str):
    """
    Главный хендлер для "Записаться на донацию".
    Проверяет наличие свежей анкеты. Если она есть - показывает мероприятия.
    Если нет - показывает WebApp для прохождения опроса.
    """
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not user:
        await callback.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        return

    # Проверяем, есть ли сегодня мероприятие
    events = await event_requests.get_active_events_for_user(session, user.id)
    today = datetime.date.today()
    is_today_event_available = any(event.event_datetime.date() == today for event in events)

    if is_today_event_available:
        await show_events_for_registration(callback.message, session, user.id)
        return

    # Проверяем наличие недавнего успешного опросника
    has_recent_survey = await user_requests.check_recent_survey(session, user.id)

    if has_recent_survey:
        # Если опросник пройден, сразу показываем мероприятия
        await callback.answer("Вы уже проходили опросник. Показываю доступные мероприятия.")
        await show_events_for_registration(callback.message, session, user.id)
    else:
        # Если опросника нет, отправляем в WebApp
        if not ngrok_url:
            await callback.answer("Ошибка: Сервис временно недоступен. Попробуйте позже.", show_alert=True)
            return

        cache_buster = int(time.time())
        webapp_url = f"{ngrok_url}/webapp/index.html?v={cache_buster}"
        
        keyboard = types.InlineKeyboardMarkup(
            inline_keyboard=[[
                types.InlineKeyboardButton(
                    text="📝 Пройти опрос перед донацией",
                    web_app=WebAppInfo(url=webapp_url)
                )
            ],[
                types.InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_main_menu")
            ]]
        )
        
        try:
            await callback.message.edit_text(
                "Перед записью на донацию необходимо пройти небольшой опрос для выявления противопоказаний. "
                "Это займет не более минуты. Пожалуйста, отвечайте честно.",
                reply_markup=keyboard
            )
        except TelegramBadRequest:
            try:
                await callback.message.delete()
            except TelegramBadRequest:
                pass
            await callback.message.answer(
                "Перед записью на донацию необходимо пройти небольшой опрос для выявления противопоказаний. "
                "Это займет не более минуты. Пожалуйста, отвечайте честно.",
                reply_markup=keyboard
            )
        await callback.answer()


@router.callback_query(F.data.startswith("reg_event_"))
async def process_event_registration(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    event = await event_requests.get_event_by_id(session, event_id)
    if not user or not event:
        await callback.answer(Text.ERROR_GENERIC_ALERT, show_alert=True)
        return

    safe_event_name = Text.escape_html(event.name)
    
    # Переопределяем клавиатуру прямо здесь для надежности
    def get_reg_success_kbd(ev_id: int):
        builder = InlineKeyboardBuilder()
        builder.row(types.InlineKeyboardButton(text="🔲 Мой QR-код для этого мероприятия", callback_data=f"get_event_qr_{ev_id}"))
        builder.row(types.InlineKeyboardButton(text="🗓️ Добавить в календарь", callback_data=f"add_to_calendar_{ev_id}"))
        builder.row(types.InlineKeyboardButton(text="❌ Отменить мою регистрацию", callback_data=f"cancel_reg_{ev_id}"))
        builder.row(types.InlineKeyboardButton(text="↩️ К списку мероприятий", callback_data="register_donation"))
        return builder.as_markup()

    existing_registration = await event_requests.find_specific_registration(session, user.id, event.id)
    if existing_registration:
        location_link = Text.format_location_link(event.location, event.latitude, event.longitude)
        await callback.message.edit_text(
            text=Text.ALREADY_REGISTERED_FOR_EVENT.format(
                event_name=safe_event_name,
                event_location=location_link,
                blood_center_name=event.blood_center.name if event.blood_center else "Не указан"
            ),
            reply_markup=get_reg_success_kbd(event.id),
            parse_mode="HTML",
            disable_web_page_preview=True
        )
        await callback.answer()
        return

    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    if is_eligible:
        await event_requests.add_event_registration(session, user.id, event_id)
        location_link = Text.format_location_link(event.location, event.latitude, event.longitude)
        
        await callback.message.edit_text(
            text=Text.REGISTRATION_SUCCESSFUL.format(
                event_name=safe_event_name,
                event_location=location_link,
                blood_center_name=event.blood_center.name if event.blood_center else "Не указан"
            ),
            reply_markup=get_reg_success_kbd(event.id),
            parse_mode="HTML",
            disable_web_page_preview=True 
        )
    else:
        await callback.answer(Text.REGISTRATION_FAILED.format(reason=reason), show_alert=True)


@router.callback_query(F.data.startswith("cancel_reg_"))
async def cancel_my_registration(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    telegram_id = callback.from_user.id
    user = await user_requests.get_user_by_tg_id(session, telegram_id)
    if not user:
        await callback.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        return
    success = await event_requests.cancel_registration(session, user.id, event_id)
    if success:
        await callback.message.edit_text(
            Text.REGISTRATION_CANCELLED_SUCCESS,
            reply_markup=inline.get_back_to_main_menu_keyboard()
        )
    else:
        await callback.message.edit_text(
            Text.REGISTRATION_CANCELLED_FAIL,
            reply_markup=inline.get_back_to_main_menu_keyboard()
        )
    await callback.answer()

# --- 🎁 МАГАЗИН МЕРЧА ---

@router.callback_query(F.data == "merch_store")
@router.callback_query(F.data.startswith("merch_page_"))
async def show_merch_store(callback: types.CallbackQuery, session: AsyncSession):
    page = 1
    if callback.data.startswith("merch_page_"):
        page = int(callback.data.split('_')[-1])
    item, total_items = await merch_requests.get_merch_page(session, page=page)
    if not item:
        await callback.answer(Text.MERCH_NO_ITEMS, show_alert=True)
        return
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    caption = Text.MERCH_ITEM_CAPTION.format(
        item_name=item.name,
        item_description=item.description,
        item_price=item.price,
        user_points=user.points
    )
    keyboard = inline.get_merch_store_keyboard(item, page, total_items)
    try:
        await callback.message.edit_media(
            media=types.InputMediaPhoto(media=item.photo_file_id, caption=caption, parse_mode="HTML"),
            reply_markup=keyboard
        )
    except TelegramBadRequest as e:
        if "message is not modified" in str(e):
             await callback.answer()
             return
        await callback.message.delete()
        await callback.message.answer_photo(
            photo=item.photo_file_id,
            caption=caption,
            reply_markup=keyboard,
            parse_mode="HTML"
        )
    await callback.answer()

@router.callback_query(F.data.startswith("buy_merch_"))
async def confirm_purchase(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await merch_requests.get_merch_item_by_id(session, item_id)
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not item:
        await callback.answer(Text.MERCH_ITEM_NOT_FOUND, show_alert=True)
        return
    if user.points < item.price:
        await callback.answer(Text.MERCH_PURCHASE_INSUFFICIENT_FUNDS.format(price=item.price, points=user.points), show_alert=True)
        return
    text = Text.MERCH_PURCHASE_CONFIRMATION.format(
        item_name=item.name,
        item_price=item.price,
        new_balance=user.points - item.price
    )
    await callback.message.edit_caption(
        caption=text,
        reply_markup=inline.get_purchase_confirmation_keyboard(item_id),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("confirm_buy_"))
async def process_purchase(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await merch_requests.get_merch_item_by_id(session, item_id)
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    success, message = await merch_requests.create_merch_order(session, user, item)
    if success:
        await session.commit() 
        await callback.message.edit_caption(
            caption=Text.MERCH_PURCHASE_SUCCESS.format(message=message),
            reply_markup=inline.get_back_to_merch_keyboard()
        )
    else:
        await session.rollback() 
        await callback.answer(Text.MERCH_PURCHASE_ERROR.format(message=message), show_alert=True)
    await callback.answer()

@router.callback_query(F.data == "my_orders")
async def show_my_orders(callback: types.CallbackQuery, session: AsyncSession):
    user_id = callback.from_user.id
    user = await user_requests.get_user_by_tg_id(session, user_id)
    orders = await merch_requests.get_user_orders(session, user.id)
    if not orders:
        text = Text.MERCH_NO_ORDERS
    else:
        text = Text.MERCH_ORDERS_HEADER
        for order in orders:
            text += Text.MERCH_ORDER_ITEM.format(
                item_name=Text.escape_html(order.item.name),
                date=order.order_date.strftime('%d.%m.%Y'),
                status=Text.escape_html(Text.MERCH_STATUS_MAP.get(order.status, 'Неизвестен'))
            )
    try:
        await callback.message.edit_text(
            text,
            reply_markup=inline.get_back_to_merch_keyboard(),
            parse_mode="HTML"
        )
    except TelegramBadRequest:
        await callback.answer(Text.MERCH_UPDATE_ERROR, show_alert=True)
    await callback.answer()


# --- ⚕️ МОИ МЕДОТВОДЫ ---

async def send_waivers_menu(message_to_answer: types.Message, user_tg_id: int, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, user_tg_id)
    
    if not user:
        await message_to_answer.answer(Text.ERROR_PROFILE_NOT_FOUND)
        return

    all_waivers = await user_requests.get_user_active_waivers(session, user.id)
    
    user_created_waivers = [w for w in all_waivers if w.created_by == 'user']
    system_waivers = [w for w in all_waivers if w.created_by != 'user']

    text_parts = [Text.WAIVERS_MENU_HEADER]

    if not all_waivers:
        text_parts.append(Text.NO_ACTIVE_WAIVERS)
    else:
        if system_waivers:
            text_parts.append(Text.SYSTEM_WAIVERS_HEADER)
            for waiver in system_waivers:
                text_parts.append(Text.WAIVER_ITEM_FORMAT.format(
                    end_date=waiver.end_date.strftime('%d.%m.%Y'),
                    reason=Text.escape_html(waiver.reason)
                ))
        
        if user_created_waivers:
            text_parts.append(Text.USER_WAIVERS_HEADER)
            for waiver in user_created_waivers:
                text_parts.append(Text.WAIVER_ITEM_FORMAT.format(
                    end_date=waiver.end_date.strftime('%d.%m.%Y'),
                    reason=Text.escape_html(waiver.reason)
                ))

    text = "\n".join(text_parts)
    keyboard = inline.get_my_waivers_keyboard(user_waivers_exist=bool(user_created_waivers))

    await message_to_answer.answer(text, reply_markup=keyboard, parse_mode="HTML")


@router.callback_query(F.data == "my_waivers")
async def show_my_waivers(callback: types.CallbackQuery, session: AsyncSession):
    try:
        await callback.message.delete()
    except TelegramBadRequest:
        logger.warning("Could not delete message in show_my_waivers, it might have been deleted already.")
    
    await send_waivers_menu(callback.message, callback.from_user.id, session)
    await callback.answer()


@router.callback_query(F.data == "set_user_waiver")
async def set_user_waiver_start(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(UserWaiver.awaiting_end_date)
    await callback.message.edit_text(Text.WAIVER_SET_PROMPT, parse_mode="HTML")
    await callback.answer()

@router.message(UserWaiver.awaiting_end_date)
async def process_user_waiver_date(message: types.Message, state: FSMContext):
    try:
        end_date = datetime.datetime.strptime(message.text, "%d.%m.%Y").date()
        if end_date <= datetime.date.today():
            await message.answer(Text.WAIVER_DATE_IN_PAST_ERROR)
            return
            
        await state.update_data(end_date=end_date)
        await state.set_state(UserWaiver.awaiting_reason)
        await message.answer(Text.WAIVER_REASON_PROMPT)
    except ValueError:
        await message.answer(Text.DATE_FORMAT_ERROR, parse_mode="HTML")

@router.message(UserWaiver.awaiting_reason)
async def process_user_waiver_reason(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    end_date = data['end_date']
    reason = message.text

    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    await user_requests.add_user_waiver(session, user.id, end_date, reason)
    
    await state.clear()
    
    await message.answer(Text.WAIVER_SET_SUCCESS.format(end_date=end_date.strftime('%d.%m.%Y')))
    
    await send_waivers_menu(message, message.from_user.id, session)

@router.callback_query(F.data == "cancel_user_waiver")
async def cancel_user_waiver_start(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    all_waivers = await user_requests.get_user_active_waivers(session, user.id)
    user_created_waivers = [w for w in all_waivers if w.created_by == 'user']
    
    if not user_created_waivers:
        await callback.answer(Text.WAIVER_NOTHING_TO_CANCEL, show_alert=True)
        return

    await callback.message.edit_text(
        Text.WAIVER_CANCELLATION_PROMPT,
        reply_markup=inline.get_waiver_cancellation_keyboard(user_created_waivers)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("delete_waiver_"))
async def process_waiver_deletion(callback: types.CallbackQuery, session: AsyncSession):
    waiver_id = int(callback.data.split('_')[-1])
    
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not user:
        await callback.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        return

    user_internal_id = user.id
    success = await user_requests.delete_user_waiver(session, waiver_id, user_internal_id)
    
    if success:
        await callback.answer(Text.WAIVER_CANCEL_SUCCESS, show_alert=True)
    else:
        await callback.answer(Text.WAIVER_CANCEL_FAIL, show_alert=True)
    
    try:
        await callback.message.delete()
    except TelegramBadRequest:
        logger.warning("Could not delete message in process_waiver_deletion.")

    await send_waivers_menu(callback.message, callback.from_user.id, session)


# --- ℹ️ ПОЛЕЗНАЯ ИНФОРМАЦИЯ ---

@router.callback_query(F.data == "info")
async def show_info_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        text=Text.INFO_MENU_HEADER,
        reply_markup=inline.get_info_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()


@router.callback_query(F.data.startswith("info_"))
async def show_info_text(callback: types.CallbackQuery, session: AsyncSession):
    section = callback.data.split('_', 1)[1]
    text_to_show = await info_requests.get_info_text(session, section)

    await callback.message.edit_text(text_to_show, reply_markup=inline.get_back_to_info_menu_keyboard(), parse_mode="HTML", disable_web_page_preview=True)
    await callback.answer()

# --- 🔲 МОЙ QR-КОД ---

@router.callback_query(F.data == "my_qr_code")
async def send_qr_code(callback: types.CallbackQuery):
    await callback.answer(Text.QR_GENERATING)
    qr_data = {"user_id": callback.from_user.id} 
    qr_image_bytes = await generate_qr(qr_data)
    await callback.message.answer_photo(
        photo=types.BufferedInputFile(qr_image_bytes, filename="my_qr.png"),
        caption=Text.QR_GENERAL_CAPTION
    )

@router.callback_query(F.data.startswith("get_event_qr_"))
async def send_event_qr_code(callback: types.CallbackQuery):
    event_id = int(callback.data.split('_')[-1])
    user_id = callback.from_user.id
    qr_data = {
        "user_id": user_id,
        "event_id": event_id
    }
    await callback.answer(Text.QR_GENERATING)
    qr_image_bytes = await generate_qr(qr_data)
    await callback.message.answer_photo(
        photo=types.BufferedInputFile(qr_image_bytes, filename="event_qr.png"),
        caption=Text.QR_EVENT_CAPTION
    )

# --- НОВЫЙ ХЕНДЛЕР: Добавление в календарь ---
@router.callback_query(F.data.startswith("add_to_calendar_"))
async def send_calendar_file(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event:
        await callback.answer("Мероприятие не найдено.", show_alert=True)
        return

    ics_content = generate_ics_file(event)
    file_to_send = BufferedInputFile(
        file=ics_content.encode('utf-8'),
        filename=f"event_{event.id}.ics"
    )
    
    await callback.message.answer_document(
        document=file_to_send,
        caption=f"🗓️ Календарный файл для мероприятия «{event.name}».\nОткройте его, чтобы добавить событие в ваш календарь."
    )
    await callback.answer()

# --- FSM ДЛЯ ОБРАТНОЙ СВЯЗИ ---

feedback_router = Router()

@feedback_router.callback_query(FeedbackSurvey.awaiting_well_being, F.data.startswith("fb_wb_"))
async def process_well_being(callback: types.CallbackQuery, state: FSMContext):
    score = int(callback.data.split('_')[-1])
    await state.update_data(well_being_score=score)
    
    if score <= 3: 
        await callback.message.edit_text(Text.FEEDBACK_WELL_BEING_BAD)
        await state.set_state(FeedbackSurvey.awaiting_well_being_comment)
    else:
        await callback.message.edit_text(Text.FEEDBACK_GET_ORGANIZATION_SCORE, reply_markup=inline.get_feedback_organization_keyboard())
        await state.set_state(FeedbackSurvey.awaiting_organization_score)
    await callback.answer()

@feedback_router.message(FeedbackSurvey.awaiting_well_being_comment)
async def process_well_being_comment(message: types.Message, state: FSMContext):
    await state.update_data(well_being_comment=message.text)
    await message.answer(Text.FEEDBACK_GET_ORGANIZATION_SCORE, reply_markup=inline.get_feedback_organization_keyboard())
    await state.set_state(FeedbackSurvey.awaiting_organization_score)

@feedback_router.callback_query(FeedbackSurvey.awaiting_organization_score, F.data.startswith("fb_org_"))
async def process_org_score(callback: types.CallbackQuery, state: FSMContext):
    score = int(callback.data.split('_')[-1])
    await state.update_data(organization_score=score)
    await callback.message.edit_text(Text.FEEDBACK_GET_WHAT_LIKED, reply_markup=inline.get_feedback_skip_keyboard())
    await state.set_state(FeedbackSurvey.awaiting_what_liked)
    await callback.answer()

async def skip_or_process_text(event: types.Message | types.CallbackQuery, state: FSMContext, field_name: str, next_state: State, next_text: str, next_keyboard=None):
    is_callback = hasattr(event, 'message')
    message_to_edit = event.message if is_callback else event
    
    if not is_callback: 
        await state.update_data(**{field_name: event.text})
        try:
            await event.delete()
        except TelegramBadRequest:
            pass
    else:
        await state.update_data(**{field_name: "Пропущено"})
        await event.answer()

    try:
        await message_to_edit.edit_text(next_text, reply_markup=next_keyboard)
    except TelegramBadRequest:
        await message_to_edit.delete()
        await message_to_edit.answer(next_text, reply_markup=next_keyboard)
        
    await state.set_state(next_state)

@feedback_router.message(FeedbackSurvey.awaiting_what_liked)
@feedback_router.callback_query(FeedbackSurvey.awaiting_what_liked, F.data == "fb_skip_step")
async def process_what_liked(event: types.Message | types.CallbackQuery, state: FSMContext):
    await skip_or_process_text(event, state, 'what_liked', FeedbackSurvey.awaiting_what_disliked, Text.FEEDBACK_GET_WHAT_DISLIKED, inline.get_feedback_skip_keyboard())

@feedback_router.message(FeedbackSurvey.awaiting_what_disliked)
@feedback_router.callback_query(FeedbackSurvey.awaiting_what_disliked, F.data == "fb_skip_step")
async def process_what_disliked(event: types.Message | types.CallbackQuery, state: FSMContext):
    await skip_or_process_text(event, state, 'what_disliked', FeedbackSurvey.awaiting_other_suggestions, Text.FEEDBACK_GET_OTHER_SUGGESTIONS, inline.get_feedback_skip_keyboard())

@feedback_router.message(FeedbackSurvey.awaiting_other_suggestions)
@feedback_router.callback_query(FeedbackSurvey.awaiting_other_suggestions, F.data == "fb_skip_step")
async def process_other_suggestions(event: types.Message | types.CallbackQuery, state: FSMContext, session: AsyncSession):
    is_callback = hasattr(event, 'message')
    message_to_use = event.message if is_callback else event
    data = await state.get_data()

    if not is_callback:
        final_suggestion = event.text
    else:  
        final_suggestion = "Пропущено"
        await event.answer()

    user = await user_requests.get_user_by_tg_id(session, event.from_user.id)
    
    feedback = Feedback(
        user_id=user.id,
        event_id=data.get('event_id'),
        well_being_score=data.get('well_being_score'),
        well_being_comment=data.get('well_being_comment'),
        organization_score=data.get('organization_score'),
        what_liked=data.get('what_liked'),
        what_disliked=data.get('what_disliked'),
        other_suggestions=final_suggestion
    )
    session.add(feedback)
    await session.commit()
    
    await state.clear()
    
    try:
        await message_to_use.edit_text(Text.FEEDBACK_FINISH)
    except TelegramBadRequest:
        await message_to_use.answer(Text.FEEDBACK_FINISH)
        
        
@router.callback_query(F.data == "ask_question")
async def start_asking_question(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(AskQuestion.awaiting_question)
    await callback.message.edit_text("Напишите ваш вопрос, и организаторы скоро на него ответят.")
    await callback.answer()

@router.message(AskQuestion.awaiting_question)
async def process_question(message: types.Message, state: FSMContext, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    await question_requests.create_question(session, user.id, message.text)
    await state.clear()
    await message.answer(
        "Спасибо! Ваш вопрос отправлен организаторам. Ответ придет сюда же, в этот чат.",
        reply_markup=inline.get_back_to_main_menu_keyboard()
    )
    
    
@router.callback_query(F.data.startswith("no_show_"))
async def process_no_show_reason(callback: types.CallbackQuery, session: AsyncSession):
    _, event_id_str, reason = callback.data.split("_")
    event_id = int(event_id_str)
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)

    report = NoShowReport(user_id=user.id, event_id=event_id, reason=reason)
    session.add(report)
    await session.commit()
    
    await callback.message.edit_text("Спасибо за ваш ответ! Это поможет нам в организации будущих мероприятий.")
    await callback.answer()

--- КОНЕЦ ФАЙЛА: bot/handlers/student.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/volunteer.py ---

import datetime
import logging
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.utils.keyboard import InlineKeyboardBuilder

from bot.db import user_requests, event_requests
from bot.filters.role import RoleFilter
from bot.states.states import VolunteerActions
from bot.utils.qr_service import read_qr
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router()
logger = logging.getLogger(__name__)

@router.callback_query(F.data == "volunteer_panel", RoleFilter('volunteer'))
async def show_volunteer_panel(callback: types.CallbackQuery):
    await callback.message.edit_text(
        Text.VOLUNTEER_MENU_HEADER,
        reply_markup=inline.get_volunteer_panel_keyboard(),
        parse_mode="HTML"  # ИСПРАВЛЕНО
    )
    await callback.answer()

@router.callback_query(F.data == "confirm_donation_qr", RoleFilter('volunteer'))
async def start_qr_confirmation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(VolunteerActions.awaiting_qr_photo)
    await callback.message.edit_text(Text.VOLUNTEER_SEND_QR_PROMPT)
    await callback.answer()

@router.message(VolunteerActions.awaiting_qr_photo, F.photo)
async def process_qr_photo(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    photo_bytes = (await bot.download(message.photo[-1].file_id)).read()
    qr_data = await read_qr(photo_bytes)

    if not qr_data or "user_id" not in qr_data or "event_id" not in qr_data:
        await message.answer(Text.QR_READ_ERROR)
        await state.clear()
        return

    try:
        donor_tg_id = int(qr_data["user_id"])
        event_id_from_qr = int(qr_data["event_id"])
    except (ValueError, TypeError):
        await message.answer(Text.QR_INVALID_DATA_ERROR)
        await state.clear()
        return

    donor = await user_requests.get_user_by_tg_id(session, donor_tg_id)
    event = await event_requests.get_event_by_id(session, event_id_from_qr)
    
    if not donor or not event:
        await message.answer(Text.QR_DB_LOOKUP_ERROR)
        await state.clear()
        return

    registration = await event_requests.find_specific_registration(session, donor.id, event.id)
    if not registration:
        # Для этой строки parse_mode не нужен, т.к. в тексте ошибки нет тегов, но лучше быть последовательным
        await message.answer(Text.QR_DONOR_NOT_REGISTERED_ERROR.format(donor_name=donor.full_name), parse_mode="HTML")
        await state.clear()
        return

    if event.event_datetime.date() != datetime.date.today():
        await message.answer(Text.QR_WRONG_DAY_ERROR) # Здесь нет форматирования, parse_mode не нужен
        await state.clear()
        return

    await state.update_data(
        donor_id=donor.id,
        event_id=event.id,
        donor_tg_id=donor.telegram_id,
        donor_name=donor.full_name,
        event_name=event.name
    )
    await state.set_state(VolunteerActions.awaiting_confirmation)

    await message.answer(
        Text.VOLUNTEER_CONFIRMATION_PROMPT.format(donor_name=donor.full_name, event_name=event.name),
        reply_markup=inline.get_donation_confirmation_keyboard(donor.id, event.id),
        parse_mode="HTML"  # ИСПРАВЛЕНО
    )

@router.callback_query(VolunteerActions.awaiting_confirmation, F.data.startswith("confirm_donation_"))
async def process_donation_confirmation(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    donor_id_from_state = data.get("donor_id")
    event_id_from_state = data.get("event_id")
    
    parts = callback.data.split('_')
    donor_id_from_cb = parts[2]
    event_id_from_cb = parts[3]
    
    if not (donor_id_from_state == int(donor_id_from_cb) and event_id_from_state == int(event_id_from_cb)):
        await callback.message.edit_text(Text.VOLUNTEER_CONFIRMATION_ERROR)
        await state.clear()
        return

    await state.clear()
    await callback.message.edit_text(Text.DONATION_CONFIRMING)
    
    donor = await user_requests.get_user_by_id(session, donor_id_from_state)
    registration = await event_requests.find_specific_registration(session, donor_id_from_state, event_id_from_state)

    if not donor or not registration:
        await callback.message.edit_text(Text.DONATION_CONFIRM_ERROR_NO_REG)
        return

    try:
        points_awarded, waiver_end_date = await event_requests.confirm_donation_transaction(session, donor, registration)
        
        success_text = Text.DONATION_CONFIRM_SUCCESS.format(
            donor_name=donor.full_name,
            event_name=registration.event.name,
            points=points_awarded
        )
        await callback.message.edit_text(
            success_text,
            reply_markup=inline.get_volunteer_panel_keyboard(),
            parse_mode="HTML"  # ИСПРАВЛЕНО
        )
    except Exception as e:
        logger.error(f"Critical error during donation confirmation for user {donor.id}: {e}", exc_info=True)
        await callback.message.edit_text(Text.DONATION_CONFIRM_CRITICAL_ERROR.format(error=e))

    await callback.answer()

@router.message(VolunteerActions.awaiting_qr_photo)
async def process_qr_invalid_input(message: types.Message):
    await message.answer(Text.VOLUNTEER_INVALID_INPUT_QR)

--- КОНЕЦ ФАЙЛА: bot/handlers/volunteer.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/handlers/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/analytics.py ---

import datetime
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import analytics_requests 
from bot.filters.role import RoleFilter
from bot.keyboards import inline
from bot.utils import analytics_service 
from bot.states.states import AdminAnalytics

router = Router(name="admin_analytics")

@router.callback_query(F.data == "admin_analytics", RoleFilter('admin'))
async def show_analytics_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        "📊 <b>Аналитический дашборд</b>\n\nВыберите интересующий раздел:",
        reply_markup=inline.get_analytics_main_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data == "analytics_kpi", RoleFilter('admin'))
async def show_main_kpi(callback: types.CallbackQuery, session: AsyncSession):
    await callback.answer("⏳ Собираю данные...")
    kpi_data = await analytics_requests.get_main_kpi(session)

    text_parts = ["📈 <b>Ключевые показатели (KPI)</b>\n"]
    text_parts.append(f"<b>Новые пользователи (30д):</b> {kpi_data['new_users_30d']}")
    text_parts.append(f"<b>Активные доноры (90д):</b> {kpi_data['active_donors_90d']}")
    text_parts.append(f"<b>Сейчас на медотводе:</b> {kpi_data['on_waiver_now']}")

    if kpi_data['next_event']:
        event = kpi_data['next_event']
        days_left = (event['date'] - datetime.datetime.now()).days
        text_parts.append(f"\n🔜 <b>Ближайшее мероприятие:</b> «{event['name']}»")
        text_parts.append(f"   - <b>Записано:</b> {event['registered']}/{event['limit']}")
        text_parts.append(f"   - <b>Осталось дней:</b> {days_left}")
    else:
        text_parts.append("\n❌ Нет запланированных мероприятий.")
        
    # Запрашиваем данные для графика
    plot_data = await analytics_requests.get_donations_by_month(session)
    plot_image = analytics_service.plot_donations_by_month(plot_data)

    # Отправляем текстовую часть
    await callback.message.edit_text(
        "\n".join(text_parts), 
        reply_markup=inline.get_analytics_main_menu_keyboard(),
        parse_mode="HTML"
    )
    # Если график создался, отправляем его отдельным сообщением
    if plot_image:
        await callback.message.answer_photo(
            photo=types.BufferedInputFile(plot_image.read(), filename="donations_plot.png")
        )

@router.callback_query(F.data == "analytics_events_select", RoleFilter('admin'))
async def select_event_for_analysis(callback: types.CallbackQuery, session: AsyncSession, state: FSMContext):
    past_events = await analytics_requests.get_past_events_for_analysis(session)
    if not past_events:
        await callback.answer("Еще не было ни одного прошедшего мероприятия.", show_alert=True)
        return

    await callback.message.edit_text(
        "📅 <b>Анализ мероприятий</b>\n\nВыберите мероприятие из списка:",
        reply_markup=inline.get_events_for_analysis_keyboard(past_events)
    )
    await state.set_state(AdminAnalytics.choosing_event_for_analysis)
    await callback.answer()

@router.callback_query(AdminAnalytics.choosing_event_for_analysis, F.data.startswith("analyze_event_"))
async def show_event_analysis(callback: types.CallbackQuery, session: AsyncSession, state: FSMContext):
    await state.clear()
    event_id = int(callback.data.split("_")[-1])
    
    await callback.answer("⏳ Собираю аналитику по мероприятию...")
    data = await analytics_requests.get_event_analysis_data(session, event_id)

    if not data:
        await callback.message.edit_text("Не удалось найти данные по этому мероприятию.")
        return

    text = [
        f"📊 <b>Аналитика по мероприятию «{data['event_name']}»</b>\n",
        "<b>Воронка привлечения:</b>",
        f"  - Записалось: {data['registered_count']}",
        f"  - Пришло: {data['attended_count']}",
        f"  - Конверсия в явку: {data['conversion_rate']:.1f}%\n",
        "<b>Портрет аудитории:</b>",
        f"  - Новички: {data['newcomers_count']}",
        f"  - 'Ветераны': {data['veterans_count']}\n",
        "<b>Распределение по факультетам (пришедшие):</b>"
    ]
    
    # Сортируем факультеты по количеству участников
    sorted_faculties = sorted(data['faculties_distribution'].items(), key=lambda item: item[1], reverse=True)
    for faculty, count in sorted_faculties:
        text.append(f"  - {faculty}: {count} чел.")

    await callback.message.edit_text(
        "\n".join(text),
        parse_mode="HTML",
        reply_markup=inline.get_analytics_main_menu_keyboard()
    )

@router.callback_query(F.data == "analytics_reports", RoleFilter('admin'))
async def show_reports_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        "📄 <b>Отчеты</b>\n\nВыберите категорию отчета:",
        reply_markup=inline.get_reports_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("report_"), RoleFilter('admin'))
async def generate_report(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    report_type = callback.data.split("_", 1)[1]
    report_titles = {
        "churn_donors": "Доноры-однодневки",
        "lapsed_donors": "Угасающие доноры",
        "top_donors": "Доноры-чемпионы",
        "rare_blood_donors": "Доноры редкой крови",
        "top_faculties": "Самые активные факультеты",
        "dkm_candidates": "Кандидаты в регистр ДКМ",
        "survey_dropoff": "Потерянные после опросника"
    }
    report_title = report_titles.get(report_type, "Отчет")

    await callback.answer("⏳ Генерирую отчет...")

    report_data = await analytics_service.create_report(session, report_type)

    if not report_data:
        await callback.message.answer("Нет данных для этого отчета.")
        return

    # Формирование отчета в виде таблицы
    headers = list(report_data[0].keys())
    # Заголовки для красоты
    header_map = {
        "full_name": "ФИО", "username": "Username", "donation_date": "Дата донации",
        "donation_count": "Донаций", "last_donation_date": "Последняя донация", "rank": "Ранг",
        "blood_group": "Группа крови", "faculty_name": "Факультет", "survey_date": "Дата опросника"
    }
    pretty_headers = [header_map.get(h, h) for h in headers]

    # Определяем ширину колонок
    col_widths = {h: len(pretty_headers[i]) for i, h in enumerate(headers)}
    for row in report_data:
        for key, value in row.items():
            col_widths[key] = max(col_widths[key], len(str(value)))

    # Собираем текстовый файл
    report_lines = []
    report_lines.append(f"Отчет: {report_title}")
    report_lines.append("=" * (sum(col_widths.values()) + len(col_widths) * 3 -1))

    header_line = "  ".join(h.ljust(col_widths[headers[i]]) for i, h in enumerate(pretty_headers))
    report_lines.append(header_line)
    report_lines.append("-" * len(header_line))

    for row in report_data:
        row_list = []
        for header in headers:
            value = row.get(header, "")
            if isinstance(value, datetime.datetime) or isinstance(value, datetime.date):
                value = value.strftime('%Y-%m-%d')
            row_list.append(str(value).ljust(col_widths[header]))
        report_lines.append("  ".join(row_list))

    report_text = "\n".join(report_lines)

    await bot.send_document(
        chat_id=callback.from_user.id,
        document=types.BufferedInputFile(
            report_text.encode("utf-8"),
            filename=f"report_{report_type}.txt"
        ),
        caption=f"Отчет: {report_title}"
    )

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/analytics.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/event_management.py ---

import logging
import datetime
import asyncio
import io
import csv
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.markdown import hbold
from aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from bot.db import admin_requests, event_requests, user_requests
from bot.db.engine import async_session_maker
from bot.filters.role import RoleFilter
from bot.states.states import EventCreation, EventEditing, PostEventProcessing
from bot.keyboards import inline
from bot.db.models import Event, User
from bot.utils.text_messages import Text
from bot.db import analytics_requests


router = Router(name="admin_event_management")
logger = logging.getLogger(__name__)


# =============================================================================
# --- 🗓️ УПРАВЛЕНИЕ МЕРОПРИЯТИЯМИ ---
# =============================================================================

@router.callback_query(F.data == "admin_create_event", RoleFilter('admin'))
async def start_event_creation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(EventCreation.awaiting_name)
    await callback.message.edit_text(Text.EVENT_CREATE_STEP_1_NAME)
    await callback.answer()

@router.message(EventCreation.awaiting_name)
async def process_event_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(EventCreation.awaiting_datetime)
    await message.answer(Text.EVENT_CREATE_STEP_2_DATE, parse_mode="HTML")

@router.message(EventCreation.awaiting_datetime)
async def process_event_datetime(message: types.Message, state: FSMContext):
    try:
        event_dt = datetime.datetime.strptime(message.text, "%d.%m.%Y %H:%M")
        await state.update_data(event_datetime=event_dt.isoformat())
        await state.set_state(EventCreation.awaiting_location_text)
        await message.answer(Text.EVENT_CREATE_STEP_3_LOCATION_TEXT)
    except ValueError:
        await message.answer(Text.DATE_FORMAT_ERROR, parse_mode="HTML")

@router.message(EventCreation.awaiting_location_text)
async def process_event_location_text(message: types.Message, state: FSMContext):
    await state.update_data(location=message.text)
    await state.set_state(EventCreation.awaiting_location_point)
    await message.answer(Text.EVENT_CREATE_STEP_4_LOCATION_POINT)

@router.message(EventCreation.awaiting_location_point, F.location)
async def process_event_location_point(message: types.Message, state: FSMContext, session: AsyncSession):
    await state.update_data(
        latitude=message.location.latitude,
        longitude=message.location.longitude
    )
    await state.set_state(EventCreation.awaiting_blood_center)

    blood_centers = await admin_requests.get_all_blood_centers(session)
    await message.answer(
        "Выберите центр крови или добавьте новый:",
        reply_markup=inline.get_blood_centers_keyboard(blood_centers)
    )


@router.callback_query(EventCreation.awaiting_blood_center, F.data.startswith("select_blood_center_"))
async def process_blood_center_selection(callback: types.CallbackQuery, state: FSMContext):
    blood_center_id = int(callback.data.split("_")[-1])
    await state.update_data(blood_center_id=blood_center_id)
    await state.set_state(EventCreation.awaiting_donation_type)
    await callback.message.edit_text(
        Text.EVENT_CREATE_STEP_5_TYPE,
        reply_markup=inline.get_donation_type_keyboard()
    )


@router.callback_query(EventCreation.awaiting_blood_center, F.data == "add_new_blood_center")
async def add_new_blood_center(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(EventCreation.awaiting_new_blood_center_name)
    await callback.message.edit_text("Введите название нового центра крови:")


@router.message(EventCreation.awaiting_new_blood_center_name)
async def process_new_blood_center_name(message: types.Message, state: FSMContext, session: AsyncSession):
    new_blood_center = await admin_requests.create_blood_center(session, message.text)
    await state.update_data(blood_center_id=new_blood_center.id)
    await state.set_state(EventCreation.awaiting_donation_type)
    await message.answer(
        Text.EVENT_CREATE_STEP_5_TYPE,
        reply_markup=inline.get_donation_type_keyboard()
    )

@router.callback_query(EventCreation.awaiting_donation_type, F.data.startswith("settype_"))
async def process_event_donation_type(callback: types.CallbackQuery, state: FSMContext):
    donation_type = callback.data.split('_', 1)[1]
    await state.update_data(donation_type=donation_type)
    await state.set_state(EventCreation.awaiting_points)
    await callback.message.edit_text(Text.EVENT_CREATE_STEP_6_POINTS.format(donation_type=donation_type))
    await callback.answer()

@router.message(EventCreation.awaiting_points)
async def process_event_points(message: types.Message, state: FSMContext):
    try:
        points = int(message.text)
        await state.update_data(points_per_donation=points)
        await state.set_state(EventCreation.awaiting_limit)
        await message.answer(Text.EVENT_CREATE_STEP_7_LIMIT)
    except ValueError:
        await message.answer(Text.EVENT_POINTS_NAN_ERROR)


@router.message(EventCreation.awaiting_limit)
async def process_event_limit(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        limit = int(message.text)
        await state.update_data(participant_limit=limit)
        await state.set_state(EventCreation.awaiting_confirmation)
        
        event_data = await state.get_data()

        blood_center = await admin_requests.get_blood_center_by_id(session, event_data['blood_center_id'])

        text = Text.EVENT_CREATE_CONFIRMATION.format(
            name=event_data['name'],
            datetime=datetime.datetime.fromisoformat(event_data['event_datetime']).strftime('%d.%m.%Y в %H:%M'),
            location=event_data['location'],
            blood_center_name=blood_center.name,
            location_set="Указана" if event_data.get('latitude') else "Не указана",
            type=event_data['donation_type'],
            points=event_data['points_per_donation'],
            limit=event_data['participant_limit']
        )
        
        await message.answer(text, reply_markup=inline.get_event_creation_confirmation_keyboard())
    except ValueError:
        await message.answer(Text.EVENT_LIMIT_NAN_ERROR)

@router.callback_query(EventCreation.awaiting_confirmation, F.data == "confirm_create_event")
async def confirm_event_creation_and_notify(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    await callback.message.edit_text(Text.EVENT_CREATING_IN_PROGRESS)
    
    event_data = await state.get_data()
    await state.clear()
    
    event_data['event_datetime'] = datetime.datetime.fromisoformat(event_data['event_datetime'])
    new_event = await admin_requests.create_event(session, event_data)
    await session.commit()
    
    await callback.message.answer(Text.EVENT_CREATE_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())
    
    msg = await callback.message.answer(Text.MAILING_STARTED_NOTIFICATION)
    
    asyncio.create_task(send_new_event_notifications(new_event, bot, msg))
    
    await callback.answer()

async def _send_notification_safe(bot: Bot, user: User, text: str, **kwargs):
    """Безопасно отправляет сообщение одному пользователю, ловит ошибки."""
    try:
        await bot.send_message(chat_id=user.telegram_id, text=text, **kwargs)
        return True
    except TelegramForbiddenError:
        logger.warning(f"Failed to send notification to user {user.id}. Bot was blocked.")
    except TelegramBadRequest as e:
        if "chat not found" in str(e):
            logger.warning(f"Failed to send notification to user {user.id}. Chat not found.")
        else:
            logger.error(f"Failed to send new event notification to user {user.id}. Error: {e}")
    except Exception as e:
        logger.error(f"Failed to send new event notification to user {user.id}. Unexpected error: {e}")
    return False

async def send_new_event_notifications(event: Event, bot: Bot, status_message: types.Message):
    """
    Выполняет рассылку о новом мероприятии пользователям, используя asyncio.gather для параллелизма.
    """
    async with async_session_maker() as session:
        try:
            users_to_notify = await user_requests.get_users_for_event_notification(session, event)
            total_users = len(users_to_notify)
            logger.info(f"Starting mailing for event '{event.name}'. Found {total_users} users.")

            if total_users == 0:
                await status_message.edit_text("✅ Рассылка завершена. Подходящих пользователей для уведомления не найдено.")
                return

            tasks = []
            for user in users_to_notify:
                location_link = Text.format_location_link(event.location, event.latitude, event.longitude)
                safe_event_name = Text.escape_html(event.name)
                
                text = Text.NEW_EVENT_NOTIFICATION.format(
                    event_name=safe_event_name,
                    event_date=event.event_datetime.strftime('%d.%m.%Y'),
                    event_time=event.event_datetime.strftime('%H:%M'),
                    event_location=location_link 
                )
                tasks.append(
                    _send_notification_safe(
                        bot,
                        user, # Передаем весь объект user
                        text,
                        parse_mode="HTML",
                        disable_web_page_preview=True
                    )
                )
            
            # Запускаем все задачи параллельно
            results = await asyncio.gather(*tasks)
            
            success_count = sum(1 for r in results if r)
            fail_count = total_users - success_count
            
            await status_message.edit_text(Text.MAILING_FINISHED_NOTIFICATION.format(success=success_count, fail=fail_count))
        except Exception as e:
            logger.error(f"Critical error during new event mailing for event {event.id}: {e}", exc_info=True)
            await status_message.edit_text(Text.MAILING_ERROR)


@router.callback_query(F.data == "admin_view_events", RoleFilter('admin'))
async def view_active_events(callback: types.CallbackQuery, session: AsyncSession):
    events = await event_requests.get_active_events(session)
    if not events:
        await callback.message.edit_text(Text.ADMIN_NO_ACTIVE_EVENTS, reply_markup=inline.get_events_management_keyboard())
        await callback.answer()
        return

    builder = InlineKeyboardBuilder()
    for event in events:
        prefix = "✅" if event.registration_is_open else "🔒"
        builder.row(types.InlineKeyboardButton(
            text=f"{prefix} {event.event_datetime.strftime('%d.%m')} - {event.name}", 
            callback_data=f"admin_show_event_{event.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_events"))
    
    await callback.message.edit_text(Text.ADMIN_CHOOSE_EVENT_TO_MANAGE, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("admin_show_event_"), RoleFilter('admin'))
async def show_single_event_card(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event:
        await callback.answer(Text.EVENT_NOT_FOUND, show_alert=True)
        return
    
    reg_count = await admin_requests.get_event_registrations_count(session, event_id)
    donation_type_ru = Text.DONATION_TYPE_RU.get(event.donation_type, event.donation_type)
    
    feedback_count = await session.scalar(select(func.count(admin_requests.Feedback.id)).where(admin_requests.Feedback.event_id == event_id))
        
    text = Text.EVENT_CARD_TEMPLATE.format(
        name=hbold(event.name),
        date_header=hbold('Дата:'),
        datetime=event.event_datetime.strftime('%d.%m.%Y в %H:%M'),
        location_header=hbold('Место:'),
        location=Text.escape_html(event.location),
        blood_center_name=event.blood_center.name if event.blood_center else "Не указан",
        type_header=hbold('Тип донации:'),
        donation_type=donation_type_ru,
        points_header=hbold('Баллы:'),
        points_per_donation=event.points_per_donation,
        limit_header=hbold('Записано/Лимит:'),
        reg_count=reg_count,
        participant_limit=event.participant_limit,
        status_header=hbold('Статус:'),
        is_active='Активно' if event.is_active else 'Архивировано',
        reg_status_header=hbold('Регистрация:'),
        reg_is_open='Открыта' if event.registration_is_open else 'Закрыта'
    )

    await callback.message.edit_text(
        text, 
        reply_markup=inline.get_single_event_management_keyboard(event.id, event.registration_is_open, has_feedback=(feedback_count > 0)), 
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_toggle_reg_"), RoleFilter('admin'))
async def toggle_event_registration(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    new_status = await admin_requests.toggle_event_registration_status(session, event_id)
    await session.commit()
    alert_text = Text.EVENT_TOGGLE_REG_OPEN if new_status else Text.EVENT_TOGGLE_REG_CLOSED
    await callback.answer(alert_text, show_alert=True)
    await show_single_event_card(callback, session)

@router.callback_query(F.data.startswith("admin_edit_event_"), RoleFilter('admin'))
async def start_event_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event: return
    
    await state.update_data(event_id=event_id)
    await state.set_state(EventEditing.choosing_field)
    
    fields = {"name": "Название", "event_date": "Дата", "location": "Место", "blood_center_id": "Центр крови", "points_per_donation": "Баллы", "participant_limit": "Лимит"}
    builder = InlineKeyboardBuilder()
    for key, name in fields.items():
        builder.row(types.InlineKeyboardButton(text=f"Изменить: {name}", callback_data=f"edit_field_{key}"))
    builder.row(types.InlineKeyboardButton(text="✅ Завершить", callback_data=f"admin_show_event_{event_id}"))
    
    await callback.message.edit_text(Text.EVENT_EDIT_PROMPT.format(event_name=event.name), reply_markup=builder.as_markup(), parse_mode="HTML")
    await callback.answer()

@router.callback_query(EventEditing.choosing_field, F.data.startswith("edit_field_"))
async def choose_field_to_edit(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    field_to_edit = callback.data.split('_', 2)[-1]
    await state.update_data(field_to_edit=field_to_edit)

    if field_to_edit == "blood_center_id":
        await state.set_state(EventEditing.awaiting_new_value)
        blood_centers = await admin_requests.get_all_blood_centers(session)
        await callback.message.edit_text(
            "Выберите новый центр крови:",
            reply_markup=inline.get_blood_centers_keyboard(blood_centers, edit_mode=True)
        )
    else:
        await state.set_state(EventEditing.awaiting_new_value)
        prompt = Text.EVENT_EDIT_FIELD_PROMPTS.get(field_to_edit, "Введите новое значение:")
        await callback.message.edit_text(prompt)

    await callback.answer()

@router.message(EventEditing.awaiting_new_value, F.text)
async def process_new_value_for_event(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    field, event_id, new_value_str = data.get("field_to_edit"), data.get("event_id"), message.text
    
    try:
        if field == "event_date": update_value = datetime.datetime.strptime(new_value_str, "%d.%m.%Y %H:%M")
        elif field in ["points_per_donation", "participant_limit"]: update_value = int(new_value_str)
        else: update_value = new_value_str
    except ValueError:
        await message.answer(Text.EVENT_EDIT_INVALID_FORMAT)
        return
        
    await admin_requests.update_event_field(session, event_id, field, update_value)
    await session.commit()
    await state.clear()
    await message.answer(Text.EVENT_EDIT_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())

@router.callback_query(EventEditing.awaiting_new_value, F.data.startswith("select_blood_center_"))
async def process_new_blood_center_for_event(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    event_id = data.get("event_id")
    new_blood_center_id = int(callback.data.split("_")[-1])

    await admin_requests.update_event_field(session, event_id, "blood_center_id", new_blood_center_id)
    await session.commit()
    await state.clear()
    await callback.message.edit_text(Text.EVENT_EDIT_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())


@router.callback_query(EventEditing.awaiting_new_value, F.data == "add_new_blood_center_edit")
async def add_new_blood_center_for_edit(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(EventEditing.awaiting_new_blood_center_name_for_edit)
    await callback.message.edit_text("Введите название нового центра крови:")


@router.message(EventEditing.awaiting_new_blood_center_name_for_edit)
async def process_new_blood_center_name_for_edit(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    event_id = data.get("event_id")
    new_blood_center = await admin_requests.create_blood_center(session, message.text)

    await admin_requests.update_event_field(session, event_id, "blood_center_id", new_blood_center.id)
    await session.commit()
    await state.clear()
    await message.answer(Text.EVENT_EDIT_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())

@router.callback_query(F.data.startswith("admin_event_participants_"), RoleFilter('admin'))
async def get_event_participants(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event, participants_regs = await admin_requests.get_event_with_participants(session, event_id)
    if not event: return await callback.answer(Text.EVENT_NOT_FOUND, show_alert=True)
    if not participants_regs: return await callback.answer(Text.EVENT_NO_PARTICIPANTS.format(event_name=event.name), show_alert=True)

    output = io.StringIO()
    writer = csv.writer(output, delimiter=';')
    writer.writerow(['ID', 'ФИО', 'Телефон', 'Факультет', 'Группа', 'Статус'])
    for reg in participants_regs:
        writer.writerow([reg.user.id, reg.user.full_name, reg.user.phone_number, reg.user.faculty, reg.user.study_group, reg.status])
    
    output.seek(0)
    file = types.BufferedInputFile(output.getvalue().encode('utf-8-sig'), filename=f"participants_{event.id}.csv")
    await callback.message.answer_document(file, caption=Text.EVENT_PARTICIPANTS_CAPTION.format(event_name=event.name))
    await callback.answer()

@router.callback_query(F.data.startswith("admin_cancel_event_"), RoleFilter('admin'))
async def ask_for_cancellation_confirmation(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event: return await callback.answer(Text.EVENT_NOT_FOUND, show_alert=True)
    reg_count = await admin_requests.get_event_registrations_count(session, event_id)
    await callback.message.edit_text(
        Text.EVENT_CANCEL_CONFIRMATION.format(event_name=event.name, reg_count=reg_count),
        reply_markup=inline.get_event_cancellation_confirmation_keyboard(event_id),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_cancel_"), RoleFilter('admin'))
async def confirm_and_cancel_event(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    await callback.message.edit_text(Text.EVENT_CANCELLING_IN_PROGRESS)
    event_id = int(callback.data.split('_')[-1])
    event, participants_regs = await admin_requests.get_event_with_participants(session, event_id)
    if not event: return

    success_count, fail_count = 0, 0
    for reg in participants_regs:
        try:
            safe_event_name = Text.escape_html(event.name)
            safe_datetime = Text.escape_html(event.event_datetime.strftime('%d.%m.%Y в %H:%M'))
            text = Text.EVENT_CANCEL_NOTIFICATION_TEXT.format(
                event_name=safe_event_name,
                datetime=safe_datetime
            )
            await bot.send_message(chat_id=reg.user.telegram_id, text=text, parse_mode="HTML")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.error(f"Failed to send cancellation to user {reg.user_id} for event {event.id}. Error: {e}")
        await asyncio.sleep(0.1)

    await admin_requests.deactivate_event(session, event_id)
    await session.commit()
    await callback.message.edit_text(
        Text.EVENT_CANCEL_SUCCESS_REPORT.format(event_name=event.name, success=success_count, fail=fail_count),
        reply_markup=inline.get_back_to_events_menu_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_view_feedback_"), RoleFilter('admin'))
async def view_event_feedback(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    feedbacks = await admin_requests.get_feedback_for_event(session, event_id)

    if not feedbacks:
        await callback.answer(Text.FEEDBACK_ADMIN_NO_FEEDBACK, show_alert=True)
        return

    report = Text.FEEDBACK_ADMIN_HEADER.format(event_name=Text.escape_html(event.name))
    for fb in feedbacks:
        report += Text.FEEDBACK_ADMIN_ITEM.format(
            user_name=Text.escape_html(fb.user.full_name),
            wb_score=fb.well_being_score or "-",
            wb_comment=Text.escape_html(fb.well_being_comment or "-"),
            org_score=fb.organization_score or "-",
            liked=Text.escape_html(fb.what_liked or "-"),
            disliked=Text.escape_html(fb.what_disliked or "-"),
            suggestions=Text.escape_html(fb.other_suggestions or "-")
        )
    
    try:
        await callback.message.delete()
    except Exception:
        logger.warning("Could not delete message in view_event_feedback")

    if len(report) > 4000: # Telegram message limit
        await callback.message.answer("Отзывов слишком много, отправляю файлом.")
        file = types.BufferedInputFile(report.encode('utf-8'), filename=f"feedback_{event_id}.txt")
        await callback.message.answer_document(file)
    else:
        try:
            await callback.message.answer(
                report,
                reply_markup=inline.get_back_to_events_menu_keyboard(),
                parse_mode="HTML"
            )
        except TelegramBadRequest:
            await callback.message.delete()
            await callback.message.answer(
                report,
                reply_markup=inline.get_back_to_events_menu_keyboard(),
                parse_mode="HTML"
            )
    
    await callback.answer()
    
    
    
@router.callback_query(F.data == "admin_post_process_dd", RoleFilter('admin'))
async def start_post_processing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Начало FSM: Выбор прошедшего мероприятия."""
    await state.clear()
    past_events = await analytics_requests.get_past_events_for_analysis(session)
    if not past_events:
        await callback.answer("Нет прошедших мероприятий для обработки.", show_alert=True)
        return

    await state.set_state(PostEventProcessing.choosing_event)
    await callback.message.edit_text(
        "Выберите мероприятие, для которого хотите внести данные:",
        reply_markup=inline.get_events_for_post_processing_keyboard(past_events)
    )
    await callback.answer()

async def show_participant_marking_menu(message: types.Message, state: FSMContext, session: AsyncSession):
    """Вспомогательная функция для отображения и обновления меню отметки."""
    data = await state.get_data()
    event_id = data.get("event_id")
    marked_donations = data.get("marked_donations", set())
    marked_dkm = data.get("marked_dkm", set())

    _, participants = await admin_requests.get_event_with_participants(session, event_id)
    if not participants:
        await message.edit_text("На это мероприятие не было зарегистрировано участников.", reply_markup=inline.get_back_to_events_menu_keyboard())
        await state.clear()
        return

    await message.edit_text(
        "Отметьте, кто сдал кровь и/или вступил в регистр ДКМ.\n(🟢 - отмечено, ⚪️ - нет)",
        reply_markup=inline.get_participant_marking_keyboard(event_id, participants, marked_donations, marked_dkm)
    )

@router.callback_query(PostEventProcessing.choosing_event, F.data.startswith("post_process_event_"))
async def choose_event_for_processing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Шаг 2: Мероприятие выбрано, показываем список участников."""
    event_id = int(callback.data.split("_")[-1])
    await state.update_data(event_id=event_id, marked_donations=set(), marked_dkm=set())
    await state.set_state(PostEventProcessing.marking_participants)
    await show_participant_marking_menu(callback.message, state, session)
    await callback.answer()
    
@router.callback_query(PostEventProcessing.marking_participants, F.data.startswith("mark_participant_"))
async def mark_participant(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Обработка нажатия на кнопку отметки (toggle)."""
    _, _, event_id_str, user_id_str, action = callback.data.split("_")
    user_id = int(user_id_str)

    data = await state.get_data()
    target_set_name = "marked_donations" if action == "donation" else "marked_dkm"
    target_set = data.get(target_set_name, set())

    if user_id in target_set:
        target_set.remove(user_id)
    else:
        target_set.add(user_id)
    
    await state.update_data(**{target_set_name: target_set})
    
    # Обновляем клавиатуру, чтобы показать изменение
    await show_participant_marking_menu(callback.message, state, session)
    await callback.answer()

@router.callback_query(PostEventProcessing.marking_participants, F.data.startswith("finish_marking_"))
async def finish_marking(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Завершение процесса: сохраняем все отметки в БД."""
    data = await state.get_data()
    event_id = data.get("event_id")
    marked_donations = data.get("marked_donations", set())
    marked_dkm = data.get("marked_dkm", set())
    await state.clear()

    if not marked_donations:
        await callback.answer("Ни один участник не отмечен как сдавший кровь.", show_alert=True)
        return
        
    await callback.message.edit_text("⏳ Сохраняю данные... Это может занять некоторое время.")

    report_lines = []
    for user_id in marked_donations:
        is_dkm = user_id in marked_dkm
        success, message = await admin_requests.manually_confirm_donation(session, user_id, event_id, is_dkm)
        report_lines.append(message)
    
    await session.commit()
    
    final_report = "✅ <b>Обработка завершена.</b>\n\n<b>Результаты:</b>\n" + "\n".join(report_lines)
    await callback.message.edit_text(final_report, reply_markup=inline.get_back_to_events_menu_keyboard())
    await callback.answer("Данные сохранены!", show_alert=True)

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/event_management.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/info_management.py ---

import logging
from aiogram import Router, F, types
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import info_requests
from bot.filters.role import RoleFilter
from bot.states.states import EditInfoSection
from bot.keyboards import inline

router = Router(name="admin_info_management")
logger = logging.getLogger(__name__)

@router.callback_query(F.data == "admin_edit_info", RoleFilter('admin'))
async def start_info_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    sections = await info_requests.get_all_info_sections(session)
    if not sections:
        await callback.answer("Информационные разделы не найдены в базе данных.", show_alert=True)
        return
        
    await state.set_state(EditInfoSection.choosing_section)
    await callback.message.edit_text(
        "Выберите раздел, который хотите отредактировать:",
        reply_markup=inline.get_info_sections_for_editing_keyboard(sections)
    )
    await callback.answer()

@router.callback_query(EditInfoSection.choosing_section, F.data.startswith("edit_info_"))
async def choose_section_to_edit(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    section_key = callback.data.split("_", 2)[-1]
    current_text = await info_requests.get_info_text(session, section_key)
    
    await state.update_data(section_key=section_key)
    await state.set_state(EditInfoSection.awaiting_new_text)
    
    await callback.message.edit_text(
        f"<b>Текущий текст раздела (для справки):</b>\n\n{current_text}\n\n"
        f"<b>Отправьте новый текст. Можно использовать HTML-теги.</b>",
        parse_mode="HTML"
    )
    await callback.answer()

@router.message(EditInfoSection.awaiting_new_text)
async def process_new_info_text(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    section_key = data.get("section_key")
    
    if not section_key:
        await message.answer("Произошла ошибка, попробуйте снова.")
        await state.clear()
        return

    await info_requests.update_info_text(session, section_key, message.html_text)
    await state.clear()
    
    await message.answer(
        "✅ Текст раздела успешно обновлен!",
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/info_management.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/mailing.py ---

import logging
import asyncio
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError

from bot.db.engine import async_session_maker
from bot.db import user_requests, admin_requests
from bot.filters.role import RoleFilter
from bot.states.states import Mailing
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router(name="admin_mailing")
logger = logging.getLogger(__name__)


async def show_audience_choice_menu(message: types.Message, state: FSMContext):
    """Отображает меню выбора аудитории с текущими фильтрами."""
    data = await state.get_data()
    current_filters = data.get("filters", {})
    
    text_parts = [Text.MAILING_STEP_3_AUDIENCE_PROMPT]
    if current_filters:
        text_parts.append("\n<b>Выбранные фильтры:</b>")
        for key, value in current_filters.items():
            text_parts.append(f"  - {key.replace('_', ' ').capitalize()}: <code>{value}</code>")
    
    prompt_text = "\n".join(text_parts)

    await message.answer(
        text=prompt_text,
        reply_markup=inline.get_mailing_audience_keyboard(current_filters),
        parse_mode="HTML"
    )

# =============================================================================
# --- 📣 РАССЫЛКИ (FSM) ---
# =============================================================================

@router.callback_query(F.data == "admin_mailing", RoleFilter('admin'))
async def start_mailing(callback: types.CallbackQuery, state: FSMContext):
    """Шаг 1: Запрашивает текст для рассылки."""
    await state.clear()
    await state.set_state(Mailing.awaiting_message_text)
    await callback.message.edit_text(Text.MAILING_STEP_1_TEXT_PROMPT, parse_mode="HTML")
    await callback.answer()


@router.message(Mailing.awaiting_message_text)
async def get_mailing_text(message: types.Message, state: FSMContext):
    """Шаг 2: Получает текст и запрашивает медиа."""
    await state.update_data(
        message_text=message.html_text,
        photo_id=None,
        video_id=None,
        filters={}
    )
    await state.set_state(Mailing.awaiting_media)
    await message.answer(Text.MAILING_STEP_2_MEDIA_PROMPT, reply_markup=inline.get_skip_media_keyboard(), parse_mode="HTML")


@router.message(Mailing.awaiting_media, F.photo)
async def get_mailing_photo(message: types.Message, state: FSMContext):
    await state.update_data(photo_id=message.photo[-1].file_id)
    await state.set_state(Mailing.awaiting_audience_choice)
    await show_audience_choice_menu(message, state)


@router.message(Mailing.awaiting_media, F.video)
async def get_mailing_video(message: types.Message, state: FSMContext):
    await state.update_data(video_id=message.video.file_id)
    await state.set_state(Mailing.awaiting_audience_choice)
    await show_audience_choice_menu(message, state)


@router.callback_query(Mailing.awaiting_media, F.data == "skip_media")
async def skip_media_step(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(Mailing.awaiting_audience_choice)
    await callback.message.delete()
    await show_audience_choice_menu(callback.message, state)
    await callback.answer()


@router.callback_query(Mailing.awaiting_audience_choice, F.data.startswith("mail_audience_type_"))
async def choose_audience_filter_type(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Шаг 3.1: Админ выбрал тип фильтра (ВУЗ, факультет, группа крови)."""
    filter_type = callback.data.split('_')[-1]
    
    items = []
    prompt_text = "Неизвестный тип фильтра"
    
    if filter_type == "university":
        items = await admin_requests.get_distinct_universities(session)
        prompt_text = "Выберите ВУЗ для фильтрации:"
    elif filter_type == "faculty":
        items = await admin_requests.get_distinct_faculties(session)
        prompt_text = "Выберите факультет для фильтрации:"

    if not items:
        await callback.answer("Нет доступных значений для этого фильтра.", show_alert=True)
        return

    keyboard = inline.get_dynamic_mailing_filter_keyboard(items, filter_type, "mail_audience_back")
    await callback.message.edit_text(prompt_text, reply_markup=keyboard)
    await callback.answer()


@router.callback_query(Mailing.awaiting_audience_choice, F.data.startswith("mail_filter_"))
async def set_audience_filter(callback: types.CallbackQuery, state: FSMContext):
    """Шаг 3.2: Админ выбрал конкретное значение. Добавляем фильтр и возвращаемся в меню."""
    parts = callback.data.split('_')
    filter_key = parts[2]
    filter_value = '_'.join(parts[3:])

    data = await state.get_data()
    current_filters = data.get("filters", {})
    current_filters[filter_key] = filter_value
    await state.update_data(filters=current_filters)
    
    await callback.message.delete()
    await show_audience_choice_menu(callback.message, state)
    await callback.answer(f"Фильтр '{filter_value}' добавлен!")


@router.callback_query(Mailing.awaiting_audience_choice, F.data == "mail_audience_back")
async def back_to_audience_choice_menu(callback: types.CallbackQuery, state: FSMContext):
    """Возврат к основному меню выбора аудитории из меню выбора значения."""
    await callback.message.delete()
    await show_audience_choice_menu(callback.message, state)
    await callback.answer()


@router.callback_query(Mailing.awaiting_audience_choice, F.data == "mail_audience_reset")
async def reset_audience_filters(callback: types.CallbackQuery, state: FSMContext):
    """Сбрасывает все выбранные фильтры."""
    await state.update_data(filters={})
    await callback.message.delete()
    await show_audience_choice_menu(callback.message, state)
    await callback.answer("Все фильтры сброшены.", show_alert=True)


@router.callback_query(Mailing.awaiting_audience_choice, F.data == "mail_audience_finish")
async def finish_audience_selection(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Шаг 4: Админ нажал 'Готово'. Переход к подтверждению."""
    data = await state.get_data()
    filters = data.get("filters", {})
    
    if not filters:
        await callback.answer("Вы не выбрали ни одного фильтра!", show_alert=True)
        return

    audience_text_parts = []
    for key, value in filters.items():
        audience_text_parts.append(f"{key.replace('_', ' ').capitalize()}: {value}")
    audience_text = " и ".join(audience_text_parts)

    users_to_notify = await user_requests.get_users_for_mailing(session, filters)
    recipient_count = len(users_to_notify)

    message_text = data.get("message_text")
    photo_id = data.get("photo_id")
    video_id = data.get("video_id")
    
    preview_text = Text.MAILING_PREVIEW_HEADER.format(audience=audience_text, count=recipient_count)
    if photo_id: preview_text += Text.MAILING_PREVIEW_WITH_PHOTO
    if video_id: preview_text += Text.MAILING_PREVIEW_WITH_VIDEO
    preview_text += Text.MAILING_PREVIEW_TEXT_HEADER.format(text=message_text)
            
    await state.set_state(Mailing.awaiting_confirmation)
    
    await callback.message.delete()
    await callback.message.answer(preview_text, reply_markup=inline.get_mailing_confirmation_keyboard(), parse_mode="HTML")
    await callback.answer()


# --- Подтверждение и запуск ---

@router.callback_query(Mailing.awaiting_confirmation, F.data == "confirm_mailing")
async def confirm_and_start_mailing(callback: types.CallbackQuery, state: FSMContext, bot: Bot):
    """Запускает рассылку в фоновом режиме."""
    data = await state.get_data()
    await state.clear()
    
    await callback.message.edit_text(
        Text.MAILING_CONFIRMED_AND_RUNNING,
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )
    
    asyncio.create_task(do_mailing(
        filters=data.get("filters", {}),
        message_text=data.get("message_text"),
        photo_id=data.get("photo_id"),
        video_id=data.get("video_id"),
        bot=bot
    ))
    await callback.answer()


async def _send_broadcast_safe(bot: Bot, user_id: int, text: str, photo_id: str | None, video_id: str | None):
    """Безопасно отправляет широковещательное сообщение."""
    try:
        if photo_id:
            await bot.send_photo(user_id, photo_id, caption=text, parse_mode="HTML")
        elif video_id:
            await bot.send_video(user_id, video_id, caption=text, parse_mode="HTML")
        else:
            await bot.send_message(user_id, text, parse_mode="HTML")
        return True
    except TelegramForbiddenError:
        logger.warning(f"Failed to send broadcast to user {user_id}. Bot was blocked or user deactivated.")
    except TelegramBadRequest as e:
         if "chat not found" in str(e):
             logger.warning(f"Failed to send broadcast to user {user_id}. Chat not found.")
         else:
             logger.error(f"Failed to send broadcast to user {user_id}. Error: {e}")
    except Exception as e:
        logger.error(f"Unexpected error sending broadcast to user {user_id}: {e}")
    return False


async def do_mailing(filters: dict, message_text: str, photo_id: str | None, video_id: str | None, bot: Bot):
    """Асинхронная задача для выполнения рассылки с использованием asyncio.gather."""
    logger.info(f"Starting mailing for filters: {filters}")
    async with async_session_maker() as session:
        try:
            users = await user_requests.get_users_for_mailing(session, filters)
            if not users:
                logger.warning("No users found for this mailing criteria.")
                return

            total_users = len(users)
            logger.info(f"Found {total_users} users for mailing.")

            tasks = [
                _send_broadcast_safe(bot, user.telegram_id, message_text, photo_id, video_id)
                for user in users
            ]

            results = await asyncio.gather(*tasks)

            success_count = sum(1 for r in results if r)
            fail_count = total_users - success_count

            logger.info(f"Mailing finished. Sent: {success_count}, Failed: {fail_count}.")

        except Exception as e:
            logger.error(f"Critical error during mailing: {e}", exc_info=True)

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/mailing.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/merch_management.py ---

import logging
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.exceptions import TelegramBadRequest
from aiogram.utils.markdown import hbold, hlink
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload

from bot.db import admin_requests, user_requests
from bot.filters.role import RoleFilter
from bot.states.states import MerchCreation, MerchEditing
from bot.keyboards import inline
from bot.db.models import MerchOrder
from bot.utils.text_messages import Text

router = Router(name="admin_merch_management")
logger = logging.getLogger(__name__)


# =============================================================================
# --- 🛍️ УПРАВЛЕНИЕ МАГАЗИНОМ ---
# =============================================================================
@router.callback_query(F.data == "admin_manage_merch", RoleFilter('admin'))
async def manage_merch_panel(callback: types.CallbackQuery):
    # ИСПРАВЛЕНО: parse_mode="HTML"
    await callback.message.edit_text(Text.ADMIN_MERCH_HEADER, reply_markup=inline.get_merch_management_keyboard(), parse_mode="HTML")
    await callback.answer()

# --- Создание товара ---
@router.callback_query(F.data == "admin_create_merch", RoleFilter('admin'))
async def start_merch_creation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(MerchCreation.awaiting_photo)
    await callback.message.edit_text(Text.MERCH_CREATE_STEP_1_PHOTO)
    await callback.answer()

@router.message(MerchCreation.awaiting_photo, F.photo)
async def process_merch_photo(message: types.Message, state: FSMContext):
    photo_file_id = message.photo[-1].file_id
    await state.update_data(photo_file_id=photo_file_id)
    await state.set_state(MerchCreation.awaiting_name)
    await message.answer(Text.MERCH_PHOTO_RECEIVED)

@router.message(MerchCreation.awaiting_name)
async def process_merch_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(MerchCreation.awaiting_description)
    await message.answer(Text.MERCH_NAME_RECEIVED)

@router.message(MerchCreation.awaiting_description)
async def process_merch_description(message: types.Message, state: FSMContext):
    await state.update_data(description=message.text)
    await state.set_state(MerchCreation.awaiting_price)
    await message.answer(Text.MERCH_DESC_RECEIVED)
    
@router.message(MerchCreation.awaiting_price)
async def process_merch_price(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        price = int(message.text)
        await state.update_data(price=price)
        item_data = await state.get_data()
        
        if 'photo_file_id' not in item_data or not item_data['photo_file_id']:
            logger.error("photo_file_id is missing from FSM data during merch creation!")
            await message.answer(Text.MERCH_CREATE_PHOTO_ID_ERROR)
            await state.clear()
            return

        await admin_requests.create_merch_item(session, item_data)
        await session.commit()
        await state.clear()
        
        await message.answer(Text.MERCH_CREATE_SUCCESS, reply_markup=inline.get_back_to_admin_panel_keyboard())
    except ValueError:
        await message.answer(Text.MERCH_PRICE_NAN_ERROR)

# --- Просмотр и редактирование товаров ---
@router.callback_query(F.data == "admin_view_merch", RoleFilter('admin'))
async def view_merch_items(callback: types.CallbackQuery, session: AsyncSession):
    items = await admin_requests.get_all_merch_items(session)
    if not items:
        await callback.message.edit_text(Text.ADMIN_NO_MERCH_ITEMS, reply_markup=inline.get_merch_management_keyboard())
        return

    builder = InlineKeyboardBuilder()
    for item in items:
        status = "✅" if item.is_available else "❌"
        builder.row(types.InlineKeyboardButton(text=f"{status} {item.name} ({item.price}Б)", callback_data=f"admin_show_merch_{item.id}"))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_merch"))

    try:
        await callback.message.edit_text(Text.ADMIN_CHOOSE_MERCH_TO_MANAGE, reply_markup=builder.as_markup())
    except TelegramBadRequest:
        await callback.message.delete()
        await callback.message.answer(Text.ADMIN_CHOOSE_MERCH_TO_MANAGE, reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("admin_show_merch_"), RoleFilter('admin'))
async def show_single_merch_card(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer(Text.MERCH_ITEM_NOT_FOUND, show_alert=True)

    status_text = '✅ Доступен' if item.is_available else '❌ Недоступен'
    caption = Text.MERCH_CARD_CAPTION.format(
        name=item.name,
        description=item.description,
        price=item.price,
        status=status_text
    )
    # ИСПРАВЛЕНО: parse_mode="HTML"
    await callback.message.edit_media(media=types.InputMediaPhoto(media=item.photo_file_id, caption=caption, parse_mode="HTML"),
        reply_markup=inline.get_single_merch_management_keyboard(item.id, item.is_available))
    await callback.answer()

@router.callback_query(F.data.startswith("admin_edit_merch_"), RoleFilter('admin'))
async def start_merch_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return

    await state.update_data(item_id=item_id)
    await state.set_state(MerchEditing.choosing_field)
    
    fields = {"name": "Название", "description": "Описание", "price": "Цена"}
    builder = InlineKeyboardBuilder()
    for key, name in fields.items():
        builder.row(types.InlineKeyboardButton(text=f"Изменить: {name}", callback_data=f"edit_merch_field_{key}"))
    builder.row(types.InlineKeyboardButton(text="✅ Завершить", callback_data=f"admin_show_merch_{item_id}"))
    
    # ИСПРАВЛЕНО: parse_mode="HTML"
    await callback.message.edit_caption(caption=Text.MERCH_EDIT_PROMPT.format(name=item.name), reply_markup=builder.as_markup(), parse_mode="HTML")

@router.callback_query(MerchEditing.choosing_field, F.data.startswith("edit_merch_field_"))
async def choose_merch_field_to_edit(callback: types.CallbackQuery, state: FSMContext):
    field_to_edit = callback.data.split('_', 3)[-1]
    await state.update_data(field_to_edit=field_to_edit)
    await state.set_state(MerchEditing.awaiting_new_value)
    
    prompt = Text.MERCH_EDIT_FIELD_PROMPTS.get(field_to_edit, Text.MERCH_EDIT_NEW_VALUE_PROMPT)
    await callback.message.delete()
    await callback.message.answer(prompt)
    await callback.answer()

@router.message(MerchEditing.awaiting_new_value)
async def process_new_value_for_merch(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    field, item_id, new_value_str = data.get("field_to_edit"), data.get("item_id"), message.text
    try:
        update_value = int(new_value_str) if field == "price" else new_value_str
    except ValueError:
        return await message.answer(Text.MERCH_PRICE_NAN_ERROR)

    await admin_requests.update_merch_item_field(session, item_id, field, update_value)
    await session.commit()
    await message.answer(Text.MERCH_EDIT_SUCCESS)
    await state.clear()
    
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    status_text = '✅ Доступен' if item.is_available else '❌ Недоступен'
    caption = Text.MERCH_CARD_CAPTION.format(
        name=item.name,
        description=item.description,
        price=item.price,
        status=status_text
    )
    # ИСПРАВЛЕНО: parse_mode="HTML"
    await message.answer_photo(photo=item.photo_file_id, caption=caption,
        reply_markup=inline.get_single_merch_management_keyboard(item.id, item.is_available), parse_mode="HTML")

@router.callback_query(F.data.startswith("admin_toggle_merch_"), RoleFilter('admin'))
async def toggle_merch_availability(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    new_status = await admin_requests.toggle_merch_item_availability(session, item_id)
    await session.commit()
    status_text = 'доступен' if new_status else 'недоступен'
    await callback.answer(Text.MERCH_TOGGLE_AVAILABILITY.format(status=status_text), show_alert=True)
    await show_single_merch_card(callback, session)

@router.callback_query(F.data.startswith("admin_delete_merch_"), RoleFilter('admin'))
async def ask_for_merch_deletion_confirmation(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer(Text.MERCH_ITEM_NOT_FOUND, show_alert=True)
    
    try: await callback.message.delete()
    except TelegramBadRequest: pass
    
    # ИСПРАВЛЕНО: parse_mode="HTML"
    await callback.message.answer(
        Text.MERCH_DELETE_CONFIRMATION.format(name=item.name),
        reply_markup=inline.get_merch_deletion_confirmation_keyboard(item_id), parse_mode="HTML")
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_delete_merch_"), RoleFilter('admin'))
async def confirm_and_delete_merch(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer(Text.MERCH_ITEM_ALREADY_DELETED, show_alert=True)
    
    item_name = item.name
    await admin_requests.delete_merch_item_by_id(session, item_id)
    await session.commit()
    # ИСПРАВЛЕНО: parse_mode="HTML"
    await callback.message.edit_text(Text.MERCH_DELETE_SUCCESS.format(name=item_name), reply_markup=inline.get_back_to_merch_menu_keyboard(), parse_mode="HTML")
    await callback.answer()

# =============================================================================
# --- 📦 ОБРАБОТКА ЗАКАЗОВ ---
# =============================================================================
@router.callback_query(F.data == "admin_process_orders", RoleFilter('admin'))
async def process_orders_list(callback: types.CallbackQuery, session: AsyncSession):
    orders = await admin_requests.get_pending_orders(session)
    if not orders:
        await callback.answer(Text.ADMIN_NO_PENDING_ORDERS, show_alert=True)
        return
    
    text_parts = [Text.ADMIN_PENDING_ORDERS_HEADER]
    builder = InlineKeyboardBuilder()
    for order in orders:
        user_link = hlink(order.user.full_name, f"tg://user?id={order.user.telegram_id}")
        
        if order.user.telegram_username:
            order_info = Text.ADMIN_ORDER_ITEM_TEXT.format(
                order_id=order.id,
                date=order.order_date.strftime('%d.%m %H:%M'),
                item_name=order.item.name,
                user_link=user_link,
                username=order.user.telegram_username,
                phone=order.user.phone_number
            )
        else:
            order_info = Text.ADMIN_ORDER_ITEM_TEXT_NO_USERNAME.format(
                order_id=order.id,
                date=order.order_date.strftime('%d.%m %H:%M'),
                item_name=order.item.name,
                user_link=user_link,
                phone=order.user.phone_number
            )

        text_parts.append(order_info)
        text_parts.append("")
        builder.row(types.InlineKeyboardButton(text=f"✅ Выдать заказ №{order.id}", callback_data=f"complete_order_{order.id}"))
    
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    
    await callback.message.edit_text(
        text="\n".join(text_parts), 
        reply_markup=builder.as_markup(), 
        parse_mode="HTML",
        disable_web_page_preview=True
    )
    await callback.answer()
    
@router.callback_query(F.data.startswith("complete_order_"), RoleFilter('admin'))
async def complete_order(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    order_id = int(callback.data.split('_')[-1])
    
    admin_user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not admin_user:
        await callback.answer(Text.ADMIN_COMPLETE_ORDER_ADMIN_ID_ERROR, show_alert=True)
        return

    order = await session.get(MerchOrder, order_id, options=[joinedload(MerchOrder.item), joinedload(MerchOrder.user)])
    if not order or order.status != 'pending_pickup':
        await callback.answer(Text.ADMIN_ORDER_NOT_FOUND_OR_PROCESSED, show_alert=True)
        return

    await admin_requests.complete_order(session, order_id, admin_user.id)
    await session.commit()
    await callback.answer(Text.ADMIN_ORDER_COMPLETED_SUCCESS.format(order_id=order_id), show_alert=True)
    
    try:
        await bot.send_message(
            chat_id=order.user.telegram_id,
            text=Text.USER_ORDER_COMPLETED_NOTIFICATION.format(item_name=order.item.name)
        )
    except Exception as e:
        logger.error(f"Failed to notify user {order.user.id} about order completion: {e}")
    
    await process_orders_list(callback, session)

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/merch_management.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/qa_management.py ---

from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload

from bot.db import question_requests, user_requests
from bot.filters.role import RoleFilter
from bot.states.states import AnswerQuestion
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router(name="admin_qa_management")

@router.callback_query(F.data == "admin_answer_questions", RoleFilter('admin'))
async def show_unanswered_questions(callback: types.CallbackQuery, session: AsyncSession):
    questions = await question_requests.get_unanswered_questions(session)
    if not questions:
        await callback.answer("Новых вопросов от пользователей нет.", show_alert=True)
        return

    builder = InlineKeyboardBuilder()
    for q in questions:
        builder.row(types.InlineKeyboardButton(
            text=f"От {q.user.full_name}: {q.question_text[:30]}...",
            callback_data=f"answer_q_{q.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    
    await callback.message.edit_text(
        "<b>Неотвеченные вопросы:</b>\n\nВыберите вопрос, чтобы ответить:",
        reply_markup=builder.as_markup(),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("answer_q_"), RoleFilter('admin'))
async def start_answering_question(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    question_id = int(callback.data.split("_")[-1])
    question = await session.get(question_requests.Question, question_id, options=[joinedload(question_requests.Question.user)])
    if not question:
        await callback.answer("Вопрос не найден.", show_alert=True)
        return
        
    await state.set_state(AnswerQuestion.awaiting_answer)
    await state.update_data(question_id=question.id, user_to_answer_id=question.user.telegram_id)
    
    await callback.message.edit_text(
        f"<b>Вопрос от:</b> {question.user.full_name}\n"
        f"<b>Текст вопроса:</b>\n<i>{Text.escape_html(question.question_text)}</i>\n\n"
        f"<b>Введите ваш ответ:</b>",
        parse_mode="HTML"
    )
    await callback.answer()

@router.message(AnswerQuestion.awaiting_answer)
async def process_answer(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    question_id = data.get("question_id")
    user_to_answer_id = data.get("user_to_answer_id")
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    
    await question_requests.answer_question(session, question_id, message.text, admin_user.id)
    
    question = await session.get(question_requests.Question, question_id)

    # Уведомляем пользователя
    try:
        await bot.send_message(
            chat_id=user_to_answer_id,
            text=(
                f"📨 <b>Получен ответ на ваш вопрос!</b>\n\n"
                f"<b>Ваш вопрос:</b>\n<i>{Text.escape_html(question.question_text)}</i>\n\n"
                f"<b>Ответ организаторов:</b>\n{Text.escape_html(message.text)}"
            ),
            parse_mode="HTML"
        )
    except Exception as e:
        await message.answer(f"Не удалось уведомить пользователя. Ошибка: {e}")

    await state.clear()
    await message.answer("✅ Ответ отправлен пользователю.", reply_markup=inline.get_back_to_admin_panel_keyboard())

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/qa_management.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/system.py ---

import io
import logging
import zipfile
import datetime
import pandas as pd
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext  # <-- ВОТ НУЖНЫЙ ИМПОРТ
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests, user_requests
from bot.db.models import User
from bot.filters.role import RoleFilter
from bot.states.states import DataImport
from bot.utils.text_messages import Text

router = Router(name="admin_system")
logger = logging.getLogger(__name__)


# =============================================================================
# --- 💾 ЭКСПОРТ ДАННЫХ (ТОЛЬКО ДЛЯ ГЛАВНОГО АДМИНА) ---
# =============================================================================

async def create_full_backup_xlsx(session: AsyncSession) -> io.BytesIO:
    """
    Собирает данные из всех таблиц, создает XLSX-файл с несколькими листами.
    """
    all_data_models = await admin_requests.get_all_data_for_export(session)
    
    output_buffer = io.BytesIO()
    with pd.ExcelWriter(output_buffer, engine='openpyxl') as writer:
        for table_name, records in all_data_models.items():
            if not records:
                continue

            data_list = [
                {c.name: getattr(record, c.name) for c in record.__table__.columns}
                for record in records
            ]
            
            df = pd.DataFrame(data_list)
            for col in df.columns:
                if pd.api.types.is_datetime64_any_dtype(df[col]) and df[col].dt.tz is not None:
                    df[col] = df[col].dt.tz_localize(None)
            for col in df.columns:
                if not df[col].dropna().empty:
                    if isinstance(df[col].dropna().iloc[0], (dict, list)):
                        df[col] = df[col].astype(str)
            
            df.to_excel(writer, sheet_name=table_name.capitalize(), index=False)

    output_buffer.seek(0)
    return output_buffer


@router.callback_query(F.data == "ma_export_data", RoleFilter('main_admin'))
async def export_data_start(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """
    Запускает процесс создания и отправки полного бэкапа в XLSX.
    """
    msg = await callback.message.edit_text(Text.EXPORT_STARTED)
    await callback.answer()

    try:
        xlsx_archive_bytes = await create_full_backup_xlsx(session)
        
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")
        filename = f"donor_bot_backup_{timestamp}.xlsx"
        
        await bot.send_document(
            chat_id=callback.from_user.id,
            document=types.BufferedInputFile(xlsx_archive_bytes.read(), filename=filename),
            caption=Text.EXPORT_SUCCESSFUL
        )
        
        await msg.delete()

    except Exception as e:
        logger.error(f"Failed to create data backup: {e}", exc_info=True)
        await msg.edit_text(Text.EXPORT_FAILED)


# =============================================================================
# --- 📥 ИМПОРТ ДАННЫХ (ТОЛЬКО ДЛЯ ГЛАВНОГО АДМИНА) ---
# =============================================================================

@router.callback_query(F.data == "ma_import_data", RoleFilter('main_admin'))
async def import_data_start(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(DataImport.awaiting_file)
    await callback.message.edit_text("Отправьте .xlsx файл для импорта/обновления данных пользователей. Обязательные колонки: `phone_number` (для поиска), `full_name`, `university`.")
    await callback.answer()

@router.callback_query(F.data == "ma_import_old_db", RoleFilter('main_admin'))
async def import_old_db_start(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(DataImport.awaiting_old_db_file)
    await callback.message.edit_text("Отправьте .xlsx файл для импорта старой базы данных.")
    await callback.answer()


from bot.utils.data_import import import_data_from_file

@router.message(DataImport.awaiting_old_db_file, F.document)
async def process_import_old_db_file(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    if not message.document.file_name.endswith('.xlsx'):
        await message.answer("Неверный формат файла. Пожалуйста, отправьте файл .xlsx")
        return

    await state.clear()
    status_msg = await message.answer("Файл получен. Начинаю обработку...")
    
    file_info = await bot.get_file(message.document.file_id)
    file_bytes = await bot.download_file(file_info.file_path)

    try:
        created_count, updated_count = await import_data_from_file(session, file_bytes)
        await status_msg.edit_text(f"✅ Импорт завершен!\n\n- Создано новых пользователей: {created_count}\n- Обновлено существующих: {updated_count}")
        
    except Exception as e:
        logger.error(f"Error processing XLSX import: {e}", exc_info=True)
        await status_msg.edit_text(f"❌ Произошла ошибка при обработке файла: {e}")

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/system.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/user_management.py ---

import logging
import datetime
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.markdown import hbold, hcode
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests, user_requests, event_requests
from bot.filters.role import RoleFilter
from bot.states.states import (
    PointsChange,
    ManualWaiver,
    UserSearch,
    BlockUser,
    AdminAddUser,
)
from bot.keyboards import inline
from bot.utils.text_messages import Text

router = Router(name="admin_user_management")
logger = logging.getLogger(__name__)


# =============================================================================
# --- 👥 УПРАВЛЕНИЕ ПОЛЬЗОВАТЕЛЯМИ ---
# =============================================================================

@router.callback_query(F.data == "admin_manage_users", RoleFilter('admin'))
async def manage_users_main_menu(callback: types.CallbackQuery):
    """Показывает главное меню управления пользователями."""
    await callback.message.edit_text(
        Text.ADMIN_USERS_HEADER,
        reply_markup=inline.get_user_management_main_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

# --- Список пользователей с пагинацией ---
@router.callback_query(F.data.startswith("admin_users_list_page_"), RoleFilter('admin'))
async def show_users_list(callback: types.CallbackQuery, session: AsyncSession):
    page = int(callback.data.split('_')[-1])
    page_size = 10

    users, total_pages = await admin_requests.get_users_page(session, page, page_size)

    if not users:
        await callback.message.edit_text(Text.ADMIN_NO_USERS_IN_DB, reply_markup=inline.get_user_management_main_keyboard())
        await callback.answer()
        return

    text = Text.USERS_LIST_HEADER.format(page=page, total_pages=total_pages)
    builder = InlineKeyboardBuilder()
    for user in users:
        builder.row(types.InlineKeyboardButton(text=f"👤 {user.full_name}", callback_data=f"admin_show_user_{user.id}"))

    pagination_keyboard = inline.get_users_list_pagination_keyboard(page, total_pages)
    for row in pagination_keyboard.inline_keyboard:
        builder.row(*row)

    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode="HTML")
    await callback.answer()

# --- Поиск пользователя ---
@router.callback_query(F.data == "admin_search_user", RoleFilter('admin'))
async def search_user_start(callback: types.CallbackQuery, state: FSMContext):
    """Запускает FSM для поиска пользователя."""
    await state.clear()
    await state.set_state(UserSearch.awaiting_query)
    await callback.message.edit_text(Text.USER_SEARCH_PROMPT)
    await callback.answer()

@router.message(UserSearch.awaiting_query)
async def process_user_search(message: types.Message, state: FSMContext, session: AsyncSession):
    """Ищет пользователей по запросу и выводит результат."""
    await state.clear()
    query = message.text
    users_found = await admin_requests.find_user_for_admin(session, query)

    if not users_found:
        await message.answer(Text.USER_SEARCH_NO_RESULTS, reply_markup=inline.get_user_management_main_keyboard())
        return

    text = Text.USER_SEARCH_RESULTS_HEADER.format(query=query)
    builder = InlineKeyboardBuilder()
    for user in users_found:
        builder.row(types.InlineKeyboardButton(text=f"👤 {user.full_name}", callback_data=f"admin_show_user_{user.id}"))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_users"))

    await message.answer(text, reply_markup=builder.as_markup(), parse_mode="HTML")

# --- Карточка пользователя и управление им ---
@router.callback_query(F.data.startswith("admin_show_user_"), RoleFilter('admin'))
async def show_single_user_card(callback: types.CallbackQuery, session: AsyncSession):
    """Показывает карточку одного пользователя с динамической клавиатурой."""
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer: return

    target_user_id = int(callback.data.split('_')[-1])
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await callback.answer(Text.USER_NOT_FOUND, show_alert=True)
        return

    block_status = "ЗАБЛОКИРОВАН" if target_user.is_blocked else "Активен"

    text = "\n".join([
        hbold(Text.USER_CARD_HEADER.format(full_name=target_user.full_name)),
        "",
        Text.USER_CARD_TEMPLATE.format(
            full_name=Text.escape_html(target_user.full_name),
            telegram_id=target_user.telegram_id,
            username=Text.escape_html(target_user.telegram_username or 'не указан'),
            phone_number=target_user.phone_number,
            role=target_user.role,
            points=target_user.points,
            block_status=block_status
        )
    ])

    await callback.message.edit_text(
        text,
        reply_markup=inline.get_user_management_keyboard(
            target_user_id=target_user.id,
            target_user_role=target_user.role,
            viewer_role=viewer.role,
            is_blocked=target_user.is_blocked
        ),
        parse_mode="HTML"
    )
    await callback.answer()

# --- +/- Баллы (FSM) ---
@router.callback_query(F.data.startswith("admin_points_"), RoleFilter('admin'))
async def change_points_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    user_id = int(callback.data.split('_')[-1])
    await state.update_data(user_id=user_id)
    await state.set_state(PointsChange.awaiting_points_amount)
    await callback.message.edit_text(Text.CHANGE_POINTS_PROMPT)
    await callback.answer()

@router.message(PointsChange.awaiting_points_amount)
async def change_points_amount(message: types.Message, state: FSMContext):
    try:
        points = int(message.text)
        await state.update_data(points=points)
        await state.set_state(PointsChange.awaiting_reason)
        await message.answer(Text.CHANGE_POINTS_REASON_PROMPT)
    except ValueError:
        await message.answer(Text.EVENT_POINTS_NAN_ERROR)

@router.message(PointsChange.awaiting_reason)
async def change_points_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason, user_id, points_change = message.text, data['user_id'], data['points']
    
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await message.answer(Text.USER_NOT_FOUND)
        await state.clear()
        return

    await admin_requests.add_points_to_user(session, user_id, points_change, reason)
    await session.commit()
    await state.clear()

    new_balance = user.points
    await message.answer(
        Text.CHANGE_POINTS_SUCCESS.format(name=user.full_name, balance=new_balance),
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )

    try:
        await bot.send_message(
            chat_id=user.telegram_id, # ИСПРАВЛЕНО
            text=Text.USER_POINTS_CHANGED_NOTIFICATION.format(points=points_change, reason=reason, balance=new_balance),
            parse_mode="HTML"
        )
    except Exception as e:
        logger.error(f"Failed to notify user {user_id} about points change: {e}")

# --- Ручное управление ролями ---
@router.callback_query(F.data.startswith("admin_promote_volunteer_"), RoleFilter('admin'))
async def promote_to_volunteer(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, user_id, 'volunteer')
    await session.commit()
    user = await user_requests.get_user_by_id(session, user_id)
    await callback.answer(Text.USER_PROMOTED_VOLUNTEER.format(name=user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=user.telegram_id, text=Text.USER_PROMOTED_VOLUNTEER_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {user.id} about promotion: {e}")
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("admin_demote_volunteer_"), RoleFilter('admin'))
async def demote_from_volunteer(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, user_id, 'student')
    await session.commit()
    user = await user_requests.get_user_by_id(session, user_id)
    await callback.answer(Text.USER_DEMOTED_VOLUNTEER.format(name=user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=user.telegram_id, text=Text.USER_DEMOTED_VOLUNTEER_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {user.id} about demotion: {e}")
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("ma_promote_admin_"), RoleFilter('main_admin'))
async def promote_to_admin(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    target_user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, target_user_id, 'admin')
    await session.commit()
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    await callback.answer(Text.USER_PROMOTED_ADMIN.format(name=target_user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=target_user.telegram_id, text=Text.USER_PROMOTED_ADMIN_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about admin promotion: {e}")
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("ma_demote_admin_"), RoleFilter('main_admin'))
async def demote_from_admin(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    target_user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, target_user_id, 'student')
    await session.commit()
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    await callback.answer(Text.USER_DEMOTED_ADMIN.format(name=target_user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=target_user.telegram_id, text=Text.USER_DEMOTED_ADMIN_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about admin demotion: {e}")
    await show_single_user_card(callback, session)

# --- Управление блокировками ---
@router.callback_query(F.data.startswith("ma_block_user_"), RoleFilter('main_admin'))
async def block_user_from_card(callback: types.CallbackQuery, state: FSMContext):
    target_user_id = int(callback.data.split('_')[-1])
    await state.clear()
    await state.update_data(user_id=target_user_id)
    await state.set_state(BlockUser.awaiting_reason)
    await callback.message.edit_text(Text.BLOCK_USER_REASON_PROMPT)
    await callback.answer()

@router.message(BlockUser.awaiting_reason)
async def process_block_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason = message.text
    target_user_id = data['user_id']

    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    if not admin_user:
        await message.answer(Text.ADMIN_ID_ERROR)
        await state.clear()
        return

    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await message.answer(Text.BLOCK_TARGET_USER_NOT_FOUND)
        await state.clear()
        return

    await admin_requests.block_user(session, target_user_id, admin_user.id, reason)
    await session.commit()
    await state.clear()

    await message.answer(
        Text.USER_BLOCKED_SUCCESS.format(name=target_user.full_name, reason=reason),
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )
    try:
        await bot.send_message(chat_id=target_user.telegram_id, text=Text.USER_BLOCKED_NOTIFY.format(reason=reason))
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about block: {e}")

@router.callback_query(F.data.startswith("ma_unblock_user_"), RoleFilter('main_admin'))
async def unblock_user_from_card(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    target_user_id = int(callback.data.split('_')[-1])
    await admin_requests.unblock_user(session, target_user_id)
    await session.commit()
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await callback.answer(Text.USER_NOT_FOUND, show_alert=True)
        return

    await callback.answer(Text.USER_UNBLOCKED_SUCCESS.format(name=target_user.full_name), show_alert=True)
    try:
        await bot.send_message(chat_id=target_user.telegram_id, text=Text.USER_UNBLOCKED_NOTIFY)
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about unblock: {e}")
    await show_single_user_card(callback, session)


# --- Ручное управление регистрациями ---
@router.callback_query(F.data.startswith("admin_manage_user_regs_"), RoleFilter('admin'))
async def manage_user_registrations_menu(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await callback.answer(Text.USER_NOT_FOUND, show_alert=True)
        return

    await callback.message.edit_text(
        Text.MANAGE_USER_REGS_HEADER.format(name=user.full_name),
        reply_markup=inline.get_manual_registration_management_keyboard(user_id),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_reg_start_"), RoleFilter('admin'))
async def show_events_for_manual_registration(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    events = await event_requests.get_upcoming_events(session)
    if not events:
        await callback.answer(Text.MANUAL_REG_NO_EVENTS, show_alert=True)
        return

    await callback.message.edit_text(
        Text.MANUAL_REG_CHOOSE_EVENT,
        reply_markup=inline.get_events_for_manual_registration_keyboard(user_id, events)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("adminReg_"), RoleFilter('admin'))
async def confirm_manual_registration(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    _, user_id_str, event_id_str = callback.data.split('_')
    user_id, event_id = int(user_id_str), int(event_id_str)
    
    user = await user_requests.get_user_by_id(session, user_id)
    event = await event_requests.get_event_by_id(session, event_id)
    if not user or not event:
        await callback.answer(Text.ERROR_GENERIC_ALERT, show_alert=True)
        return

    success, message = await admin_requests.manually_register_user(session, user, event)
    if success:
        await session.commit()
        try:
            await bot.send_message(
                chat_id=user.telegram_id,
                text=Text.MANUAL_REG_SUCCESS_NOTIFY.format(event_name=event.name, date=event.event_datetime.strftime('%d.%m.%Y')),
                parse_mode="HTML"
            )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about manual registration: {e}")
            await callback.message.answer(Text.NOTIFY_USER_FAILED.format(name=user.full_name))
    else:
        await session.rollback()

    await callback.answer(message, show_alert=True)
    # This might fail if the original message was deleted, need a robust way to return to menu
    try:
        await manage_user_registrations_menu(callback, session)
    except Exception:
        await callback.message.answer("Возврат в меню...", reply_markup=inline.get_back_to_admin_panel_keyboard())


@router.callback_query(F.data.startswith("admin_cancel_start_"), RoleFilter('admin'))
async def show_registrations_for_cancellation(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    registrations = await admin_requests.get_user_registrations(session, user_id)
    
    if not registrations:
        await callback.answer(Text.MANUAL_CANCEL_NO_REGS, show_alert=True)
        return

    await callback.message.edit_text(
        Text.MANUAL_CANCEL_CHOOSE_REG,
        reply_markup=inline.get_registrations_for_cancellation_keyboard(user_id, registrations)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("adminCancel_"), RoleFilter('admin'))
async def confirm_manual_cancellation(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    _, user_id_str, event_id_str = callback.data.split('_')
    user_id, event_id = int(user_id_str), int(event_id_str)

    user = await user_requests.get_user_by_id(session, user_id)
    event = await event_requests.get_event_by_id(session, event_id)
    if not user or not event:
        await callback.answer(Text.ERROR_GENERIC_ALERT, show_alert=True)
        return
        
    success = await event_requests.cancel_registration(session, user_id, event_id)
    if success:
        await session.commit()
        await callback.answer(Text.MANUAL_CANCEL_SUCCESS.format(name=user.full_name, event_name=event.name), show_alert=True)
        try:
            await bot.send_message(
                chat_id=user.telegram_id,
                text=Text.MANUAL_CANCEL_SUCCESS_NOTIFY.format(event_name=event.name),
                parse_mode="HTML"
            )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about manual cancellation: {e}")
            await callback.message.answer(Text.NOTIFY_USER_FAILED.format(name=user.full_name))
    else:
        await session.rollback()
        await callback.answer(Text.MANUAL_CANCEL_FAIL, show_alert=True)
    
    try:
        await manage_user_registrations_menu(callback, session)
    except Exception:
         await callback.message.answer("Возврат в меню...", reply_markup=inline.get_back_to_admin_panel_keyboard())


# --- Управление медотводами ---
@router.callback_query(F.data.startswith("admin_manage_waivers_"), RoleFilter('admin'))
async def admin_manage_user_waivers_menu(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await callback.answer(Text.USER_NOT_FOUND, show_alert=True)
        return

    waivers = await admin_requests.get_all_user_active_waivers(session, user_id)
    text_header = Text.MANAGE_WAIVERS_HEADER.format(name=user.full_name)
    if not waivers:
        text = text_header + Text.MANAGE_WAIVERS_NO_WAIVERS
    else:
        text = text_header + Text.MANAGE_WAIVERS_WITH_WAIVERS

    await callback.message.edit_text(
        text,
        reply_markup=inline.get_admin_waiver_management_keyboard(user_id, waivers),
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_waiver_"), RoleFilter('admin'))
async def set_waiver_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    user_id = int(callback.data.split('_')[-1])
    await state.update_data(user_id=user_id)
    await state.set_state(ManualWaiver.awaiting_end_date)
    await callback.message.edit_text(Text.MANUAL_WAIVER_DATE_PROMPT)
    await callback.answer()

@router.message(ManualWaiver.awaiting_end_date)
async def set_waiver_date(message: types.Message, state: FSMContext):
    try:
        end_date = datetime.datetime.strptime(message.text, "%d.%m.%Y").date()
        await state.update_data(end_date=end_date)
        await state.set_state(ManualWaiver.awaiting_reason)
        await message.answer(Text.MANUAL_WAIVER_REASON_PROMPT)
    except ValueError:
        await message.answer(Text.DATE_FORMAT_ERROR, parse_mode="HTML")

@router.message(ManualWaiver.awaiting_reason)
async def set_waiver_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason, user_id, end_date = message.text, data['user_id'], data['end_date']
    
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    user = await user_requests.get_user_by_id(session, user_id)

    await admin_requests.create_manual_waiver(session, user_id, end_date, reason, admin_user.id)
    await session.commit()
    await state.clear()

    await message.answer(
        Text.MANUAL_WAIVER_SUCCESS.format(name=user.full_name, date=end_date.strftime('%d.%m.%Y')),
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )
    try:
        await bot.send_message(
            chat_id=user.telegram_id,
            text=Text.MANUAL_WAIVER_NOTIFY.format(date=end_date.strftime('%d.%m.%Y'), reason=reason),
            parse_mode="HTML"
        )
    except Exception as e:
        logger.error(f"Failed to notify user {user_id} about manual waiver: {e}")

@router.callback_query(F.data.startswith("admin_del_waiver_"), RoleFilter('admin'))
async def admin_delete_waiver(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    try:
        _, _, _, waiver_id_str, user_id_str = callback.data.split('_')
        waiver_id, user_id = int(waiver_id_str), int(user_id_str)
    except ValueError:
        await callback.answer(Text.ADMIN_DELETE_WAIVER_DATA_ERROR, show_alert=True)
        return

    success = await admin_requests.force_delete_waiver(session, waiver_id)
    if success:
        await session.commit()
        await callback.answer(Text.ADMIN_DELETE_WAIVER_SUCCESS, show_alert=True)
        try:
            user = await user_requests.get_user_by_id(session, user_id)
            if user:
                await bot.send_message(chat_id=user.telegram_id, text=Text.ADMIN_DELETE_WAIVER_NOTIFY)
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about admin waiver deletion: {e}")
    else:
        await session.rollback()
        await callback.answer(Text.ADMIN_DELETE_WAIVER_FAIL, show_alert=True)
    
    try:
        await admin_manage_user_waivers_menu(callback, session)
    except Exception:
        await callback.message.answer("Возврат в меню...", reply_markup=inline.get_back_to_admin_panel_keyboard())
        
        
        
        
@router.callback_query(F.data == "admin_add_user_start", RoleFilter('admin'))
async def add_user_start(callback: types.CallbackQuery, state: FSMContext):
    """Начало FSM добавления пользователя."""
    await state.clear()
    await state.set_state(AdminAddUser.awaiting_phone)
    await callback.message.edit_text("<b>Шаг 1/8:</b> Введите номер телефона нового пользователя в формате <code>+7...</code>")
    await callback.answer()

@router.message(AdminAddUser.awaiting_phone)
async def add_user_phone(message: types.Message, state: FSMContext, session: AsyncSession):
    phone_number = message.text
    if not phone_number.startswith('+') or not phone_number[1:].isdigit() or len(phone_number) < 11:
        await message.answer("❌ Неверный формат номера. Введите в формате <code>+7...</code>")
        return

    existing_user = await user_requests.get_user_by_phone(session, phone_number)
    if existing_user:
        await message.answer(f"❌ Пользователь с номером {phone_number} уже существует: {existing_user.full_name}.")
        await state.clear()
        return

    # Генерируем уникальный отрицательный ID
    min_user_id = await admin_requests.get_min_user_id(session)
    new_telegram_id = min(0, min_user_id) - 1

    await state.update_data(
        phone_number=phone_number,
        telegram_id=new_telegram_id,
        telegram_username=f"manual_{phone_number}"
    )
    await state.set_state(AdminAddUser.awaiting_full_name)
    await message.answer("<b>Шаг 2/8:</b> Введите ФИО пользователя.")

# Далее мы можем использовать почти те же шаги, что и при обычной регистрации.
# Просто привязываем их к нашему новому состоянию AdminAddUser.
# Этот код можно добавить в конец файла user_management.py

@router.message(AdminAddUser.awaiting_full_name)
async def add_user_full_name(message: types.Message, state: FSMContext):
    await state.update_data(full_name=message.text.strip())
    await state.set_state(AdminAddUser.awaiting_category)
    await message.answer("<b>Шаг 3/8:</b> Выберите категорию пользователя.", reply_markup=inline.get_category_keyboard())

@router.callback_query(AdminAddUser.awaiting_category, F.data.startswith('category_'))
async def add_user_category(callback: types.CallbackQuery, state: FSMContext):
    category = callback.data.split('_', 1)[1]
    await state.update_data(category=category)
    await callback.message.edit_text("<b>Шаг 4/8:</b> Выберите ВУЗ.", reply_markup=inline.get_university_keyboard())
    await state.set_state(AdminAddUser.awaiting_university)
    await callback.answer()

@router.callback_query(AdminAddUser.awaiting_university, F.data.startswith('university_'))
async def add_user_university(callback: types.CallbackQuery, state: FSMContext):
    choice = callback.data.split('_', 1)[1]
    if choice == 'mifi':
        await state.update_data(university="НИЯУ МИФИ")
        await callback.message.edit_text("<b>Шаг 5/8:</b> Выберите факультет.", reply_markup=inline.get_faculties_keyboard())
        await state.set_state(AdminAddUser.awaiting_faculty)
    else:
        await callback.message.edit_text("<b>Шаг 5/8:</b> Введите название ВУЗа.")
        await state.set_state(AdminAddUser.awaiting_custom_university_name)
    await callback.answer()

@router.message(AdminAddUser.awaiting_custom_university_name)
async def add_user_custom_university(message: types.Message, state: FSMContext):
    await state.update_data(university=message.text)
    await message.answer("<b>Шаг 6/8:</b> Введите факультет.")
    await state.set_state(AdminAddUser.awaiting_custom_faculty_name)

@router.callback_query(AdminAddUser.awaiting_faculty, F.data.startswith('faculty_'))
async def add_user_faculty(callback: types.CallbackQuery, state: FSMContext):
    faculty = callback.data.split('_', 1)[1]
    if faculty == 'Other':
        await callback.message.edit_text("<b>Шаг 6/8:</b> Введите название факультета.")
        await state.set_state(AdminAddUser.awaiting_custom_faculty_name)
    else:
        await state.update_data(faculty=faculty)
        await callback.message.edit_text("<b>Шаг 7/8:</b> Введите номер группы (или 'нет').")
        await state.set_state(AdminAddUser.awaiting_study_group)
    await callback.answer()
    
@router.message(AdminAddUser.awaiting_custom_faculty_name)
async def add_user_custom_faculty(message: types.Message, state: FSMContext):
    await state.update_data(faculty=message.text)
    await message.answer("<b>Шаг 7/8:</b> Введите номер группы (или 'нет').")
    await state.set_state(AdminAddUser.awaiting_study_group)

@router.message(AdminAddUser.awaiting_study_group)
async def add_user_study_group(message: types.Message, state: FSMContext):
    await state.update_data(study_group=message.text)
    await state.set_state(AdminAddUser.awaiting_gender)
    await message.answer("<b>Шаг 8/8:</b> Укажите пол.", reply_markup=inline.get_gender_inline_keyboard())

@router.callback_query(AdminAddUser.awaiting_gender, F.data.startswith("gender_"))
async def add_user_gender(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """Последний шаг - сохранение."""
    gender = callback.data.split('_', 1)[1]
    await state.update_data(gender=gender, consent_given=True) # Согласие подразумевается, т.к. добавляет админ
    
    user_data = await state.get_data()

    await user_requests.add_user(session, user_data)
    await session.commit()
    await state.clear()
    
    await callback.message.edit_text(
        f"✅ Пользователь <b>{user_data['full_name']}</b> успешно добавлен в базу данных.",
        reply_markup=inline.get_user_management_main_keyboard()
    )
    await callback.answer("Пользователь добавлен!", show_alert=True)

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/user_management.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/__init__.py ---

from aiogram import Router, F, types
from sqlalchemy.ext.asyncio import AsyncSession

from bot.filters.role import RoleFilter
from bot.db import user_requests
from bot.keyboards import inline
from bot.utils.text_messages import Text

from .user_management import router as user_management_router
from .event_management import router as event_management_router
from .merch_management import router as merch_management_router
from .mailing import router as mailing_router
from .system import router as system_router
from .analytics import router as analytics_router
from .info_management import router as info_management_router
from .qa_management import router as qa_management_router

admin_router = Router(name="admin")

admin_router.include_routers(
    user_management_router,
    event_management_router,
    merch_management_router,
    mailing_router,
    system_router,
    analytics_router,
    info_management_router,
    qa_management_router,
)

@admin_router.callback_query(F.data == "admin_panel", RoleFilter('admin'))
async def show_admin_panel(callback: types.CallbackQuery, session: AsyncSession):
    """
    Отображает главную панель администратора.
    Клавиатура динамически подстраивается под роль (admin или main_admin).
    """
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer:
        await callback.answer(Text.ERROR_PROFILE_NOT_FOUND, show_alert=True)
        return

    await callback.message.edit_text(
        text=Text.ADMIN_PANEL_HEADER,
        reply_markup=inline.get_admin_panel_keyboard(viewer.role),
        parse_mode="HTML"
    )
    await callback.answer()
    

@admin_router.callback_query(F.data == "admin_manage_events")
async def manage_events_panel_test(callback: types.CallbackQuery):

    await callback.message.edit_text(Text.ADMIN_EVENTS_HEADER, reply_markup=inline.get_events_management_keyboard(), parse_mode="HTML")
    await callback.answer()

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/keyboards/inline.py ---

from aiogram import types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from bot.db.models import MerchItem, InfoText
from aiogram.fsm.context import FSMContext

# --- КЛАВИАТУРЫ ---

def get_back_to_main_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_category_keyboard():
    """Клавиатура для выбора категории пользователя."""
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="Студент", callback_data="category_student"))
    builder.row(InlineKeyboardButton(text="Внешний донор", callback_data="category_external"))
    return builder.as_markup()

def get_consent_keyboard():
    """Клавиатура для подтверждения согласия на обработку ПДн."""
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="✅ Принимаю условия", callback_data="consent_given"))
    return builder.as_markup()


def get_student_main_menu(viewer_role: str = 'student'):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📅 Записаться на донацию", callback_data="register_donation"))
    builder.row(InlineKeyboardButton(text="👤 Мой профиль", callback_data="my_profile"))
    builder.row(InlineKeyboardButton(text="🎁 Магазин мерча", callback_data="merch_store"))
    builder.row(InlineKeyboardButton(text="ℹ️ Полезная информация", callback_data="info"))
    builder.row(InlineKeyboardButton(text="⚕️ Мои медотводы", callback_data="my_waivers"))
    builder.row(InlineKeyboardButton(text="❓ Задать вопрос организаторам", callback_data="ask_question"))
    
    if viewer_role == 'volunteer':
        builder.row(InlineKeyboardButton(
            text="⭐ Вернуться в меню волонтера",
            callback_data="volunteer_panel"
        ))
    elif viewer_role in ['admin', 'main_admin']:
        builder.row(InlineKeyboardButton(
            text="⭐ Перейти в режим волонтера",
            callback_data="switch_to_volunteer_view"
        ))
        builder.row(InlineKeyboardButton(
            text="⚙️ Вернуться в админ-панель",
            callback_data="admin_panel"
        ))
        
    return builder.as_markup()

def get_volunteer_main_menu(viewer_role: str = 'volunteer'):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="⭐ Меню волонтёра", callback_data="volunteer_panel"))
    builder.row(InlineKeyboardButton(text="👤 Перейти в режим донора", callback_data="switch_to_donor_view"))
    return builder.as_markup()

def get_admin_main_menu(viewer_role: str = 'admin'):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="⚙️ Панель администратора", callback_data="admin_panel"))
    return builder.as_markup()  

def get_main_admin_main_menu(viewer_role: str = 'main_admin'):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="⚙️ Открыть панель администратора", callback_data="admin_panel"))
    return builder.as_markup()

def get_university_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="НИЯУ МИФИ", callback_data="university_mifi"))
    return builder.as_markup()


def get_faculties_keyboard():
    faculties = ["ИИКС", "ФИБС", "ИнЯз", "ИФТЭБ", "БМТ", "ИФИБ"]
    builder = InlineKeyboardBuilder()
    for faculty in faculties:
        builder.row(InlineKeyboardButton(text=faculty, callback_data=f"faculty_{faculty}"))
    builder.row(InlineKeyboardButton(text="Другой/Не из списка", callback_data="faculty_Other"))
    return builder.as_markup()

def get_gender_inline_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="Мужской", callback_data="gender_male"),
        InlineKeyboardButton(text="Женский", callback_data="gender_female")
    )
    return builder.as_markup()

def get_profile_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📊 Мои данные", callback_data="profile_data"))
    builder.row(InlineKeyboardButton(text="🩸 История донаций", callback_data="profile_history"))
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_back_to_profile_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ Назад в профиль", callback_data="my_profile"))
    return builder.as_markup()

def get_info_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="Как подготовиться?", callback_data="info_prepare"))
    builder.row(InlineKeyboardButton(text="Противопоказания", callback_data="info_contraindications"))
    builder.row(InlineKeyboardButton(text="Что делать после?", callback_data="info_after"))
    builder.row(InlineKeyboardButton(text="🩸 О донорстве костного мозга (ДКМ)", callback_data="info_dkm"))
    builder.row(InlineKeyboardButton(text="🏥 О донациях в МИФИ", callback_data="info_mifi_process"))
    builder.row(InlineKeyboardButton(text="Связаться с организаторами", callback_data="info_contacts"))
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_back_to_info_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ Назад к разделам", callback_data="info"))
    return builder.as_markup()

def get_merch_store_keyboard(item: MerchItem, page: int, total_pages: int):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text=f'Купить за {item.price}Б', callback_data=f"buy_merch_{item.id}"))
    nav_buttons = []
    prev_page = total_pages if page == 1 else page - 1
    nav_buttons.append(InlineKeyboardButton(text="◀️", callback_data=f"merch_page_{prev_page}"))
    nav_buttons.append(InlineKeyboardButton(text=f"{page}/{total_pages}", callback_data="ignore"))
    next_page = 1 if page == total_pages else page + 1
    nav_buttons.append(InlineKeyboardButton(text="▶️", callback_data=f"merch_page_{next_page}"))
    builder.row(*nav_buttons)
    builder.row(InlineKeyboardButton(text="🛍️ Мои заказы", callback_data="my_orders"))
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_purchase_confirmation_keyboard(item_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="✅ Подтвердить", callback_data=f"confirm_buy_{item_id}"),
        InlineKeyboardButton(text="❌ Отмена", callback_data="merch_store")
    )
    return builder.as_markup()

def get_back_to_merch_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ Назад в магазин", callback_data="merch_store"))
    return builder.as_markup()
    
def get_admin_panel_keyboard(viewer_role: str):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="🗓️ Упр. мероприятиями", callback_data="admin_manage_events"))
    builder.row(types.InlineKeyboardButton(text="❓ Вопросы от пользователей", callback_data="admin_answer_questions"))
    builder.row(InlineKeyboardButton(text="👥 Упр. пользователями", callback_data="admin_manage_users"))
    builder.row(InlineKeyboardButton(text="🛍️ Упр. магазином", callback_data="admin_manage_merch"))
    builder.row(InlineKeyboardButton(text="📦 Обработка заказов", callback_data="admin_process_orders"))
    builder.row(InlineKeyboardButton(text="📣 Рассылки", callback_data="admin_mailing"))
    builder.row(InlineKeyboardButton(text="📊 Аналитика", callback_data="admin_analytics"))
    builder.row(InlineKeyboardButton(text="📝 Ред. инфо-разделы", callback_data="admin_edit_info"))
    if viewer_role == 'main_admin':
        builder.row(
        types.InlineKeyboardButton(text="💾 Экспорт данных", callback_data="ma_export_data"),
        types.InlineKeyboardButton(text="📥 Импорт данных", callback_data="ma_import_data")
        )
        builder.row(types.InlineKeyboardButton(text="📥 Импорт старой БД", callback_data="ma_import_old_db"))
    builder.row(InlineKeyboardButton(text="👤 Перейти в режим донора", callback_data="switch_to_donor_view"))
    return builder.as_markup()



def get_info_sections_for_editing_keyboard(sections: list[InfoText]):
    builder = InlineKeyboardBuilder()
    for section in sections:
        builder.row(types.InlineKeyboardButton(
            text=section.section_title,
            callback_data=f"edit_info_{section.section_key}"
        ))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    return builder.as_markup()

def get_analytics_main_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📈 Общая статистика (KPI)", callback_data="analytics_kpi"))
    builder.row(InlineKeyboardButton(text="📅 Анализ мероприятий", callback_data="analytics_events_select"))
    builder.row(InlineKeyboardButton(text="📄 Отчеты", callback_data="analytics_reports"))
    # Можно добавить еще кнопки для других разделов
    builder.row(InlineKeyboardButton(text="↩️ В админ-панель", callback_data="admin_panel"))
    return builder.as_markup()

def get_reports_menu_keyboard():
    builder = InlineKeyboardBuilder()
    # I. Отчеты по активности и лояльности доноров
    builder.row(InlineKeyboardButton(text="Доноры-однодневки", callback_data="report_churn_donors"))
    builder.row(InlineKeyboardButton(text="Угасающие доноры", callback_data="report_lapsed_donors"))
    builder.row(InlineKeyboardButton(text="Топ-20 доноров", callback_data="report_top_donors"))
    # builder.row(InlineKeyboardButton(text="Доноры редкой крови", callback_data="report_rare_blood_donors"))
    # II. Отчеты по сегментации и демографии
    builder.row(InlineKeyboardButton(text="Самые активные факультеты", callback_data="report_top_faculties"))
    builder.row(InlineKeyboardButton(text="Кандидаты в регистр ДКМ", callback_data="report_dkm_candidates"))
    # III. Отчеты по конверсии и эффективности
    builder.row(InlineKeyboardButton(text="Потеря после опросника", callback_data="report_survey_dropoff"))

    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="admin_analytics"))
    return builder.as_markup()

def get_events_for_analysis_keyboard(events: list):
    builder = InlineKeyboardBuilder()
    for event in events:
        builder.row(InlineKeyboardButton(
            text=f"{event.event_datetime.strftime('%d.%m.%y')} - {event.name}",
            callback_data=f"analyze_event_{event.id}"
        ))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="admin_analytics"))
    return builder.as_markup()

def get_events_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Создать мероприятие", callback_data="admin_create_event"))
    builder.row(InlineKeyboardButton(text="📜 Просмотр/Редактирование активных", callback_data="admin_view_events"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    return builder.as_markup()

def get_single_event_management_keyboard(event_id: int, registration_is_open: bool, has_feedback: bool = False):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="✏️ Редактировать", callback_data=f"admin_edit_event_{event_id}"))
    reg_status_text = "🔒 Закрыть регистрацию" if registration_is_open else "🔓 Открыть регистрацию"
    builder.row(InlineKeyboardButton(text=reg_status_text, callback_data=f"admin_toggle_reg_{event_id}"))
    builder.row(InlineKeyboardButton(text="👥 Список участников (.csv)", callback_data=f"admin_event_participants_{event_id}"))
    builder.row(InlineKeyboardButton(text="🚨 Отменить мероприятие", callback_data=f"admin_cancel_event_{event_id}"))
    if has_feedback:
        builder.row(InlineKeyboardButton(text="📊 Посмотреть отзывы", callback_data=f"admin_view_feedback_{event_id}"))
    builder.row(InlineKeyboardButton(text="↩️ К списку мероприятий", callback_data="admin_view_events"))
    return builder.as_markup()

def get_back_to_admin_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ В панель администратора", callback_data="admin_panel"))
    return builder.as_markup()

def get_user_management_keyboard(target_user_id: int, target_user_role: str, viewer_role: str, is_blocked: bool):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="🎟️ Упр. регистрациями", callback_data=f"admin_manage_user_regs_{target_user_id}"))
    builder.row(InlineKeyboardButton(text="⚕️ Упр. медотводами", callback_data=f"admin_manage_waivers_{target_user_id}"))

    builder.row(InlineKeyboardButton(text="+/- Баллы", callback_data=f"admin_points_{target_user_id}"))

    if target_user_role == 'student':
        builder.row(InlineKeyboardButton(text="⭐ Назначить волонтером", callback_data=f"admin_promote_volunteer_{target_user_id}"))
    elif target_user_role == 'volunteer':
        builder.row(InlineKeyboardButton(text="🧑‍🎓 Снять с должности волонтера", callback_data=f"admin_demote_volunteer_{target_user_id}"))
    
    if viewer_role == 'main_admin' and target_user_role != 'main_admin':
        if target_user_role == 'admin':
            builder.row(InlineKeyboardButton(text="👑➖ Разжаловать админа", callback_data=f"ma_demote_admin_{target_user_id}"))
        else:
            builder.row(InlineKeyboardButton(text="👑➕ Назначить админом", callback_data=f"ma_promote_admin_{target_user_id}"))
        if is_blocked:
            builder.row(InlineKeyboardButton(text="✅ Разблокировать", callback_data=f"ma_unblock_user_{target_user_id}"))
        else:
            builder.row(InlineKeyboardButton(text="🚫 Заблокировать", callback_data=f"ma_block_user_{target_user_id}"))
            
    builder.row(InlineKeyboardButton(text="↩️ Назад к управлению", callback_data="admin_manage_users"))
    return builder.as_markup()

def get_donation_type_keyboard():
    builder = InlineKeyboardBuilder()
    types = {'whole_blood': 'Цельная кровь', 'plasma': 'Плазма', 'platelets': 'Тромбоциты', 'erythrocytes': 'Эритроциты'}
    for key, value in types.items():
        builder.row(InlineKeyboardButton(text=value, callback_data=f"settype_{key}"))
    return builder.as_markup()


def get_blood_centers_keyboard(blood_centers, edit_mode=False):
    builder = InlineKeyboardBuilder()
    for center in blood_centers:
        builder.row(InlineKeyboardButton(text=center.name, callback_data=f"select_blood_center_{center.id}"))

    callback_data = "add_new_blood_center_edit" if edit_mode else "add_new_blood_center"
    builder.row(InlineKeyboardButton(text="➕ Добавить новый", callback_data=callback_data))
    return builder.as_markup()

def get_main_admin_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="👮‍♂️ Управление администраторами", callback_data="ma_manage_admins"))
    builder.row(InlineKeyboardButton(text="🚫 Управление блокировками", callback_data="ma_manage_blocks"))
    builder.row(InlineKeyboardButton(text="💾 Экспорт данных", callback_data="ma_export_data"))
    builder.row(InlineKeyboardButton(text="↩️ В панель администратора", callback_data="admin_panel"))
    return builder.as_markup()
    
def get_back_to_ma_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ В панель гл. администратора", callback_data="main_admin_panel"))
    return builder.as_markup()

def get_admins_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Назначить администратора", callback_data="add_admin"))
    builder.row(InlineKeyboardButton(text="➖ Разжаловать администратора", callback_data="remove_admin"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="main_admin_panel"))
    return builder.as_markup()

def get_blocks_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="🔒 Заблокировать пользователя", callback_data="block_user_start"))
    builder.row(InlineKeyboardButton(text="🔓 Разблокировать пользователя", callback_data="unblock_user_start"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="main_admin_panel"))
    return builder.as_markup()
    
def get_export_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="Выгрузить пользователей (.csv)", callback_data="export_users_csv"))
    builder.row(InlineKeyboardButton(text="Выгрузить донации (.csv)", callback_data="export_donations_csv"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="main_admin_panel"))
    return builder.as_markup()

def get_merch_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Добавить товар", callback_data="admin_create_merch"))
    builder.row(InlineKeyboardButton(text="📜 Просмотр/Редактирование", callback_data="admin_view_merch"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    return builder.as_markup()

def get_event_cancellation_confirmation_keyboard(event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="❌ Да, отменить", callback_data=f"admin_confirm_cancel_{event_id}"),
        InlineKeyboardButton(text="↩️ Нет, назад", callback_data=f"admin_show_event_{event_id}")
    )
    return builder.as_markup()

def get_back_to_events_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ К управлению мероприятиями", callback_data="admin_manage_events"))
    return builder.as_markup()

def get_single_merch_management_keyboard(item_id: int, is_available: bool):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="✏️ Редактировать", callback_data=f"admin_edit_merch_{item_id}"))
    availability_text = "✅ Сделать доступным" if not is_available else "❌ Сделать недоступным"
    builder.row(InlineKeyboardButton(text=availability_text, callback_data=f"admin_toggle_merch_{item_id}"))
    builder.row(InlineKeyboardButton(text="🗑️ Удалить товар", callback_data=f"admin_delete_merch_{item_id}"))
    builder.row(InlineKeyboardButton(text="↩️ К списку товаров", callback_data="admin_view_merch"))
    return builder.as_markup()

def get_merch_deletion_confirmation_keyboard(item_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="🗑️ Да, удалить", callback_data=f"admin_confirm_delete_merch_{item_id}"),
        InlineKeyboardButton(text="↩️ Нет, назад", callback_data=f"admin_show_merch_{item_id}")
    )
    return builder.as_markup()

def get_back_to_merch_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ К управлению магазином", callback_data="admin_manage_merch"))
    return builder.as_markup()

def get_already_registered_keyboard(event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(
        text="❌ Отменить мою регистрацию",
        callback_data=f"cancel_reg_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="↩️ К списку мероприятий",
        callback_data="register_donation"
    ))
    return builder.as_markup()

def get_event_creation_confirmation_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="✅ Создать и разослать", callback_data="confirm_create_event"))
    builder.row(InlineKeyboardButton(text="❌ Отмена", callback_data="admin_manage_events"))
    return builder.as_markup()

def get_mailing_audience_keyboard(current_filters: dict = None):
    """
    Создает клавиатуру для выбора аудитории рассылки.
    Динамически отображает уже выбранные фильтры и кнопки.
    """
    if current_filters is None:
        current_filters = {}

    builder = InlineKeyboardBuilder()


    builder.row(InlineKeyboardButton(text="📢 Всем пользователям", callback_data="mail_filter_role_all"))
    builder.row(InlineKeyboardButton(text="⭐ Волонтерам и админам", callback_data="mail_filter_role_volunteers"))
    builder.row(InlineKeyboardButton(text="⚙️ Только администраторам", callback_data="mail_filter_role_admins"))
    # builder.row(InlineKeyboardButton(text="-"*25, callback_data="ignore")) 

    # builder.row(InlineKeyboardButton(text="🎓 По ВУЗу", callback_data="mail_audience_type_university"))
    builder.row(InlineKeyboardButton(text="🏛️ По факультету", callback_data="mail_audience_type_faculty"))
    
    if current_filters:
        builder.row(InlineKeyboardButton(text="✅ Готово (перейти к подтверждению)", callback_data="mail_audience_finish"))

    # Кнопка "Сбросить фильтры"
    if current_filters:
        builder.row(InlineKeyboardButton(text="🔄 Сбросить все фильтры", callback_data="mail_audience_reset"))

    builder.row(InlineKeyboardButton(text="❌ Отмена рассылки", callback_data="admin_panel"))
    
    return builder.as_markup()



def get_dynamic_mailing_filter_keyboard(items: list[str], filter_key: str, back_callback: str):
    """
    Создает клавиатуру для выбора значения фильтра.
    :param items: Список значений для кнопок (напр., список ВУЗов).
    :param filter_key: Ключ фильтра (напр., 'university').
    :param back_callback: callback_data для кнопки "Назад".
    """
    builder = InlineKeyboardBuilder()
    for item in items:
        builder.row(InlineKeyboardButton(text=item, callback_data=f"mail_filter_{filter_key}_{item}"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data=back_callback))
    return builder.as_markup()

def get_mailing_confirmation_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="🚀 Да, запустить рассылку", callback_data="confirm_mailing"),
        InlineKeyboardButton(text="✏️ Изменить текст", callback_data="edit_mailing_text"),
        InlineKeyboardButton(text="❌ Отмена", callback_data="admin_panel")
    )
    return builder.as_markup()

def get_skip_media_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➡️ Пропустить", callback_data="skip_media"))
    builder.row(InlineKeyboardButton(text="❌ Отмена", callback_data="admin_panel"))
    return builder.as_markup()

def get_user_management_main_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📜 Список всех пользователей", callback_data="admin_users_list_page_1"))
    builder.row(InlineKeyboardButton(text="🔍 Найти пользователя", callback_data="admin_search_user"))
    builder.row(InlineKeyboardButton(text="➕ Добавить пользователя вручную", callback_data="admin_add_user_start"))
    builder.row(InlineKeyboardButton(text="↩️ Назад в админ-панель", callback_data="admin_panel"))
    return builder.as_markup()

def get_users_list_pagination_keyboard(page: int, total_pages: int):
    builder = InlineKeyboardBuilder()
    nav_buttons = []
    if page > 1:
        nav_buttons.append(InlineKeyboardButton(text="◀️", callback_data=f"admin_users_list_page_{page - 1}"))
    nav_buttons.append(InlineKeyboardButton(text=f"{page}/{total_pages}", callback_data="ignore"))
    if page < total_pages:
        nav_buttons.append(InlineKeyboardButton(text="▶️", callback_data=f"admin_users_list_page_{page + 1}"))
    builder.row(*nav_buttons)
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_users"))
    return builder.as_markup()

def get_successful_registration_keyboard(event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(
        text="🔲 Мой QR-код для этого мероприятия",
        callback_data=f"get_event_qr_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="🗓️ Добавить в календарь",
        callback_data=f"add_to_calendar_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="❌ Отменить мою регистрацию",
        callback_data=f"cancel_reg_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="↩️ К списку мероприятий",
        callback_data="register_donation"
    ))
    return builder.as_markup()

def get_donation_confirmation_keyboard(user_id: int, event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(
            text="✅ Подтвердить",
            callback_data=f"confirm_donation_{user_id}_{event_id}"
        ),
        InlineKeyboardButton(
            text="❌ Отмена",
            callback_data="volunteer_panel"
        )
    )
    return builder.as_markup()

def get_volunteer_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📷 Подтвердить донацию (QR)", callback_data="confirm_donation_qr"))
    builder.row(InlineKeyboardButton(text="↩️ Назад в меню донора", callback_data="switch_to_donor_view"))
    return builder.as_markup()

def get_manual_registration_management_keyboard(user_id: int):
    """Клавиатура для выбора: записать или отменить запись."""
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Записать на мероприятие", callback_data=f"admin_reg_start_{user_id}"))
    builder.row(InlineKeyboardButton(text="➖ Отменить регистрацию", callback_data=f"admin_cancel_start_{user_id}"))
    builder.row(InlineKeyboardButton(text="↩️ Назад к пользователю", callback_data=f"admin_show_user_{user_id}"))
    return builder.as_markup()

def get_events_for_manual_registration_keyboard(user_id: int, events: list):
    """Клавиатура со списком мероприятий для ручной записи."""
    builder = InlineKeyboardBuilder()
    for event in events:
        builder.row(InlineKeyboardButton(
            text=f"{event.event_date.strftime('%d.%m')} - {event.name}",
            callback_data=f"adminReg_{user_id}_{event.id}" 
        ))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data=f"admin_manage_user_regs_{user_id}"))
    return builder.as_markup()

def get_registrations_for_cancellation_keyboard(user_id: int, registrations: list):
    """Клавиатура со списком регистраций для отмены."""
    builder = InlineKeyboardBuilder()
    for reg in registrations:
        builder.row(InlineKeyboardButton(
            text=f"❌ {reg.event.event_date.strftime('%d.%m')} - {reg.event.name}",
            callback_data=f"adminCancel_{user_id}_{reg.event_id}"
        ))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data=f"admin_manage_user_regs_{user_id}"))
    return builder.as_markup()



def get_my_waivers_keyboard(user_waivers_exist: bool):
    """
    Клавиатура для меню 'Мои медотводы'.
    Показывает кнопку удаления, только если у пользователя есть созданные им отводы.
    """
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Установить временный отвод", callback_data="set_user_waiver"))
    if user_waivers_exist:
        builder.row(InlineKeyboardButton(text="➖ Отменить свой отвод", callback_data="cancel_user_waiver"))
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_waiver_cancellation_keyboard(waivers: list):
    """Клавиатура со списком медотводов, созданных пользователем, для отмены."""
    builder = InlineKeyboardBuilder()
    for waiver in waivers:
        builder.row(InlineKeyboardButton(
            text=f"❌ До {waiver.end_date.strftime('%d.%m.%y')}: {waiver.reason[:25]}...",
            callback_data=f"delete_waiver_{waiver.id}"
        ))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="my_waivers"))
    return builder.as_markup()

def get_admin_waiver_management_keyboard(user_id: int, waivers: list):
    """Клавиатура для админа со списком медотводов пользователя для удаления."""
    builder = InlineKeyboardBuilder()
    for waiver in waivers:
        creator_map = {'user': '👤', 'system': '⚙️', 'admin': '👑'}
        creator_icon = creator_map.get(str(waiver.created_by).lower(), '❓')
        
        if str(waiver.created_by).isdigit():
            creator_icon = '👑'

        reason_short = (waiver.reason[:20] + '...') if len(waiver.reason) > 20 else waiver.reason
        
        builder.row(InlineKeyboardButton(
            text=f"❌ {creator_icon} До {waiver.end_date.strftime('%d.%m')} - {reason_short}",
            callback_data=f"admin_del_waiver_{waiver.id}_{user_id}"
        ))
        
    builder.row(InlineKeyboardButton(text="➕ Установить новый медотвод", callback_data=f"admin_waiver_{user_id}"))
    builder.row(InlineKeyboardButton(text="↩️ Назад к пользователю", callback_data=f"admin_show_user_{user_id}"))
    return builder.as_markup()

def get_feedback_well_being_keyboard():
    builder = InlineKeyboardBuilder()
    buttons = [InlineKeyboardButton(text=str(i), callback_data=f"fb_wb_{i}") for i in range(1, 6)]
    builder.row(*buttons)
    return builder.as_markup()

def get_feedback_organization_keyboard():
    builder = InlineKeyboardBuilder()
    # Две строки по 5 кнопок
    builder.row(*[InlineKeyboardButton(text=str(i), callback_data=f"fb_org_{i}") for i in range(1, 6)])
    builder.row(*[InlineKeyboardButton(text=str(i), callback_data=f"fb_org_{i}") for i in range(6, 11)])
    return builder.as_markup()

def get_feedback_skip_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➡️ Пропустить", callback_data="fb_skip_step"))
    return builder.as_markup()



def get_events_for_post_processing_keyboard(events: list):
    """Клавиатура для выбора прошедшего мероприятия для обработки."""
    builder = InlineKeyboardBuilder()
    for event in events:
        builder.row(types.InlineKeyboardButton(
            text=f"{event.event_datetime.strftime('%d.%m.%y')} - {event.name}",
            callback_data=f"post_process_event_{event.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_events"))
    return builder.as_markup()

def get_participant_marking_keyboard(event_id: int, participants: list, marked_donations: set, marked_dkm: set):
    """Динамическая клавиатура для отметки участников."""
    builder = InlineKeyboardBuilder()
    for reg in participants:
        user = reg.user
        
        donation_icon = "🟢" if user.id in marked_donations else "⚪️"
        dkm_icon = "🟢" if user.id in marked_dkm else "⚪️"

        builder.row(
            types.InlineKeyboardButton(text=user.full_name, callback_data="ignore"),
            types.InlineKeyboardButton(
                text=f"{donation_icon} Сдал кровь", 
                callback_data=f"mark_participant_{event_id}_{user.id}_donation"
            ),
            types.InlineKeyboardButton(
                text=f"{dkm_icon} Вступил в ДКМ", 
                callback_data=f"mark_participant_{event_id}_{user.id}_dkm"
            )
        )
    builder.row(types.InlineKeyboardButton(text="✅ Сохранить изменения и завершить", callback_data=f"finish_marking_{event_id}"))
    builder.row(types.InlineKeyboardButton(text="❌ Отмена", callback_data="admin_manage_events"))
    return builder.as_markup()

--- КОНЕЦ ФАЙЛА: bot/keyboards/inline.py ---

--- НАЧАЛО ФАЙЛА: bot/keyboards/reply.py ---

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

def get_contact_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="Поделиться контактом", request_contact=True)]],
        resize_keyboard=True
    )


def get_home_keyboard():
    """Возвращает клавиатуру с кнопкой 'Домой'."""
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="🏠 Домой")]
        ],
        resize_keyboard=True
    )


--- КОНЕЦ ФАЙЛА: bot/keyboards/reply.py ---

--- НАЧАЛО ФАЙЛА: bot/keyboards/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/keyboards/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/middlewares/block.py ---

from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, Message, CallbackQuery
from sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession

from bot.db import user_requests

class BlockUserMiddleware(BaseMiddleware):
    def __init__(self):
        super().__init__()

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        if not isinstance(event, (Message, CallbackQuery)):
            return await handler(event, data)

        session: AsyncSession = data.get("session")
        if not session:
            return await handler(event, data)

        user = await user_requests.get_user_by_tg_id(session, event.from_user.id)

        if user and user.is_blocked:
            if isinstance(event, Message):
                await event.answer("❌ Вы заблокированы и не можете использовать этого бота.")
            elif isinstance(event, CallbackQuery):
                await event.answer("❌ Вы заблокированы.", show_alert=True)
            return  # Прерываем дальнейшую обработку

        return await handler(event, data)

--- КОНЕЦ ФАЙЛА: bot/middlewares/block.py ---

--- НАЧАЛО ФАЙЛА: bot/middlewares/db.py ---

from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from sqlalchemy.ext.asyncio import async_sessionmaker

class DbSessionMiddleware(BaseMiddleware):
    def __init__(self, session_pool: async_sessionmaker):
        super().__init__()
        self.session_pool = session_pool

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        async with self.session_pool() as session:
            data["session"] = session
            return await handler(event, data)

--- КОНЕЦ ФАЙЛА: bot/middlewares/db.py ---

--- НАЧАЛО ФАЙЛА: bot/middlewares/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/middlewares/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/states/states.py ---

from aiogram.fsm.state import State, StatesGroup

class Registration(StatesGroup):
    awaiting_full_name = State()
    awaiting_category = State()
    awaiting_consent = State()
    awaiting_university = State()
    awaiting_custom_university_name = State()
    awaiting_faculty = State()
    awaiting_custom_faculty_name = State()
    awaiting_study_group = State()
    awaiting_gender = State()

class EventCreation(StatesGroup):
    awaiting_name = State()
    awaiting_datetime = State()
    awaiting_location_text = State()
    awaiting_location_point = State()
    awaiting_blood_center = State()
    awaiting_new_blood_center_name = State()
    awaiting_donation_type = State()
    awaiting_points = State()
    awaiting_limit = State()
    awaiting_confirmation = State()

class MerchCreation(StatesGroup):
    awaiting_photo = State()
    awaiting_name = State()
    awaiting_description = State()
    awaiting_price = State()

class PointsChange(StatesGroup):
    awaiting_user_id = State()
    awaiting_points_amount = State()
    awaiting_reason = State()

class ManualWaiver(StatesGroup):
    awaiting_end_date = State()
    awaiting_reason = State()

class Mailing(StatesGroup):
    awaiting_message_text = State()
    awaiting_media = State()
    awaiting_audience_type = State()     
    awaiting_audience_value = State()   
    awaiting_audience_choice = State()   
    awaiting_confirmation = State()
class AdminManagement(StatesGroup):
    awaiting_user_to_promote = State()
    awaiting_user_to_demote = State()
    
class BlockUser(StatesGroup):
    awaiting_user_id = State()
    awaiting_reason = State()
    awaiting_user_id_unblock = State()

class VolunteerActions(StatesGroup):
    awaiting_qr_photo = State()
    awaiting_confirmation = State()
    
class EventEditing(StatesGroup):
    choosing_field = State() 
    awaiting_new_value = State()
    awaiting_new_blood_center_name_for_edit = State()
    
class MerchEditing(StatesGroup):
    choosing_field = State()
    awaiting_new_value = State()
    
class UserSearch(StatesGroup):
    awaiting_query = State()
    
class UserWaiver(StatesGroup):
    awaiting_end_date = State()
    awaiting_reason = State()
    
    
class FeedbackSurvey(StatesGroup):
    awaiting_well_being = State()
    awaiting_well_being_comment = State()
    awaiting_organization_score = State()
    awaiting_what_liked = State()
    awaiting_what_disliked = State()
    awaiting_other_suggestions = State()
    
class AdminAnalytics(StatesGroup):
    choosing_event_for_analysis = State()
    
class AdminAddUser(StatesGroup):
    awaiting_phone = State()
    awaiting_full_name = State()
    awaiting_category = State()
    awaiting_consent = State()
    awaiting_university = State()
    awaiting_custom_university_name = State()
    awaiting_faculty = State()
    awaiting_custom_faculty_name = State()
    awaiting_study_group = State()
    awaiting_gender = State()
    
class PostEventProcessing(StatesGroup):
    choosing_event = State()
    marking_participants = State()
    
class EditInfoSection(StatesGroup):
    choosing_section = State()
    awaiting_new_text = State()
    
class AskQuestion(StatesGroup):
    awaiting_question = State()

class AnswerQuestion(StatesGroup):
    awaiting_answer = State()
    
class DataImport(StatesGroup):
    awaiting_file = State()
    awaiting_old_db_file = State()

--- КОНЕЦ ФАЙЛА: bot/states/states.py ---

--- НАЧАЛО ФАЙЛА: bot/states/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/states/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/analytics_service.py ---

import io
import matplotlib.pyplot as plt
import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db import analytics_requests

async def create_report(session: AsyncSession, report_type: str) -> dict:
    """
    Создает отчет на основе указанного типа.
    """
    report_data = {}
    if report_type == "one_time_donors":
        report_data = await analytics_requests.get_one_time_donors(session)
    elif report_type == "no_show_donors":
        report_data = await analytics_requests.get_no_show_donors(session)
    elif report_type == "dkm_donors":
        report_data = await analytics_requests.get_dkm_donors(session)
    elif report_type == "students":
        report_data = await analytics_requests.get_students(session)
    elif report_type == "employees":
        report_data = await analytics_requests.get_employees(session)
    elif report_type == "external_donors":
        report_data = await analytics_requests.get_external_donors(session)
    elif report_type == "graduated_donors":
        report_data = await analytics_requests.get_graduated_donors(session)
    elif report_type == "churn_donors":
        report_data = await analytics_requests.get_churn_donors(session)
    elif report_type == "lapsed_donors":
        report_data = await analytics_requests.get_lapsed_donors(session)
    elif report_type == "top_donors":
        report_data = await analytics_requests.get_top_donors(session)
    elif report_type == "rare_blood_donors":
        report_data = await analytics_requests.get_rare_blood_donors(session)
    elif report_type == "top_faculties":
        report_data = await analytics_requests.get_top_faculties(session)
    elif report_type == "dkm_candidates":
        report_data = await analytics_requests.get_dkm_candidates(session)
    elif report_type == "survey_dropoff":
        report_data = await analytics_requests.get_survey_dropoff(session)
    return report_data

def plot_donations_by_month(data: list[tuple]) -> io.BytesIO:
    """
    Создает график в виде столбчатой диаграммы по данным о донациях.
    :param data: Список кортежей (datetime.date, int), где date - первый день месяца.
    :return: BytesIO объект с изображением PNG.
    """
    if not data:
        return None

    # plt.style.use('ggplot') # Можете выбрать стиль по вкусу
    fig, ax = plt.subplots(figsize=(10, 6))

    months = [item[0].strftime("%b %Y") for item in data]
    counts = [item[1] for item in data]

    ax.bar(months, counts, color='#E53935') # Фирменный красный цвет

    ax.set_title('Динамика донаций по месяцам', fontsize=16, pad=20)
    ax.set_ylabel('Количество донаций')
    ax.tick_params(axis='x', rotation=45)
    
    # Добавляем цифры над столбцами
    for i, v in enumerate(counts):
        ax.text(i, v + 0.5, str(v), ha='center', fontweight='bold')

    plt.tight_layout()

    # Сохраняем график в буфер в памяти
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    plt.close(fig) # Закрываем фигуру, чтобы освободить память

    return buf

--- КОНЕЦ ФАЙЛА: bot/utils/analytics_service.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/calendar_service.py ---

import datetime
import pytz
from ics import Calendar, Event as IcsEvent
from ics.alarm import DisplayAlarm
from bot.db.models import Event as DbEvent
from bot.utils.text_messages import Text

def generate_ics_file(event: DbEvent) -> str:
    """
    Генерирует содержимое .ics файла для указанного мероприятия,
    оптимизированное для лучшей совместимости, в т.ч. с Google Calendar.

    :param event: Объект мероприятия из базы данных.
    :return: Строка с содержимым .ics файла.
    """
    cal = Calendar()
    e = IcsEvent()

    timezone = pytz.timezone("Europe/Moscow")

    if event.event_datetime.tzinfo is None:
        start_time = timezone.localize(event.event_datetime)
    else:
        start_time = event.event_datetime.astimezone(timezone)

    end_time = start_time + datetime.timedelta(hours=2)

    e.name = f"Донация: {event.name}"
    e.begin = start_time
    e.end = end_time
    donation_type_ru = Text.DONATION_TYPE_RU.get(event.donation_type, event.donation_type)
    e.description = (
        f"Тип донации: {donation_type_ru}.\n" # <-- ИЗМЕНЕНО
        f"Не забудьте взять с собой паспорт и хорошо себя чувствовать. "
        f"Спасибо за вашу помощь!"
    )
    e.location = event.location
    e.created = datetime.datetime.now(tz=timezone)
    
    e.uid = f"{datetime.datetime.now().strftime('%Y%m%dT%H%M%S')}-{event.id}@donor.mifi.ru"
    

    alarm = DisplayAlarm(trigger=datetime.timedelta(hours=-1))
    
    e.alarms.append(alarm)
    
    cal.events.add(e)
    
    return cal.serialize()

--- КОНЕЦ ФАЙЛА: bot/utils/calendar_service.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/data_import.py ---

import openpyxl
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db.models import User, Donation
from bot.db import user_requests
import datetime
import pandas as pd
import re


def format_full_name(full_name: str) -> str:
    """
    Formats a full name by capitalizing the first letter of each word and removing extra spaces.
    """
    if not isinstance(full_name, str):
        return full_name

    full_name = re.sub(r'\s+', ' ', full_name).strip()
    return ' '.join(word.capitalize() for word in full_name.split())


async def import_data_from_file(session: AsyncSession, file_bytes: bytes) -> tuple[int, int]:
    """
    Imports data from an .xlsx file with the old format into the database.
    Returns a tuple of (created_count, updated_count).
    """
    df = pd.read_excel(file_bytes)

    column_mapping = {
        'ФИО': 'full_name',
        'Телефон': 'phone_number',
        'Группа': 'study_group',
        'Кол-во Гаврилова': 'donations_gavrilov',
        'Кол-во ФМБА': 'donations_fmba',
    }

    df = df.rename(columns=column_mapping)

    required_cols = ['full_name', 'phone_number']
    if not all(col in df.columns for col in required_cols):
        raise ValueError(f"Ошибка: в файле отсутствуют обязательные колонки ({', '.join(required_cols)}).")

    created_count = 0
    updated_count = 0

    for index, row in df.iterrows():
        phone = str(row['phone_number'])
        if not phone.startswith('+'):
            phone = '+' + phone
        user = await user_requests.get_user_by_phone(session, phone)

        study_group = row.get('study_group')
        university = "НИЯУ МИФИ" if 'сотрудник' in str(study_group).lower() or (study_group and study_group != '-') else "Внешний донор"
        faculty = "Сотрудник" if 'сотрудник' in str(study_group).lower() else None

        user_data = {
            'full_name': format_full_name(row.get('full_name')),
            'university': university,
            'faculty': faculty,
            'study_group': study_group if university == "НИЯУ МИФИ" and faculty != "Сотрудник" else None,
            'role': 'student',
        }
        user_data = {k: v for k, v in user_data.items() if pd.notna(v)}

        if user:
            await user_requests.update_user_profile(session, user.id, user_data)
            updated_count += 1
        else:
            full_data = user_data.copy()
            full_data['phone_number'] = phone
            full_data['telegram_id'] = -index  # Use negative index for unique tg_id
            full_data['telegram_username'] = f"import_{phone}"
            user = await user_requests.add_user(session, full_data)
            await session.flush()  # Flush to get the user ID
            created_count += 1

        donations_gavrilov = row.get('donations_gavrilov', 0)
        donations_fmba = row.get('donations_fmba', 0)
        total_donations = (donations_gavrilov if pd.notna(donations_gavrilov) else 0) + \
                          (donations_fmba if pd.notna(donations_fmba) else 0)

        if total_donations > 0:
            for _ in range(int(total_donations)):
                donation = Donation(
                    user_id=user.id,
                    donation_date=datetime.date(2023, 1, 1),
                    donation_type='whole_blood',
                    points_awarded=0,
                    event_id=None
                )
                session.add(donation)

    await session.commit()
    return created_count, updated_count


--- КОНЕЦ ФАЙЛА: bot/utils/data_import.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/graduation.py ---

import datetime
from bot.db import user_requests

def calculate_graduation_year(group: str) -> int | None:
    """
    Calculates the graduation year based on the group name.
    Returns None if the group format is not recognized.
    """
    if not group or not isinstance(group, str):
        return None

    group_upper = group.upper()

    try:
        if group_upper.startswith('Б') or group_upper.startswith('B'):
            # Бакалавриат - 4 года
            year_prefix = int(group_upper[1:3])
            return 2000 + year_prefix + 4
        elif group_upper.startswith('С') or group_upper.startswith('C'):
            # Специалитет - 5 лет
            year_prefix = int(group_upper[1:3])
            return 2000 + year_prefix + 5
        elif group_upper.startswith('М') or group_upper.startswith('M'):
            # Магистратура - 2 года
            year_prefix = int(group_upper[1:3])
            return 2000 + year_prefix + 2
    except (ValueError, IndexError):
        return None

    return None

async def check_graduation_status(bot, session):
    """
    Checks the graduation status of all users and sends a notification
    to those who have graduated.
    """
    today = datetime.date.today()
    if today.month == 9:
        users = await user_requests.get_all_users(session)
        for user in users:
            if user.graduation_year and user.graduation_year <= today.year:
                await bot.send_message(
                    user.telegram_id,
                    "Здравствуйте! По нашим данным, вы уже выпустились. "
                    "Пожалуйста, обновите свои данные, чтобы продолжать "
                    "пользоваться ботом."
                )


--- КОНЕЦ ФАЙЛА: bot/utils/graduation.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/qr_service.py ---

import io
import hashlib
import qrcode
import json
import logging
from PIL import Image
from pyzbar.pyzbar import decode, ZBarSymbol

from bot.config_reader import config

logger = logging.getLogger(__name__)

def create_secure_payload(data: dict) -> str:
    # Формирует строку для QR-кода
    json_string = json.dumps(data, sort_keys=True, separators=(',', ':'))
    salt = config.qr_secret_key.get_secret_value()
    string_to_hash = json_string + salt
    # logger.info(f"[CREATE] String to be hashed: '{string_to_hash}'")
    h = hashlib.sha256(string_to_hash.encode()).hexdigest()
    # logger.info(f"[CREATE] Generated hash: {h}")
    return f"{json_string}|{h}"

def verify_secure_payload(payload: str) -> dict | None:
    # Проверяет строку и возвращает данные
    try:
        json_string, received_hash = payload.split('|', 1)
        salt = config.qr_secret_key.get_secret_value()
        string_to_hash = json_string + salt
        # logger.info(f"[VERIFY] String to be hashed: '{string_to_hash}'")
        expected_hash = hashlib.sha256(string_to_hash.encode()).hexdigest()
        # logger.info(f"[VERIFY] Received hash:  {received_hash}")
        # logger.info(f"[VERIFY] Expected hash:  {expected_hash}")
        if received_hash == expected_hash:
            # logger.info("[VERIFY] Hashes MATCH. Verification successful.")
            return json.loads(json_string)
        else:
            # logger.error("[VERIFY] Hashes DO NOT MATCH. Verification failed.")
            return None
    except (ValueError, IndexError, json.JSONDecodeError) as e:
        # logger.error(f"[VERIFY] An exception occurred during verification: {e}")
        return None

async def generate_qr(data: dict) -> bytes:
    # Генерирует QR-код
    # logger.info(f"--- Generating QR for data: {data} ---")
    payload = create_secure_payload(data)
    img = qrcode.make(payload)
    buf = io.BytesIO()
    img.save(buf, 'PNG')
    buf.seek(0)
    return buf.read()

async def read_qr(photo_bytes: bytes) -> dict | None:
    # Читает QR-код и возвращает данные
    try:
        image = Image.open(io.BytesIO(photo_bytes)).convert('L')
        decoded_objects = decode(image, symbols=[ZBarSymbol.QRCODE])
        if not decoded_objects:
            # logger.warning("pyzbar failed to find any QR codes on the image.")
            return None
        payload = decoded_objects[0].data.decode('utf-8')
        # logger.info(f"--- Verifying QR with payload: '{payload}' ---")
        verified_data = verify_secure_payload(payload)
        return verified_data
    except Exception as e:
        # logger.error(f"An exception occurred in read_qr: {e}", exc_info=True)
        return None


--- КОНЕЦ ФАЙЛА: bot/utils/qr_service.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/scheduler.py ---

import logging
import datetime
from aiogram import Bot
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy import select, and_
from sqlalchemy.orm import joinedload
from bot.db.models import EventRegistration, MedicalWaiver, Event, User, Donation, NoShowReport
from bot.utils.text_messages import Text
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.base import StorageKey
from bot.states.states import FeedbackSurvey
from bot.keyboards import inline
from bot.utils.graduation import check_graduation_status


logger = logging.getLogger(__name__)

async def send_reminders_for_interval(
    bot: Bot, 
    session_pool: async_sessionmaker, 
    time_from_now: datetime.timedelta, 
    time_window: datetime.timedelta,
    text_template: str
):
    now = datetime.datetime.now()
    start_time = now + time_from_now
    end_time = start_time + time_window

    logger.info(f"Running reminder job. Checking for events between {start_time.strftime('%Y-%m-%d %H:%M')} and {end_time.strftime('%Y-%m-%d %H:%M')}")
    
    async with session_pool() as session:
        stmt = (
            select(EventRegistration)
            .join(Event, EventRegistration.event_id == Event.id)
            .where(
                and_(
                    Event.event_datetime >= start_time,
                    Event.event_datetime < end_time,
                    EventRegistration.status == 'registered',
                    Event.is_active == True
                )
            )
            .options(
                joinedload(EventRegistration.user),
                joinedload(EventRegistration.event)
            )
        )
        
        results = await session.execute(stmt)
        registrations = results.scalars().unique().all()
        
        if not registrations:
            logger.info("No registrations found for this time window.")
            return
            
        logger.info(f"Found {len(registrations)} registrations to notify.")
        success_count = 0
        for reg in registrations:
            try:
                user = reg.user
                event = reg.event
                
                if not user or not event:
                    continue

                formatted_datetime = event.event_datetime.strftime('%d.%m.%Y %H:%M')
                
                safe_event_name = Text.escape_html(event.name)
                safe_datetime = Text.escape_html(formatted_datetime)
                location_link = Text.format_location_link(event.location, event.latitude, event.longitude)
                
                text = text_template.format(
                    event_name=safe_event_name,
                    event_datetime=safe_datetime,
                    event_location=location_link
                )

                await bot.send_message(chat_id=user.telegram_id, text=text, parse_mode="HTML")
                success_count += 1
            except Exception as e:
                logger.error(f"Failed to send reminder to user {reg.user_id} for event {reg.event_id}. Error: {e}", exc_info=True)
        
        logger.info(f"Job finished. Sent {success_count}/{len(registrations)} reminders.")

async def send_post_donation_feedback(bot: Bot, session_pool: async_sessionmaker, storage: MemoryStorage):
    """Инициирует опрос обратной связи через день после донации."""
    yesterday = datetime.date.today() - datetime.timedelta(days=1)
    logger.info(f"Running post-donation feedback job for donations made on {yesterday}.")

    async with session_pool() as session:
        stmt = (
            select(Donation)
            .options(joinedload(Donation.user))
            .where(
                Donation.donation_date == yesterday,
                Donation.feedback_requested == False
            )
        )
        results = await session.execute(stmt)
        donations_to_process = results.scalars().all()

        if not donations_to_process:
            logger.info("No donations found for feedback request.")
            return

        logger.info(f"Found {len(donations_to_process)} donations for feedback request.")
        success_count = 0
        for donation in donations_to_process:
            try:
                user = donation.user
                if not user:
                    continue
                
                storage_key = StorageKey(bot_id=bot.id, chat_id=user.telegram_id, user_id=user.telegram_id)
                state = FSMContext(storage=storage, key=storage_key)               
                
                await state.set_state(FeedbackSurvey.awaiting_well_being)
                await state.update_data(
                    event_id=donation.event_id,
                    donation_id=donation.id
                )
                
                await bot.send_message(
                    chat_id=user.telegram_id,
                    text=Text.FEEDBACK_START,
                    reply_markup=inline.get_feedback_well_being_keyboard()
                )
                
                donation.feedback_requested = True
                success_count += 1
            except Exception as e:
                logger.error(f"Failed to initiate feedback survey for user {donation.user_id}. Error: {e}", exc_info=True)
        
        if success_count > 0:
            await session.commit()
        
        logger.info(f"Post-donation feedback job finished. Initiated {success_count}/{len(donations_to_process)} surveys.")


async def check_waiver_expirations(bot: Bot, session_pool: async_sessionmaker):
    yesterday = datetime.date.today() - datetime.timedelta(days=1)
    async with session_pool() as session:
        stmt = (
            select(MedicalWaiver.user_id)
            .where(MedicalWaiver.end_date == yesterday)
        )
        results = await session.execute(stmt)
        user_ids_to_notify = results.scalars().unique().all()
        if not user_ids_to_notify:
            return
        users_stmt = select(User).where(User.id.in_(user_ids_to_notify))
        users_result = await session.execute(users_stmt)
        users = users_result.scalars().all()
        for user in users:
            try:
                await bot.send_message(chat_id=user.telegram_id, text=Text.WAIVER_EXPIRED_NOTIFICATION)
            except Exception as e:
                logger.error(f"Failed to send waiver expiration notification to user {user.id}. Error: {e}")


async def check_student_status(bot: Bot, session_pool: async_sessionmaker):
    """Проверяет, не выпустился ли студент."""
    async with session_pool() as session:
        stmt = select(User).where(User.category == "student")
        results = await session.execute(stmt)
        students = results.scalars().all()

        for student in students:
            try:
                if student.study_group:
                    # Very simplified logic. A real implementation would be more complex.
                    study_group_year = int(student.study_group.split("-")[1][:2])
                    current_year = datetime.datetime.now().year % 100
                    if current_year - study_group_year > 4:
                        await bot.send_message(
                            chat_id=student.telegram_id,
                            text="Привет! Похоже, ты уже выпустился из университета. Пожалуйста, обнови свои данные."
                        )
            except Exception as e:
                logger.error(f"Failed to check student status for user {student.id}. Error: {e}", exc_info=True)

def setup_scheduler(bot: Bot, session_pool: async_sessionmaker, storage: MemoryStorage) -> AsyncIOScheduler:
    scheduler = AsyncIOScheduler(timezone="Europe/Moscow")

    scheduler.add_job(
        send_no_show_surveys,
        trigger='cron',
        hour='*',
        minute=5, 
        args=[bot, session_pool]
    )

    scheduler.add_job(
        send_reminders_for_interval,
        trigger='cron',
        hour=10,
        minute=0,
        args=[bot, session_pool, datetime.timedelta(days=7), datetime.timedelta(days=1), Text.REMINDER_WEEK]
    )
    scheduler.add_job(
        send_reminders_for_interval,
        trigger='cron',
        hour=10,
        minute=30,
        args=[bot, session_pool, datetime.timedelta(days=3), datetime.timedelta(days=1), Text.REMINDER_3_DAYS]
    )
    scheduler.add_job(
        send_reminders_for_interval,
        trigger='cron',
        hour=10,
        minute=30,
        args=[bot, session_pool, datetime.timedelta(days=1), datetime.timedelta(days=1), Text.REMINDER_1_DAY]
    )
    scheduler.add_job(
        send_reminders_for_interval,
        trigger='cron',
        hour='*',
        minute=0,
        args=[bot, session_pool, datetime.timedelta(hours=2), datetime.timedelta(hours=1), Text.REMINDER_2_HOURS]
    )
    scheduler.add_job(
        check_waiver_expirations,
        trigger='cron',
        hour=9,
        minute=0,
        args=[bot, session_pool]
    )
    
    scheduler.add_job(
        send_post_donation_feedback,
        trigger='cron',
        hour=11,
        minute=0,
        args=[bot, session_pool, storage]
    )
    
    scheduler.add_job(
        check_student_status,
        trigger='cron',
        month=9,
        day=1,
        hour=12,
        minute=0,
        args=[bot, session_pool]
    )

    scheduler.add_job(
        check_graduation_status,
        trigger='cron',
        month=9,
        day=1,
        hour=13,
        minute=0,
        args=[bot, session_pool]
    )

    logger.info("Scheduler configured successfully with 7 jobs.")
    return scheduler

async def send_no_show_surveys(bot: Bot, session_pool: async_sessionmaker):
    """Находит неявившихся участников и отправляет им опрос."""
    now = datetime.datetime.now()
    # Ищем мероприятия, которые закончились 3-4 часа назад
    start_window = now - datetime.timedelta(hours=4)
    end_window = now - datetime.timedelta(hours=3)

    logger.info(f"Running no-show survey job for events ended between {start_window} and {end_window}")

    async with session_pool() as session:
        stmt = (
            select(EventRegistration)
            .join(Event)
            .where(
                Event.event_datetime.between(start_window, end_window),
                EventRegistration.status == 'registered'
            )
            .options(joinedload(EventRegistration.user), joinedload(EventRegistration.event))
        )
        results = await session.execute(stmt)
        no_shows = results.scalars().unique().all()
        
        if not no_shows:
            logger.info("No participants found for no-show survey.")
            return

        for reg in no_shows:
            try:
                builder = types.InlineKeyboardBuilder()
                reasons = {
                    "medical": "Медотвод (болезнь)",
                    "personal": "Личные причины",
                    "forgot": "Забыл(а) / не захотел(а)"
                }
                for key, text in reasons.items():
                    builder.row(types.InlineKeyboardButton(
                        text=text,
                        callback_data=f"no_show_{reg.event_id}_{key}"
                    ))
                
                await bot.send_message(
                    chat_id=reg.user.telegram_id,
                    text=(
                        f"Добрый день! Вы были записаны на донорскую акцию «{reg.event.name}», "
                        "но не отметились у волонтеров. Подскажите, пожалуйста, почему не получилось прийти?"
                    ),
                    reply_markup=builder.as_markup()
                )
                # Меняем статус, чтобы не отправлять повторно
                reg.status = 'no_show_survey_sent'
            except Exception as e:
                logger.error(f"Failed to send no-show survey to user {reg.user_id}: {e}")
        
        await session.commit()

--- КОНЕЦ ФАЙЛА: bot/utils/scheduler.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/text_messages.py ---

import html

class Text:
    @staticmethod
    def escape_html(text: str) -> str:
        """Экранирует специальные символы для parse_mode=HTML."""
        if not isinstance(text, str):
            text = str(text)
        return html.escape(text)

    @staticmethod
    def format_location_link(text: str, latitude: float | None, longitude: float | None) -> str:
        # Экранируем видимую часть текста для HTML
        safe_visible_text = Text.escape_html(text)
        
        if latitude and longitude:
            # Возвращаем HTML-ссылку
            url = f"https://yandex.ru/maps/?pt={longitude},{latitude}&z=18&l=map"
            return f'<a href="{url}">{safe_visible_text}</a>'
            
        # Если координат нет, возвращаем просто экранированный текст
        return safe_visible_text

    DONATION_TYPE_RU = {
        'whole_blood': 'Цельная кровь',
        'plasma': 'Плазма',
        'platelets': 'Тромбоциты',
        'erythrocytes': 'Эритроциты'
    }
    WELCOME = "👋 Добро пожаловать в бот донорского движения МИФИ!\n\nДля начала работы, пожалуйста, поделитесь своим контактом. Это необходимо для вашей идентификации в системе доноров."
    AUTH_SUCCESS = "✅ Авторизация прошла успешно! С возвращением, {name}!"
    START_REGISTRATION = "🔍 Похоже, вы у нас впервые. Давайте познакомимся!"
    GET_FULL_NAME = "📝 Введите, пожалуйста, ваше ФИО (например, Иванов Иван Иванович):"
    GET_UNIVERSITY = "🎓 Выберите ваш ВУЗ:"
    GET_CUSTOM_UNIVERSITY = "Введите полное название вашего ВУЗа:"
    GET_FACULTY = "🏛️ Выберите ваш факультет:"
    GET_CUSTOM_FACULTY = "Введите название вашего факультета:"
    GET_GROUP = "🔢 Введите номер вашей учебной группы (например, Б20-505):"
    GET_GENDER = "🚻 Укажите ваш пол:"
    REGISTRATION_COMPLETE = "🎉 Отлично! Регистрация завершена. Теперь вы можете пользоваться всеми возможностями бота."
    ERROR_WRONG_FORMAT = "❌ Неверный формат. Пожалуйста, попробуйте еще раз."
    INFO_PREPARE = (
        "<b>Как подготовиться к сдаче крови:</b>\n\n"
        "<b>Накануне и в день сдачи крови запрещено:</b>\n"
        "▪️ Употреблять жирную, жареную, острую и копченую пищу, колбасные изделия, а также мясные, рыбные и молочные продукты, яйца и масло (в т.ч. растительное), шоколад, орехи и финики.\n"
        "▪️ Принимать алкоголь за 48 часов до донации.\n"
        "▪️ Принимать лекарства, содержащие аспирин и анальгетики, за 72 часа до донации.\n\n"
        "<b>Что нужно делать:</b>\n"
        "▪️ Хорошо выспаться.\n"
        "▪️ Легко позавтракать (сладкий чай, сухое печенье, каша на воде).\n"
        "▪️ Не курить за час до донации.\n"
        "▪️ Не приходить на донацию при недомогании."
    )
    INFO_CONTRAINDICATIONS = (
        "<b>Абсолютные противопоказания (отвод от донорства навсегда):</b>\n\n"
        "▪️ ВИЧ-инфекция, сифилис, вирусные гепатиты.\n"
        "▪️ Туберкулез (все формы).\n"
        "▪️ Болезни крови.\n"
        "▪️ Онкологические заболевания.\n"
        "▪️ Наркомания, алкоголизм.\n\n"
        "<b>Временные противопоказания:</b>\n"
        "▪️ Удаление зуба (10 дней).\n"
        "▪️ Нанесение татуировки, пирсинг (1 год).\n"
        "▪️ Ангина, грипп, ОРВИ (1 месяц после выздоровления).\n"
        "▪️ Прививки (от 10 дней до 1 года)."
    )
    INFO_AFTER = (
        "<b>Что делать после донации:</b>\n\n"
        "▪️ Отдохните 10–15 минут.\n"
        "▪️ Не снимайте повязку 3–4 часа.\n"
        "▪️ Не подвергайтесь физическим нагрузкам в течение дня.\n"
        "▪️ Воздержитесь от употребления алкоголя в течение суток.\n"
        "▪️ Пейте больше жидкости и полноценно питайтесь в течение двух суток."
    )
    INFO_CONTACTS = (
        "<b>Связаться с организаторами:</b>\n\n"
        "Если у вас возникли вопросы, вы можете связаться с нами:\n"
        "▪️ Телеграм-чат для доноров: [ссылка на чат]\n"
        "▪️ Ответственный за донорское движение: [Александр, @Alkzaz7]"
    )
    NEW_EVENT_NOTIFICATION = (
        "🎉 <b>Анонс нового донорского мероприятия!</b> \n\n"
        "Открыта запись на: <b>{event_name}</b>\n"
        "🗓️ <b>Когда:</b> {event_date} в {event_time}\n"
        "📍 <b>Где:</b> {event_location}\n\n"
        "Вы можете принять участие! Записаться можно прямо сейчас через главное меню бота. "
        "Ваша помощь очень важна!"
    )

    PROFILE_DATA_TEMPLATE = (
        "📊 <b>Ваши данные</b>\n\n"
        "👤 <b>ФИО:</b> {full_name}\n"
        "🎓 <b>Университет:</b> {university}\n"
        "🏛️ <b>Факультет:</b> {faculty}, <b>Группа:</b> {study_group}\n"
        "⭐ <b>Баллы:</b> {points}\n"
        "💉 <b>Всего донаций:</b> {total_donations}\n"
        "🗓️ <b>Следующая донация возможна с:</b> {next_date}\n"
        "--- --- ---\n"
        "<b>Последняя донация:</b> {last_donation_info}\n"
        "<b>Донор костного мозга (ДКМ):</b> {dkm_status}"
    )

    INFO_DKM = (
        "<b>🩸 О донорстве костного мозга (ДКМ)</b>\n\n"
        "<b>Почему это важно?</b>\n"
        "Трансплантация костного мозга — это единственный шанс на жизнь для многих людей с раком крови. Ваши стволовые клетки могут спасти чью-то жизнь.\n\n"
        "<b>Как вступить в регистр?</b>\n"
        "На каждом Дне Донора в МИФИ вы можете сдать дополнительную пробирку крови (4-9 мл), чтобы ваши данные внесли в Федеральный регистр доноров костного мозга. Это просто, быстро и безопасно.\n\n"
        "<b>Что происходит дальше?</b>\n"
        "Если ваши клетки совпадут с клетками нуждающегося пациента, с вами свяжутся. Сама донация похожа на сдачу компонентов крови и абсолютно безопасна для вас."
    )

    INFO_MIFI_PROCESS = (
        "<b>🏥 Как проходят Дни Донора в МИФИ</b>\n\n"
        "<b>1. Регистрация:</b> Заранее запишитесь на удобную дату через этого бота.\n"
        "<b>2. Подготовка:</b> Соблюдайте диету и рекомендации перед сдачей крови.\n"
        "<b>3. В день акции:</b> Приходите в назначенное время с паспортом. Волонтеры вас встретят и проводят.\n"
        "<b>4. Осмотр:</b> Вы пройдете небольшой осмотр у врача из Центра Крови.\n"
        "<b>5. Донация:</b> Сама процедура сдачи крови занимает 10-15 минут.\n"
        "<b>6. Отдых:</b> После донации отдохните, выпейте сладкий чай с печеньем.\n"
        "<b>7. Баллы и мерч:</b> Не забудьте отсканировать QR-код у волонтера, чтобы получить баллы, которые можно обменять на мерч!\n\n"
        "Дата ближайшего Дня Донора будет анонсирована в рассылке."
    )

    CONSENT_TEXT = (
        "<b>Согласие на обработку персональных данных</b>\n\n"
        "Нажимая кнопку «Принимаю условия», вы даете свое согласие на обработку следующих персональных данных: ФИО, номер телефона, telegram-username, данные о донациях.\n\n"
        "Цели обработки: ведение базы доноров, информирование о мероприятиях и новостях донорского движения НИЯУ МИФИ, ведение статистики.\n\n"
        "Ваши данные не будут переданы третьим лицам, за исключением случаев, предусмотренных законодательством."
    )

    WELCOME_BACK = "✅ С возвращением, {name}!"
    MAIN_MENU_PROMPT = "Чем могу помочь?"
    USER_BLOCKED_MESSAGE = "❌ К сожалению, вы были заблокированы."
    SWITCH_TO_DONOR_VIEW = "✅ Вы переключились в режим донора. Здесь доступны все студенческие функции."
    ERROR_PROFILE_NOT_FOUND = "Ошибка: не удалось найти ваш профиль."
    ALREADY_REGISTERED = "Вы уже зарегистрированы, {name}!"
    USER_BLOCKED_ON_AUTH = "❌ Ваш аккаунт заблокирован."
    ACTION_CANCELLED = "Действие отменено."
    ADMIN_SWITCH_TO_VOLUNTEER_VIEW = "⭐ <b>Вы переключились в режим волонтера</b>"
    UNKNOWN_COMMAND = "Я не понимаю эту команду. Пожалуйста, используйте кнопки меню для навигации."
    ERROR_GENERIC_ALERT = "Произошла ошибка. Попробуйте снова."
    INFO_SECTION_NOT_FOUND = "Раздел не найден."
    GET_CATEGORY = "Укажите вашу категорию:"
    FIO_VALIDATION_ERROR = "❌ ФИО не должно содержать цифр или спецсимволов. Пожалуйста, введите корректные данные."
    FACULTY_SELECTED = "Выбран факультет: {faculty}"
    GENDER_SELECTED = "Пол: {gender}"
    DATE_FORMAT_ERROR = "❌ Неверный формат даты. Введите <b>ДД.ММ.ГГГГ</b>."
    PROFILE_MENU_HEADER = "👤 <b>Мой профиль</b>\n\nВыберите, что вас интересует:"
    PROFILE_LOAD_ERROR = "Не удалось загрузить профиль."
    NO_DONATION_HISTORY = "У вас еще нет записей о донациях."
    DONATION_HISTORY_HEADER = "🩸 <b>Ваша история донаций:</b>\n\n"
    DONATION_HISTORY_ITEM = "▪️ {date}: {type}, <b>+{points} баллов</b>\n"
    NO_ACTIVE_EVENTS = "Активных мероприятий для записи сейчас нет."
    CHOOSE_EVENT_TO_REGISTER = "Выберите мероприятие для записи:"
    ALREADY_REGISTERED_FOR_EVENT = (
        "Вы уже записаны на мероприятие «<b>{event_name}</b>».\n\n"
        "📍 <b>Место проведения:</b> {event_location}\n"
        "🏢 <b>Центр крови:</b> {blood_center_name}\n\n"
        "Здесь вы можете получить QR-код или отменить свою запись."
    )
    REGISTRATION_SUCCESSFUL = (
        "✅ Вы успешно записаны на: <b>{event_name}</b>\n\n"
        "📍 <b>Место проведения:</b> {event_location}\n"
        "🏢 <b>Центр крови:</b> {blood_center_name}\n\n"
        "Ваш QR-код для подтверждения донации доступен по кнопке ниже."
    )
    REGISTRATION_FAILED = "❌ Запись невозможна.\nПричина: {reason}"
    REGISTRATION_CANCELLED_SUCCESS = "✅ Ваша регистрация на мероприятие была отменена."
    REGISTRATION_CANCELLED_FAIL = "Не удалось отменить регистрацию. Возможно, она уже была отменена."
    MERCH_NO_ITEMS = "В магазине пока нет товаров."
    MERCH_ITEM_CAPTION = (
        "🛍️ <b>{item_name}</b>\n\n"
        "{item_description}\n\n"
        "Цена: <b>{item_price}</b> баллов\n"
        "Ваш баланс: <b>{user_points}</b> баллов"
    )
    MERCH_PURCHASE_INSUFFICIENT_FUNDS = "Недостаточно баллов. Нужно {price}, у вас {points}."
    MERCH_ITEM_NOT_FOUND = "Товар не найден."
    MERCH_PURCHASE_CONFIRMATION = (
        "Вы уверены, что хотите купить <b>'{item_name}'</b> за <b>{item_price}</b> баллов?\n\n"
        "Ваш баланс после покупки: <b>{new_balance}</b> баллов."
    )
    MERCH_PURCHASE_SUCCESS = "🎉 Поздравляем с покупкой!\n{message}\n\nМы сообщим, когда можно будет забрать заказ."
    MERCH_PURCHASE_ERROR = "⚠️ Ошибка: {message}"
    MERCH_NO_ORDERS = "У вас пока нет заказов."
    MERCH_ORDERS_HEADER = "🛍️ <b>Ваши заказы:</b>\n\n"
    MERCH_ORDER_ITEM = "▪️ <b>{item_name}</b> (от {date})\n   Статус: <b>{status}</b>\n"
    MERCH_STATUS_MAP = {'pending_pickup': 'Ожидает выдачи', 'completed': 'Выдан'}
    MERCH_UPDATE_ERROR = "Не удалось обновить. Попробуйте войти в магазин заново."
    WAIVERS_MENU_HEADER = "⚕️ <b>Управление медицинскими отводами</b>\n"
    NO_ACTIVE_WAIVERS = "\n✅ У вас нет активных отводов. Вы можете спасать жизни! 💪"
    SYSTEM_WAIVERS_HEADER = "\n<b>Назначенные системой/администратором (нельзя отменить):</b>"
    USER_WAIVERS_HEADER = "\n<b>Установленные вами (можно отменить):</b>"
    WAIVER_ITEM_FORMAT = "▪️ До <b>{end_date}</b> по причине: «{reason}»"
    WAIVER_SET_PROMPT = (
        "Вы можете установить временный отвод от донорства (например, из-за ОРВИ или плохого самочувствия).\n\n"
        "Введите дату, до которой будет действовать отвод, в формате <b>ДД.ММ.ГГГГ</b>:"
    )
    WAIVER_DATE_IN_PAST_ERROR = "❌ Дата окончания должна быть в будущем. Попробуйте снова."
    WAIVER_REASON_PROMPT = "Отлично. Теперь кратко укажите причину (например, 'Простуда', 'Плохое самочувствие'):"
    WAIVER_SET_SUCCESS = "✅ Ваш личный медотвод успешно установлен до {end_date}."
    WAIVER_CANCELLATION_PROMPT = "Выберите, какой из ваших отводов отменить:"
    WAIVER_NOTHING_TO_CANCEL = "У вас нет отводов, которые можно отменить."
    WAIVER_CANCEL_SUCCESS = "✅ Ваш медотвод успешно отменен."
    WAIVER_CANCEL_FAIL = "❌ Не удалось отменить отвод."
    INFO_MENU_HEADER = "ℹ️ <b>Полезная информация</b>\n\nВыберите интересующий вас раздел:"
    QR_GENERATING = "Генерирую ваш QR-код..."
    QR_GENERAL_CAPTION = "Этот QR-код можно использовать для быстрой идентификации. Для подтверждения донации на мероприятии используйте QR-код из меню мероприятия."
    QR_EVENT_CAPTION = "Покажите этот QR-код волонтёру после донации для начисления баллов."
    VOLUNTEER_MENU_HEADER = "⭐ <b>Меню волонтёра</b>"
    VOLUNTEER_SEND_QR_PROMPT = "Отправьте мне фотографию с QR-кодом донора."
    QR_READ_ERROR = "❌ QR-код не распознан или имеет неверный формат. Попробуйте снова."
    QR_INVALID_DATA_ERROR = "❌ QR-код содержит некорректные данные."
    QR_DB_LOOKUP_ERROR = "❌ Ошибка: Пользователь или мероприятие из QR-кода не найдены в базе."
    QR_DONOR_NOT_REGISTERED_ERROR = "❌ Ошибка: Донор <b>{donor_name}</b> не зарегистрирован на это мероприятие."
    QR_WRONG_DAY_ERROR = "❌ Ошибка: Этот QR-код для мероприятия, которое проходит не сегодня."
    VOLUNTEER_CONFIRMATION_PROMPT = (
        "🔍 <b>Подтверждение донации</b>\n\n"
        "Вы собираетесь подтвердить донацию для:\n"
        "👤 <b>Донор:</b> {donor_name}\n"
        "🗓️ <b>Мероприятие:</b> {event_name}\n\n"
        "Все верно?"
    )
    VOLUNTEER_CONFIRMATION_ERROR = "❌ Произошла ошибка. Пожалуйста, отсканируйте QR-код заново."
    DONATION_CONFIRMING = "⏳ Подтверждаю донацию..."
    DONATION_CONFIRM_ERROR_NO_REG = "❌ Ошибка: не удалось найти донора или его регистрацию. Возможно, она была отменена."
    DONATION_CONFIRM_SUCCESS = (
        "✅ Донация для <b>{donor_name}</b> на мероприятии «<b>{event_name}</b>» подтверждена.\n\n"
        "Начислено <b>{points}</b> баллов.\n\nГотовы сканировать следующий QR-код."
    )
    DONATION_CONFIRM_CRITICAL_ERROR = "Произошла критическая ошибка при подтверждении донации: {error}"
    VOLUNTEER_INVALID_INPUT_QR = "Пожалуйста, отправьте именно фотографию с QR-кодом."
    ADMIN_PANEL_HEADER = "⚙️ Панель администратора"
    ADMIN_EVENTS_HEADER = "🗓️ Управление мероприятиями"
    EVENT_CREATE_STEP_1_NAME = "Шаг 1/7: Введите название мероприятия:"
    EVENT_CREATE_STEP_2_DATE = "Шаг 2/7: Введите дату и время мероприятия в формате <b>ДД.ММ.ГГГГ ЧЧ:ММ</b> (например, 25.12.2024 10:30):"
    EVENT_CREATE_STEP_3_LOCATION_TEXT = "Шаг 3/7: Введите адрес мероприятия текстом (например, 'г. Москва, ул. Каширское шоссе, д. 31'):"
    EVENT_CREATE_STEP_4_LOCATION_POINT = "Шаг 4/7: Отлично. Теперь отправьте геоточку для этого адреса, чтобы доноры могли легко построить маршрут."
    EVENT_CREATE_STEP_5_TYPE = "Шаг 5/7: Выберите тип донации:"
    EVENT_CREATE_STEP_6_POINTS = "Выбран тип: {donation_type}\n\nШаг 6/7: Введите количество баллов за донацию:"
    EVENT_CREATE_STEP_7_LIMIT = "Шаг 7/7: Введите лимит участников:"
    EVENT_LIMIT_NAN_ERROR = "❌ Лимит должен быть числом."
    EVENT_POINTS_NAN_ERROR = "❌ Введите целое число."
    EVENT_CREATE_CONFIRMATION = (
        "✅ Все данные собраны. Пожалуйста, проверьте:\n\n"
        "▪️ Название: {name}\n"
        "▪️ Дата и время: {datetime}\n"
        "▪️ Адрес: {location}\n"
        "▪️ Центр крови: {blood_center_name}\n"
        "▪️ Точка на карте: {location_set}\n"
        "▪️ Тип: {type}\n"
        "▪️ Баллы: {points}\n"
        "▪️ Лимит: {limit}\n\n"
        "Создать мероприятие и запустить рассылку?"
    )
    EVENT_CREATING_IN_PROGRESS = "Принято. Создаю мероприятие..."
    EVENT_CREATE_SUCCESS = "✅ Мероприятие успешно создано!"
    MAILING_STARTED_NOTIFICATION = "⏳ Начинаю рассылку. Это может занять некоторое время..."
    MAILING_FINISHED_NOTIFICATION = "✅ Рассылка завершена.\n\nОтправлено: {success}\nОшибок: {fail}"
    MAILING_ERROR = "❌ Произошла ошибка во время рассылки."
    ADMIN_NO_ACTIVE_EVENTS = "Активных мероприятий нет."
    ADMIN_CHOOSE_EVENT_TO_MANAGE = "Выберите мероприятие для управления:\n(✅ - регистрация открыта, 🔒 - закрыта)"
    EVENT_NOT_FOUND = "Мероприятие не найдено."
    EVENT_CARD_TEMPLATE = (
        "🗓️ {name}\n\n"
        "▪️ {date_header} {datetime}\n" 
        "▪️ {location_header} {location}\n"
        "▪️ <b>Центр крови:</b> {blood_center_name}\n"
        "▪️ {type_header} {donation_type}\n"
        "▪️ {points_header} {points_per_donation}\n"
        "▪️ {limit_header} {reg_count}/{participant_limit}\n"
        "▪️ {status_header} {is_active}\n"
        "▪️ {reg_status_header} {reg_is_open}"
    )
    EVENT_TOGGLE_REG_OPEN = "Регистрация на мероприятие теперь открыта."
    EVENT_TOGGLE_REG_CLOSED = "Регистрация на мероприятие теперь закрыта."
    EVENT_EDIT_PROMPT = "Вы редактируете: <b>{event_name}</b>\n\nКакое поле хотите изменить?"
    EVENT_EDIT_FIELD_PROMPTS = {
        "name": "Введите новое название:",
        "event_date": "Введите новую дату (ДД.ММ.ГГГГ):",
        "location": "Введите новое место:",
        "points_per_donation": "Введите новое кол-во баллов:",
        "participant_limit": "Введите новый лимит:"
    }
    EVENT_EDIT_INVALID_FORMAT = "❌ Неверный формат данных. Попробуйте снова."
    EVENT_EDIT_SUCCESS = "✅ Поле успешно обновлено!"
    EVENT_NO_PARTICIPANTS = "На '{event_name}' пока никто не записался."
    EVENT_PARTICIPANTS_CAPTION = "Участники мероприятия '{event_name}'"
    EVENT_CANCEL_CONFIRMATION = "🚨 <b>Подтверждение отмены</b>\n\nВы уверены, что хотите отменить «<b>{event_name}</b>»?\n\nУведомление будет отправлено <b>{reg_count}</b> участникам."
    EVENT_CANCELLING_IN_PROGRESS = "⏳ Начинаю процесс отмены..."
    EVENT_CANCEL_NOTIFICATION_TEXT = "❗️ <b>Внимание, мероприятие отменено!</b>\n\nК сожалению, «<b>{event_name}</b>», запланированное на {datetime}, было отменено."
    EVENT_CANCEL_SUCCESS_REPORT = "✅ <b>Мероприятие «{event_name}» отменено.</b>\n\n<b>Результаты:</b>\n- Успешно отправлено: {success}\n- Ошибок: {fail}"
    MAILING_STEP_1_TEXT_PROMPT = (
        "Вы начали создание рассылки.\n\n"
        "<b>Шаг 1/3:</b> Введите текст сообщения. Он будет подписью, если вы добавите фото/видео. "
        "Можно использовать HTML-теги: <b>жирный</b>, <i>курсив</i>, <code>код</code>, <a href='...'>ссылка</a>.\n\n"
        "Чтобы отменить, нажмите /cancel."
    )
    MAILING_STEP_2_MEDIA_PROMPT = (
        "Текст получен.\n\n"
        "<b>Шаг 2/3:</b> Теперь отправьте фото или видео, которое нужно прикрепить к рассылке. "
        "Если хотите отправить только текст, нажмите 'Пропустить'."
    )
    MAILING_PHOTO_RECEIVED = "Фото получено.\n\n<b>Шаг 3/3:</b> Выберите аудиторию для рассылки:"
    MAILING_VIDEO_RECEIVED = "Видео получено.\n\n<b>Шаг 3/3:</b> Выберите аудиторию для рассылки:"
    MAILING_STEP_3_AUDIENCE_PROMPT = "<b>Шаг 3/3:</b> Выберите аудиторию для рассылки:"
    MAILING_AUDIENCE_MAP = {
        "all": "Всем пользователям",
        "can_donate": "Донорам, которые могут сдавать",
        "volunteers": "Волонтерам",
        "admins": "Администраторам"
    }
    MAILING_PREVIEW_HEADER = (
    "<b>🔍 Проверьте рассылку перед запуском</b>\n\n"
    "<b>👤 Аудитория:</b> {audience}\n"
    "<b>👥 Получателей:</b> {count}\n"
    )
    MAILING_PREVIEW_WITH_PHOTO = "🖼️ <b>Прикреплено фото</b>\n"
    MAILING_PREVIEW_WITH_VIDEO = "📹 <b>Прикреплено видео</b>\n"
    MAILING_PREVIEW_TEXT_HEADER = "\n<b>✉️ Текст/подпись:</b>\n------------------------------------\n{text}\n------------------------------------"
    MAILING_EDIT_TEXT_PROMPT = "Введите новый текст сообщения для рассылки:"
    MAILING_CONFIRMED_AND_RUNNING = "✅ Рассылка запущена в фоновом режиме. Вы можете продолжать пользоваться ботом."
    ADMIN_MERCH_HEADER = "🛍️ <b>Управление магазином</b>"
    MERCH_CREATE_STEP_1_PHOTO = "Отправьте фотографию для нового товара."
    MERCH_PHOTO_RECEIVED = "Фото получено. Введите название товара:"
    MERCH_NAME_RECEIVED = "Название сохранено. Введите описание товара:"
    MERCH_DESC_RECEIVED = "Описание сохранено. Введите цену в баллах:"
    MERCH_PRICE_NAN_ERROR = "❌ Цена должна быть целым числом."
    MERCH_CREATE_PHOTO_ID_ERROR = "❌ Произошла ошибка: ID фото не был сохранен. Начните заново."
    MERCH_CREATE_SUCCESS = "✅ Товар успешно добавлен!"
    ADMIN_NO_MERCH_ITEMS = "В магазине пока нет товаров."
    ADMIN_CHOOSE_MERCH_TO_MANAGE = "Выберите товар для управления:"
    MERCH_CARD_CAPTION = (
        "🛍️ <b>Товар: {name}</b>\n\n"
        "▪️ <b>Описание:</b> {description}\n"
        "▪️ <b>Цена:</b> {price} баллов\n"
        "▪️ <b>Статус:</b> {status}"
    )
    MERCH_EDIT_PROMPT = "Вы редактируете: <b>{name}</b>\n\nКакое поле хотите изменить?"
    MERCH_EDIT_FIELD_PROMPTS = {
        "name": "Введите новое название:",
        "description": "Введите новое описание:",
        "price": "Введите новую цену в баллах:"
    }
    MERCH_EDIT_NEW_VALUE_PROMPT = "Введите новое значение:"
    MERCH_EDIT_SUCCESS = "✅ Поле успешно обновлено!"
    MERCH_TOGGLE_AVAILABILITY = "Статус изменен на: {status}."
    MERCH_DELETE_CONFIRMATION = "🗑️ <b>Подтверждение удаления</b>\n\nВы уверены, что хотите <b>безвозвратно</b> удалить «<b>{name}</b>»?"
    MERCH_DELETE_SUCCESS = "✅ Товар «<b>{name}</b>» был удален."
    MERCH_ITEM_ALREADY_DELETED = "Товар уже удален."
    ADMIN_NO_PENDING_ORDERS = "Новых заказов нет."
    ADMIN_PENDING_ORDERS_HEADER = "📦 <b>Новые заказы на выдачу:</b>\n\n"
    ADMIN_ORDER_ITEM_TEXT = (
        "🔹 <b>Заказ №{order_id}</b> от {date}\n"
        "   Товар: «{item_name}»\n"
        "   Заказал: {user_link} (@{username})\n"
        "   Телефон: {phone}"
    )
    ADMIN_ORDER_ITEM_TEXT_NO_USERNAME = (
        "🔹 <b>Заказ №{order_id}</b> от {date}\n"
        "   Товар: «{item_name}»\n"
        "   Заказал: {user_link}\n"
        "   Телефон: {phone}"
    )
    ADMIN_COMPLETE_ORDER_ADMIN_ID_ERROR = "Ошибка: не удалось идентифицировать администратора."
    ADMIN_ORDER_NOT_FOUND_OR_PROCESSED = "Заказ не найден или уже обработан."
    ADMIN_ORDER_COMPLETED_SUCCESS = "✅ Заказ №{order_id} помечен как выданный."
    USER_ORDER_COMPLETED_NOTIFICATION = "🎉 Ваш заказ «{item_name}» был выдан. Приятного пользования!"
    EXPORT_STARTED = "⏳ Начинаю сбор данных и создание архива... Это может занять некоторое время."
    EXPORT_SUCCESSFUL = "✅ Полный бэкап базы данных готов."
    EXPORT_FAILED = "❌ Произошла ошибка при создании бэкапа. Подробности в логах."
    ADMIN_USERS_HEADER = "👥 <b>Управление пользователями</b>"
    ADMIN_NO_USERS_IN_DB = "В базе данных пока нет пользователей."
    USERS_LIST_HEADER = "📜 <b>Список пользователей (Страница {page}/{total_pages})</b>\n\n"
    USER_SEARCH_PROMPT = "🔍 Введите запрос для поиска (ФИО, username, ID, телефон):"
    USER_SEARCH_NO_RESULTS = "🤷‍♂️ По вашему запросу никого не найдено."
    USER_SEARCH_RESULTS_HEADER = "🔍 <b>Результаты поиска по запросу «{query}»:</b>\n\n"
    USER_CARD_HEADER = "👤 Профиль пользователя: {full_name}"
    USER_CARD_TEMPLATE = (
        "  <b>ФИО:</b> {full_name}\n"
        "  <b>ID:</b> <code>{telegram_id}</code>\n"
        "  <b>Username:</b> @{username}\n"
        "  <b>Телефон:</b> <code>{phone_number}</code>\n"
        "  <b>Роль:</b> <code>{role}</code>\n"
        "  <b>Баллы:</b> <b>{points}</b>\n"
        "  <b>Статус:</b> <b>{block_status}</b>"
    )
    USER_NOT_FOUND = "Пользователь не найден."
    CHANGE_POINTS_PROMPT = "Введите сумму баллов для начисления (например, 50) или списания (-50):"
    CHANGE_POINTS_REASON_PROMPT = "Введите причину начисления/списания:"
    CHANGE_POINTS_SUCCESS = "✅ Баланс пользователя {name} изменен. Новый баланс: {balance}"
    USER_POINTS_CHANGED_NOTIFICATION = "⚙️ Администратор изменил ваш баланс на {points} баллов.\n<b>Причина:</b> {reason}\n<b>Ваш новый баланс:</b> {balance}"
    USER_PROMOTED_VOLUNTEER = "✅ Пользователь {name} назначен волонтером."
    USER_PROMOTED_VOLUNTEER_NOTIFY = "⭐ Поздравляем! Администратор назначил вас волонтером. Вам доступно меню волонтера."
    USER_DEMOTED_VOLUNTEER = "✅ Пользователь {name} снят с должности волонтера."
    USER_DEMOTED_VOLUNTEER_NOTIFY = "⚙️ Ваша роль изменена на 'студент'. Меню волонтера больше недоступно."
    USER_PROMOTED_ADMIN = "✅ {name} назначен администратором."
    USER_PROMOTED_ADMIN_NOTIFY = "Поздравляем! Вас назначили администратором бота."
    USER_DEMOTED_ADMIN = "✅ {name} разжалован до студента."
    USER_DEMOTED_ADMIN_NOTIFY = "Ваша роль изменена на 'студент'."
    BLOCK_USER_REASON_PROMPT = "Введите причину блокировки:"
    ADMIN_ID_ERROR = "Критическая ошибка: не удалось идентифицировать вас."
    BLOCK_TARGET_USER_NOT_FOUND = "Ошибка: целевой пользователь не найден."
    USER_BLOCKED_SUCCESS = "✅ Пользователь {name} заблокирован. Причина: {reason}"
    USER_BLOCKED_NOTIFY = "Ваш аккаунт был заблокирован.\nПричина: {reason}"
    USER_UNBLOCKED_SUCCESS = "✅ Пользователь {name} успешно разблокирован."
    USER_UNBLOCKED_NOTIFY = "🎉 Ваш аккаунт был разблокирован. Теперь вы снова можете пользоваться ботом."
    MANAGE_USER_REGS_HEADER = "🎟️ Управление регистрациями для: <b>{name}</b>\n\nВыберите действие:"
    MANUAL_REG_CHOOSE_EVENT = "Выберите мероприятие, на которое нужно записать пользователя:"
    MANUAL_REG_NO_EVENTS = "Нет предстоящих мероприятий для записи."
    MANUAL_REG_SUCCESS_NOTIFY = "⚙️ Администратор записал вас на мероприятие «<b>{event_name}</b>» на {datetime}."
    NOTIFY_USER_FAILED = "⚠️ Не удалось уведомить пользователя {name}."
    MANUAL_CANCEL_CHOOSE_REG = "Выберите регистрацию, которую нужно отменить:"
    MANUAL_CANCEL_NO_REGS = "У этого пользователя нет активных регистраций на будущие мероприятия."
    MANUAL_CANCEL_SUCCESS = "Регистрация пользователя {name} на {event_name} отменена."
    MANUAL_CANCEL_SUCCESS_NOTIFY = "⚙️ Администратор отменил вашу запись на мероприятие «<b>{event_name}</b>»."
    MANUAL_CANCEL_FAIL = "Не удалось отменить регистрацию (возможно, уже отменена)."
    MANAGE_WAIVERS_HEADER = "⚕️ Управление медотводами пользователя <b>{name}</b>.\n\n"
    MANAGE_WAIVERS_NO_WAIVERS = "Активных медотводов нет. Вы можете установить новый."
    MANAGE_WAIVERS_WITH_WAIVERS = "Нажмите на медотвод, чтобы удалить, или установите новый:"
    MANUAL_WAIVER_DATE_PROMPT = "Введите дату окончания медотвода в формате ДД.ММ.ГГГГ:"
    MANUAL_WAIVER_REASON_PROMPT = "Введите причину медотвода:"
    MANUAL_WAIVER_SUCCESS = "✅ Медотвод для {name} установлен до {date}."
    MANUAL_WAIVER_NOTIFY = "⚕️ Администратор установил вам медотвод до {date}.\n<b>Причина:</b> {reason}"
    ADMIN_DELETE_WAIVER_DATA_ERROR = "Ошибка в данных. Попробуйте снова."
    ADMIN_DELETE_WAIVER_SUCCESS = "✅ Медотвод успешно удален."
    ADMIN_DELETE_WAIVER_FAIL = "❌ Не удалось удалить медотвот."
    ADMIN_DELETE_WAIVER_NOTIFY = "⚙️ Администратор отменил один из ваших медицинских отводов."
    WAIVER_EXPIRED_NOTIFICATION = "🎉 Отличные новости! Срок вашего медицинского отвода истек. Вы снова можете спасать жизни, участвуя в донациях! 💪"
    REMINDER_WEEK = (
        "👋 <b>Напоминание о донации через неделю!</b> \n\n"
        "Вы записаны на мероприятие «<b>{event_name}</b>», которое состоится через неделю - <b>{event_datetime}</b>.\n\n"
        "📍 <b>Место:</b> {event_location}\n\n"
        "Пожалуйста, начните готовиться к донации заранее и следите за своим самочувствием. Спасибо!"
    )
    REMINDER_3_DAYS = (
        "👋 <b>Напоминание о донации!</b> \n\n"
        "Вы записаны на мероприятие «<b>{event_name}</b>», которое состоится через 3 дня - <b>{event_datetime}</b>.\n\n"
        "📍 <b>Место:</b> {event_location}\n\n"
        "Напоминаем, что за 48 часов до донации нельзя принимать лекарства, содержащие аспирин и анальгетики."
    )
    REMINDER_2_DAYS = (
        "👋 <b>Напоминание о донации!</b> \n\n"
        "Вы записаны на мероприятие «<b>{event_name}</b>», которое состоится через 2 дня - <b>{event_datetime}</b>.\n\n"
        "📍 <b>Место:</b> {event_location}\n\n"
        "Напоминаем, что за 48 часов до донации нельзя принимать лекарства, содержащие аспирин и анальгетики."
    )
    REMINDER_1_DAY = (
        "👋 <b>Напоминание о донации!</b> \n\n"
        "Вы записаны на мероприятие «<b>{event_name}</b>», которое состоится завтра, <b>{event_datetime}</b>.\n\n"
        "📍 <b>Место:</b> {event_location}\n\n"
        "Напоминаем, что за 24 часа до донации нельзя употреблять БАДы. Пожалуйста, не забудьте паспорт и хорошо выспитесь. Спасибо, что помогаете!"
    )
    REMINDER_2_HOURS = (
        "❗️<b>Донация уже скоро!</b> \n\n"
        "Напоминаем, что вы записаны на мероприятие «<b>{event_name}</b>», которое начнется уже через 2 часа, в <b>{event_datetime}</b>.\n\n"
        "Ждем вас по адресу: {event_location}"
    )
    POST_DONATION_FEEDBACK = "Привет! Как ты себя чувствуешь?\n\nОцени, пожалуйста, организацию мероприятия 1/5"
    FEEDBACK_START = "👋 Привет! Спасибо за твою донацию вчера. Мы были бы очень признательны, если бы ты ответил(а) на несколько вопросов. Это поможет нам стать лучше!\n\nДля начала, как ты себя чувствуешь после донации? Оцени по шкале от 1 (очень плохо) до 5 (отлично)."
    FEEDBACK_WELL_BEING_BAD = "Нам жаль это слышать. Пожалуйста, напиши, что именно не так? (например, 'кружится голова', 'слабость'). Если тебе нужна помощь, обязательно свяжись с нами!"
    FEEDBACK_GET_ORGANIZATION_SCORE = "Понятно, спасибо! Теперь оцени, пожалуйста, организацию самого мероприятия по шкале от 1 (очень плохо) до 10 (отлично)."
    FEEDBACK_GET_WHAT_LIKED = "Отлично! Расскажи, пожалуйста, что тебе понравилось больше всего?"
    FEEDBACK_GET_WHAT_DISLIKED = "Спасибо! А что можно было бы улучшить? Что не понравилось?"
    FEEDBACK_GET_OTHER_SUGGESTIONS = "Принято. И последний вопрос: есть ли у тебя какие-либо другие идеи или предложения?"
    FEEDBACK_FINISH = "🎉 Опрос завершён! Огромное спасибо за твою обратную связь. Она очень важна для нас!"
    FEEDBACK_ADMIN_HEADER = "📊 <b>Отзывы по мероприятию «{event_name}»</b>\n\n"
    FEEDBACK_ADMIN_NO_FEEDBACK = "По этому мероприятию пока нет отзывов."
    FEEDBACK_ADMIN_ITEM = (
        "--- Отзыв от {user_name} ---\n"
        "<b>Самочувствие:</b> {wb_score}/5\n"
        "<i>Комментарий:</i> {wb_comment}\n"
        "<b>Организация:</b> {org_score}/10\n"
        "<b>👍 Понравилось:</b> {liked}\n"
        "<b>👎 Не понравилось:</b> {disliked}\n"
        "<b>💬 Предложения:</b> {suggestions}\n\n"
    )

--- КОНЕЦ ФАЙЛА: bot/utils/text_messages.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/utils/__init__.py ---

--- НАЧАЛО ФАЙЛА: donor_bot_telegram.egg-info/dependency_links.txt ---




--- КОНЕЦ ФАЙЛА: donor_bot_telegram.egg-info/dependency_links.txt ---

--- НАЧАЛО ФАЙЛА: donor_bot_telegram.egg-info/SOURCES.txt ---

README.md
pyproject.toml
bot/__init__.py
bot/config_reader.py
bot/db/__init__.py
bot/db/admin_requests.py
bot/db/analytics_requests.py
bot/db/engine.py
bot/db/event_requests.py
bot/db/info_requests.py
bot/db/merch_requests.py
bot/db/models.py
bot/db/qa_management.py
bot/db/question_requests.py
bot/db/user_requests.py
bot/filters/role.py
bot/handlers/__init__.py
bot/handlers/common.py
bot/handlers/main_admin.py
bot/handlers/other.py
bot/handlers/student.py
bot/handlers/volunteer.py
bot/handlers/admin/__init__.py
bot/handlers/admin/analytics.py
bot/handlers/admin/event_management.py
bot/handlers/admin/info_management.py
bot/handlers/admin/mailing.py
bot/handlers/admin/merch_management.py
bot/handlers/admin/qa_management.py
bot/handlers/admin/system.py
bot/handlers/admin/user_management.py
bot/keyboards/__init__.py
bot/keyboards/inline.py
bot/keyboards/reply.py
bot/middlewares/__init__.py
bot/middlewares/block.py
bot/middlewares/db.py
bot/states/__init__.py
bot/states/states.py
bot/utils/__init__.py
bot/utils/analytics_service.py
bot/utils/calendar_service.py
bot/utils/graduation.py
bot/utils/qr_service.py
bot/utils/scheduler.py
bot/utils/text_messages.py
donor_bot_telegram.egg-info/PKG-INFO
donor_bot_telegram.egg-info/SOURCES.txt
donor_bot_telegram.egg-info/dependency_links.txt
donor_bot_telegram.egg-info/top_level.txt
tests/test_admin_fsm.py
tests/test_analytics.py
tests/test_calendar_service.py
tests/test_db_requests.py
tests/test_filters.py
tests/test_graduation.py
tests/test_handlers_logic.py
tests/test_keyboards.py
tests/test_mailing_logic.py
tests/test_middlewares.py
tests/test_registration_logic.py
tests/test_scheduler_logic.py
tests/test_security.py
tests/test_survey_logic.py
tests/test_utils.py
tests/test_volunteer_fsm.py

--- КОНЕЦ ФАЙЛА: donor_bot_telegram.egg-info/SOURCES.txt ---

--- НАЧАЛО ФАЙЛА: donor_bot_telegram.egg-info/top_level.txt ---

bot


--- КОНЕЦ ФАЙЛА: donor_bot_telegram.egg-info/top_level.txt ---

--- НАЧАЛО ФАЙЛА: logs/pytest-logs.txt ---

ERROR    main:main.py:95 Telegram WebApp data validation failed: Invalid hash. Raw auth_data: 'auth_date=1700000000&query_id=AAg123456789&user=%7B%22id%22%3A123%2C%22username%22%3A%22test%22%7D&hash=125b98532e863d708dcf6141ea32692de0537a3a4a18cbe18b38e5abcdefghij'
ERROR    main:main.py:95 Telegram WebApp data validation failed: Hash not found in auth data. Raw auth_data: 'user=%7B%22id%22%3A+123%7D&auth_date=1700000000'
ERROR    main:main.py:95 Telegram WebApp data validation failed: Invalid hash. Raw auth_data: 'auth_date=1700000000&query_id=AAg123456789&user=%7B%22id%22%3A123%7D&hash=40f05e5ab6663c9f1ef8c1ce079b8ae543366d3c47562462714dcd19790c2116&new_param=hacker'


--- КОНЕЦ ФАЙЛА: logs/pytest-logs.txt ---

--- НАЧАЛО ФАЙЛА: tests/conftest.py ---

# tests/conftest.py

import pytest
import pytest_asyncio
import sys
from pathlib import Path
from typing import AsyncGenerator

from sqlalchemy.ext.asyncio import (
    create_async_engine,
    async_sessionmaker,
    AsyncSession,
    AsyncEngine,
)

# --- Настройка путей ---
# Добавляем корневую папку проекта в sys.path, чтобы pytest мог найти модули бота.
# Это стандартная практика для корректной работы импортов в тестах.
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from bot.db.models import Base

# --- Настройка тестовой БД ---

# URL для асинхронной базы данных SQLite в памяти.
# Это идеальный выбор для быстрых и полностью изолированных тестов,
# так как база данных создается в оперативной памяти и исчезает после завершения тестов.
TEST_DATABASE_URL = "sqlite+aiosqlite:///:memory:"

# Создаем тестовый движок БД. Он будет жить в течение всей тестовой сессии.
test_engine: AsyncEngine = create_async_engine(TEST_DATABASE_URL, echo=False)

# Создаем фабрику сессий для тестов.
# Она будет использоваться для создания новых сессий для каждого теста.
TestSessionMaker = async_sessionmaker(
    bind=test_engine, class_=AsyncSession, expire_on_commit=False
)


@pytest_asyncio.fixture(scope="session", autouse=True)
async def setup_database() -> AsyncGenerator[None, None]:
    """
    Фикстура уровня сессии для подготовки базы данных.

    `scope="session"`: код выполняется один раз перед запуском всех тестов.
    `autouse=True`: фикстура активируется автоматически, ее не нужно указывать в тестах.

    Действия:
    1. Перед тестами: создает все таблицы на основе моделей SQLAlchemy.
    2. После тестов: удаляет все таблицы, очищая окружение.
    """
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    yield  # В этот момент выполняются все тесты

    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)


@pytest_asyncio.fixture(scope="function")
async def session(setup_database: None) -> AsyncGenerator[AsyncSession, None]:
    """
    Основная фикстура для предоставления сессии в каждый тестовый кейс.

    `scope="function"`: код выполняется для каждой отдельной тестовой функции.
    `setup_database`: зависимость от фикстуры, которая гарантирует, что таблицы уже созданы.

    Принцип работы для изоляции тестов:
    1. Устанавливается соединение с БД.
    2. Начинается транзакция.
    3. Создается сессия, привязанная к этой транзакции.
    4. Сессия передается в тест (`yield session`).
    5. Тест выполняет свои операции с БД (добавление, изменение данных).
    6. После завершения теста транзакция откатывается (`rollback`), отменяя все изменения,
       сделанные в тесте.
    7. Соединение закрывается.

    Таким образом, каждый тест начинается с абсолютно чистой БД.
    """
    connection = await test_engine.connect()
    transaction = await connection.begin()

    try:
        # Создаем сессию, привязанную к транзакции
        session_for_test = TestSessionMaker(bind=connection)
        yield session_for_test
    finally:
        # Откатываем транзакцию и закрываем соединение в любом случае
        await transaction.rollback()
        await connection.close()
        
@pytest.fixture(scope="session")
def session_pool() -> async_sessionmaker:
    """
    Фикстура, которая предоставляет фабрику сессий (session maker).
    Она нужна для компонентов, которые сами управляют созданием сессий,
    например, для планировщика.
    """
    return TestSessionMaker

--- КОНЕЦ ФАЙЛА: tests/conftest.py ---

--- НАЧАЛО ФАЙЛА: tests/test_admin_fsm.py ---

import pytest
import datetime
from unittest.mock import AsyncMock, Mock

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from aiogram import Bot

from bot.handlers.admin import merch_management as merch_handlers
from bot.handlers.admin import user_management as user_handlers
from bot.handlers.admin import event_management as event_handlers
from bot.handlers.admin import mailing as mailing_handlers
from bot.states.states import MerchCreation, BlockUser, ManualWaiver, EventEditing, UserSearch, Mailing, AdminAddUser, EditInfoSection, PostEventProcessing

from bot.db.models import MerchItem, User, UserBlock, MedicalWaiver, Event, InfoText, Donation, EventRegistration
from bot.handlers.admin import info_management as info_handlers


pytestmark = pytest.mark.asyncio

class MockMessage:
    def __init__(self, text=None, from_user_id=1, photo=None):
        self.text = text
        self.from_user = Mock(id=from_user_id)
        self.photo = [Mock(file_id="photo_file_id_123")] if photo else None
        self.html_text = text
        self.answer = AsyncMock()
        self.delete = AsyncMock()

class MockCallbackQuery:
    def __init__(self, data, from_user_id=1, message=None):
        self.data = data
        self.from_user = Mock(id=from_user_id)
        if not message:
            self.message = MockMessage(from_user_id=from_user_id)
        else:
            self.message = message
        for method_name in ['edit_text', 'delete', 'answer']:
            if not hasattr(self.message, method_name):
                setattr(self.message, method_name, AsyncMock())
        self.answer = AsyncMock()

class MockFSMContext:
    def __init__(self):
        self._state = None
        self._data = {}
    async def get_state(self): return self._state
    async def set_state(self, state): self._state = state
    async def get_data(self): return self._data.copy()
    async def update_data(self, **kwargs): self._data.update(kwargs)
    async def clear(self):
        self._state = None
        self._data = {}

async def test_merch_creation_fsm_full_path(session: AsyncSession):
    admin_user_id = 1001
    state = MockFSMContext()
    callback_start = MockCallbackQuery(data="admin_create_merch", from_user_id=admin_user_id)
    await merch_handlers.start_merch_creation(callback_start, state)
    assert await state.get_state() == MerchCreation.awaiting_photo
    msg_photo = MockMessage(from_user_id=admin_user_id, photo=True)
    await merch_handlers.process_merch_photo(msg_photo, state)
    assert await state.get_state() == MerchCreation.awaiting_name
    msg_name = MockMessage(text="Крутая кружка", from_user_id=admin_user_id)
    await merch_handlers.process_merch_name(msg_name, state)
    assert await state.get_state() == MerchCreation.awaiting_description
    msg_desc = MockMessage(text="Очень крутая кружка для доноров", from_user_id=admin_user_id)
    await merch_handlers.process_merch_description(msg_desc, state)
    assert await state.get_state() == MerchCreation.awaiting_price
    msg_price = MockMessage(text="150", from_user_id=admin_user_id)
    await merch_handlers.process_merch_price(msg_price, state, session)
    assert await state.get_state() is None
    created_item = (await session.execute(select(MerchItem))).scalar_one_or_none()
    assert created_item is not None
    assert created_item.name == "Крутая кружка"

async def test_block_user_fsm_full_path(session: AsyncSession, mocker):
    mock_bot = Mock(spec=Bot)
    mock_bot.send_message = AsyncMock()
    main_admin = User(phone_number="+1", telegram_id=1001, full_name="Main Admin", university="Test")
    target_user = User(phone_number="+2", telegram_id=2002, full_name="Target User", university="Test")
    session.add_all([main_admin, target_user])
    await session.commit()
    state = MockFSMContext()
    callback_start = MockCallbackQuery(data=f"ma_block_user_{target_user.id}", from_user_id=main_admin.telegram_id)
    await user_handlers.block_user_from_card(callback_start, state)
    assert await state.get_state() == BlockUser.awaiting_reason
    msg_reason = MockMessage(text="Нарушение правил", from_user_id=main_admin.telegram_id)
    await user_handlers.process_block_reason(msg_reason, state, session, mock_bot)
    assert await state.get_state() is None
    await session.refresh(target_user)
    assert target_user.is_blocked is True
    mock_bot.send_message.assert_called_once()

async def test_manual_waiver_fsm_full_path(session: AsyncSession, mocker):
    mock_bot = Mock(spec=Bot)
    mock_bot.send_message = AsyncMock()
    admin = User(phone_number="+1", telegram_id=1001, full_name="Admin", university="Test")
    target_user = User(phone_number="+2", telegram_id=2002, full_name="Target User", university="Test")
    session.add_all([admin, target_user])
    await session.commit()
    state = MockFSMContext()
    callback_start = MockCallbackQuery(data=f"admin_waiver_{target_user.id}", from_user_id=admin.telegram_id)
    await user_handlers.set_waiver_start(callback_start, state)
    assert await state.get_state() == ManualWaiver.awaiting_end_date
    msg_date = MockMessage(text="01.01.2099", from_user_id=admin.telegram_id)
    await user_handlers.set_waiver_date(msg_date, state)
    assert await state.get_state() == ManualWaiver.awaiting_reason
    msg_reason = MockMessage(text="Медицинские показания", from_user_id=admin.telegram_id)
    await user_handlers.set_waiver_reason(msg_reason, state, session, mock_bot)
    assert await state.get_state() is None
    waiver_record = (await session.execute(select(MedicalWaiver))).scalar_one_or_none()
    assert waiver_record is not None
    mock_bot.send_message.assert_called_once()

async def test_user_search_fsm_full_path(session: AsyncSession):
    admin_id = 1001
    user_to_find = User(phone_number="+7123", telegram_id=123, full_name="Иванов Иван", university="Test")
    session.add(user_to_find)
    await session.commit()
    state = MockFSMContext()
    callback = MockCallbackQuery(data="admin_search_user", from_user_id=admin_id)
    await user_handlers.search_user_start(callback, state)
    assert await state.get_state() == UserSearch.awaiting_query
    message = MockMessage(text="Иванов", from_user_id=admin_id)
    await user_handlers.process_user_search(message, state, session)
    assert await state.get_state() is None
    message.answer.assert_called_once()
    args, kwargs = message.answer.call_args
    assert "Результаты поиска" in args[0]
    assert "Иванов Иван" in str(kwargs['reply_markup'])

async def test_event_editing_fsm_full_path(session: AsyncSession, mocker):
    admin_id = 1001
    event = Event(name="Старое Название", event_datetime=datetime.datetime.now(), location="Test", donation_type="d", points_per_donation=1, participant_limit=1)
    session.add(event)
    await session.commit()
    state = MockFSMContext()
    callback_start = MockCallbackQuery(data=f"admin_edit_event_{event.id}", from_user_id=admin_id)
    await event_handlers.start_event_editing(callback_start, state, session)
    assert await state.get_state() == EventEditing.choosing_field
    callback_choose_field = MockCallbackQuery(data="edit_field_name", from_user_id=admin_id)
    await event_handlers.choose_field_to_edit(callback_choose_field, state)
    assert await state.get_state() == EventEditing.awaiting_new_value
    message = MockMessage(text="Новое Шикарное Название", from_user_id=admin_id)
    await event_handlers.process_new_value_for_event(message, state, session)
    assert await state.get_state() is None
    await session.refresh(event)
    assert event.name == "Новое Шикарное Название"
    message.answer.assert_called_once_with("✅ Поле успешно обновлено!", reply_markup=mocker.ANY)

async def test_mailing_fsm_full_path(session: AsyncSession, mocker):
    mock_do_mailing = mocker.patch("bot.handlers.admin.mailing.do_mailing", new_callable=AsyncMock)
    admin = User(id=1001, phone_number="+1", telegram_id=1001, full_name="Admin", university="НИЯУ МИФИ", role="admin")
    user_mifi = User(id=1, phone_number="+2", telegram_id=1, full_name="User1", university="НИЯУ МИФИ", role="student")
    user_mgu = User(id=2, phone_number="+3", telegram_id=2, full_name="User2", university="МГУ", role="student")
    session.add_all([admin, user_mifi, user_mgu])
    await session.commit()
    state = MockFSMContext()
    cb_start = MockCallbackQuery(data="admin_mailing", from_user_id=admin.id)
    await mailing_handlers.start_mailing(cb_start, state)
    assert await state.get_state() == Mailing.awaiting_message_text
    msg_text = MockMessage(text="<b>Всем привет!</b>", from_user_id=admin.id)
    await mailing_handlers.get_mailing_text(msg_text, state)
    assert await state.get_state() == Mailing.awaiting_media
    msg_photo = MockMessage(from_user_id=admin.id, photo=True)
    await mailing_handlers.get_mailing_photo(msg_photo, state)
    assert await state.get_state() == Mailing.awaiting_audience_choice
    cb_choose_filter = MockCallbackQuery(data="mail_audience_type_university", from_user_id=admin.id)
    await mailing_handlers.choose_audience_filter_type(cb_choose_filter, state, session)
    cb_set_filter = MockCallbackQuery(data="mail_filter_university_НИЯУ МИФИ", from_user_id=admin.id)
    await mailing_handlers.set_audience_filter(cb_set_filter, state)
    cb_finish_audience = MockCallbackQuery(data="mail_audience_finish", from_user_id=admin.id)
    await mailing_handlers.finish_audience_selection(cb_finish_audience, state, session)
    assert await state.get_state() == Mailing.awaiting_confirmation
    cb_finish_audience.message.answer.assert_called_once()
    args, _ = cb_finish_audience.message.answer.call_args
    assert "<b>👥 Получателей:</b> 2" in args[0]
    assert "Прикреплено фото" in args[0]
    cb_confirm = MockCallbackQuery(data="confirm_mailing", from_user_id=admin.id)
    await mailing_handlers.confirm_and_start_mailing(cb_confirm, state, Mock(spec=Bot))
    assert await state.get_state() is None
    mock_do_mailing.assert_called_once()

async def test_admin_add_user_fsm_full_path(session: AsyncSession):
    """
    Тестирует полную FSM-цепочку ручного добавления пользователя администратором.
    """
    admin_user_id = 1001
    state = MockFSMContext()

    callback_start = MockCallbackQuery(data="admin_add_user_start", from_user_id=admin_user_id)
    await user_handlers.add_user_start(callback_start, state)
    assert await state.get_state() == AdminAddUser.awaiting_phone
    callback_start.message.edit_text.assert_called_once()

    await user_handlers.add_user_phone(MockMessage(text="+79876543210"), state, session)
    assert await state.get_state() == AdminAddUser.awaiting_full_name

    await user_handlers.add_user_full_name(MockMessage(text="Мануалов Мануал Мануалович"), state)
    assert await state.get_state() == AdminAddUser.awaiting_category

    await user_handlers.add_user_category(MockCallbackQuery(data="category_student"), state)
    assert await state.get_state() == AdminAddUser.awaiting_university
    
    await user_handlers.add_user_university(MockCallbackQuery(data="university_mifi"), state)
    assert await state.get_state() == AdminAddUser.awaiting_faculty

    await user_handlers.add_user_faculty(MockCallbackQuery(data="faculty_ИИКС"), state)
    assert await state.get_state() == AdminAddUser.awaiting_study_group

    await user_handlers.add_user_study_group(MockMessage(text="Б21-123"), state)
    assert await state.get_state() == AdminAddUser.awaiting_gender

    callback_gender = MockCallbackQuery(data="gender_male")
    await user_handlers.add_user_gender(callback_gender, state, session)
    
    assert await state.get_state() is None

    created_user = (await session.execute(
        select(User).where(User.phone_number == "+79876543210")
    )).scalar_one_or_none()

    assert created_user is not None
    assert created_user.full_name == "Мануалов Мануал Мануалович"
    assert created_user.university == "НИЯУ МИФИ"
    assert created_user.faculty == "ИИКС"
    assert created_user.study_group == "Б21-123"
    assert created_user.telegram_id == 0
    assert created_user.consent_given is True


async def test_edit_info_section_fsm(session: AsyncSession):
    """
    Тестирует FSM редактирования текста информационного раздела.
    """
    admin_user_id = 1001
    # Создаем тестовую запись в БД
    info_section = InfoText(
        section_key="prepare",
        section_title="Подготовка",
        section_text="Старый текст"
    )
    session.add(info_section)
    await session.commit()

    state = MockFSMContext()
    
    callback_start = MockCallbackQuery(data="admin_edit_info", from_user_id=admin_user_id)
    await info_handlers.start_info_editing(callback_start, state, session)
    assert await state.get_state() == EditInfoSection.choosing_section
    
    callback_choose = MockCallbackQuery(data="edit_info_prepare", from_user_id=admin_user_id)
    await info_handlers.choose_section_to_edit(callback_choose, state, session)
    assert await state.get_state() == EditInfoSection.awaiting_new_text
    
    new_text = "<b>Это новый, обновленный текст!</b>"
    message_new_text = MockMessage(text=new_text, from_user_id=admin_user_id)
    # Имитируем, что message.html_text содержит тот же текст
    message_new_text.html_text = new_text 
    await info_handlers.process_new_info_text(message_new_text, state, session)
    assert await state.get_state() is None

    await session.refresh(info_section) 
    assert info_section.section_text == new_text
    
    
    
      
async def test_post_event_processing_fsm(session: AsyncSession, mocker):
    """
    Тестирует полную FSM-цепочку обработки прошедшего мероприятия:
    - Выбор мероприятия
    - Отметка участников (сдал кровь / вступил в ДКМ)
    - Сохранение результатов в БД
    """
    # 1. ПОДГОТОВКА ДАННЫХ
    admin = User(phone_number="+0", telegram_id=1000, full_name="Admin", university="Test")
    user1 = User(phone_number="+1", telegram_id=1001, full_name="User One", university="Test", is_dkm_donor=False, points=0, gender="male")
    user2 = User(phone_number="+2", telegram_id=1002, full_name="User Two", university="Test", is_dkm_donor=False, points=0, gender="female")
    
    past_event = Event(
        name="Past Event", 
        event_datetime=datetime.datetime.now() - datetime.timedelta(days=5),
        location="Test", donation_type="whole_blood", points_per_donation=100, participant_limit=10
    )
    session.add_all([admin, user1, user2, past_event])
    await session.commit()
    
    # Регистрируем обоих пользователей на мероприятие
    reg1 = EventRegistration(user_id=user1.id, event_id=past_event.id)
    reg2 = EventRegistration(user_id=user2.id, event_id=past_event.id)
    session.add_all([reg1, reg2])
    await session.commit()

    state = MockFSMContext()
    
    # 2. ПРОХОЖДЕНИЕ FSM
    
    # --- Шаг 1: Выбор мероприятия ---
    callback_start = MockCallbackQuery(data=f"post_process_event_{past_event.id}", from_user_id=admin.telegram_id)
    await event_handlers.choose_event_for_processing(callback_start, state, session)
    assert await state.get_state() == PostEventProcessing.marking_participants
    
    # --- Шаг 2: Отмечаем участников ---
    # Пользователь 1: сдал кровь
    cb_mark1 = MockCallbackQuery(data=f"mark_participant_{past_event.id}_{user1.id}_donation", from_user_id=admin.telegram_id, message=callback_start.message)
    await event_handlers.mark_participant(cb_mark1, state, session)
    
    # Пользователь 2: сдал кровь
    cb_mark2_don = MockCallbackQuery(data=f"mark_participant_{past_event.id}_{user2.id}_donation", from_user_id=admin.telegram_id, message=callback_start.message)
    await event_handlers.mark_participant(cb_mark2_don, state, session)
    
    # Пользователь 2: вступил в ДКМ
    cb_mark2_dkm = MockCallbackQuery(data=f"mark_participant_{past_event.id}_{user2.id}_dkm", from_user_id=admin.telegram_id, message=callback_start.message)
    await event_handlers.mark_participant(cb_mark2_dkm, state, session)

    # Проверяем внутреннее состояние FSM
    fsm_data = await state.get_data()
    assert fsm_data["marked_donations"] == {user1.id, user2.id}
    assert fsm_data["marked_dkm"] == {user2.id}

    # --- Шаг 3: Завершаем и сохраняем ---
    callback_finish = MockCallbackQuery(data=f"finish_marking_{past_event.id}", from_user_id=admin.telegram_id, message=callback_start.message)
    await event_handlers.finish_marking(callback_finish, state, session)

    # 3. ПРОВЕРКА РЕЗУЛЬТАТОВ В БД
    assert await state.get_state() is None
    
    # Проверяем пользователя 1
    await session.refresh(user1)
    donations_user1 = (await session.execute(select(Donation).where(Donation.user_id == user1.id))).scalars().all()
    assert len(donations_user1) == 1
    assert user1.points == 100
    assert user1.is_dkm_donor is False # Не отмечали ДКМ

    # Проверяем пользователя 2
    await session.refresh(user2)
    donations_user2 = (await session.execute(select(Donation).where(Donation.user_id == user2.id))).scalars().all()
    assert len(donations_user2) == 1
    assert user2.points == 100
    assert user2.is_dkm_donor is True # Отмечали ДКМ

    

--- КОНЕЦ ФАЙЛА: tests/test_admin_fsm.py ---

--- НАЧАЛО ФАЙЛА: tests/test_analytics.py ---

# tests/test_analytics.py

import pytest
import datetime
from sqlalchemy.ext.asyncio import AsyncSession

# Правильный импорт из существующего модуля
from bot.db import analytics_requests
from bot.db.models import User, Donation, MedicalWaiver, Survey, Event, EventRegistration

pytestmark = pytest.mark.asyncio

# --- Тесты для функций из analytics_requests.py ---

async def test_get_churn_donors(session: AsyncSession):
    """
    Тест: Находит доноров-однодневок (1 донация, >6 мес. назад).
    """
    # Пользователь 1: подходит под условия
    user1 = User(id=1, full_name="Churn Donor", telegram_id=111, phone_number="111", university="Test")
    donation1 = Donation(user_id=1, donation_date=datetime.date.today() - datetime.timedelta(days=200), donation_type='whole_blood', points_awarded=10)
    
    # Пользователь 2: донация была недавно
    user2 = User(id=2, full_name="Active Donor", telegram_id=222, phone_number="222", university="Test")
    donation2 = Donation(user_id=2, donation_date=datetime.date.today() - datetime.timedelta(days=30), donation_type='whole_blood', points_awarded=10)
    
    # Пользователь 3: имеет несколько донаций
    user3 = User(id=3, full_name="Multiple Donor", telegram_id=333, phone_number="333", university="Test")
    donation3_1 = Donation(user_id=3, donation_date=datetime.date.today() - datetime.timedelta(days=200), donation_type='whole_blood', points_awarded=10)
    donation3_2 = Donation(user_id=3, donation_date=datetime.date.today() - datetime.timedelta(days=30), donation_type='plasma', points_awarded=10)

    session.add_all([user1, donation1, user2, donation2, user3, donation3_1, donation3_2])
    await session.commit()

    churn_donors = await analytics_requests.get_churn_donors(session)

    assert len(churn_donors) == 1
    assert churn_donors[0]['full_name'] == "Churn Donor"


async def test_get_lapsed_donors(session: AsyncSession):
    """
    Тест: Находит угасающих доноров (2+ донации, последняя >9 мес. назад, без медотвода).
    """
    # Пользователь 1: подходит под условия
    user1 = User(id=4, full_name="Lapsed Donor", telegram_id=444, phone_number="444", university="Test")
    d1_1 = Donation(user_id=4, donation_date=datetime.date.today() - datetime.timedelta(days=300), donation_type='whole_blood', points_awarded=10)
    d1_2 = Donation(user_id=4, donation_date=datetime.date.today() - datetime.timedelta(days=400), donation_type='whole_blood', points_awarded=10)

    # Пользователь 2: последняя донация была недавно
    user2 = User(id=5, full_name="Active Donor", telegram_id=555, phone_number="555", university="Test")
    d2_1 = Donation(user_id=5, donation_date=datetime.date.today() - datetime.timedelta(days=30), donation_type='whole_blood', points_awarded=10)
    d2_2 = Donation(user_id=5, donation_date=datetime.date.today() - datetime.timedelta(days=60), donation_type='plasma', points_awarded=10)

    # Пользователь 3: подходит по датам, но имеет активный медотвод
    user3 = User(id=6, full_name="Lapsed With Waiver", telegram_id=666, phone_number="666", university="Test")
    d3_1 = Donation(user_id=6, donation_date=datetime.date.today() - datetime.timedelta(days=300), donation_type='whole_blood', points_awarded=10)
    d3_2 = Donation(user_id=6, donation_date=datetime.date.today() - datetime.timedelta(days=400), donation_type='whole_blood', points_awarded=10)
    waiver = MedicalWaiver(user_id=6, start_date=datetime.date.today(), end_date=datetime.date.today() + datetime.timedelta(days=30), reason="test", created_by="system")

    session.add_all([user1, d1_1, d1_2, user2, d2_1, d2_2, user3, d3_1, d3_2, waiver])
    await session.commit()

    lapsed_donors = await analytics_requests.get_lapsed_donors(session)

    assert len(lapsed_donors) == 1
    assert lapsed_donors[0]['full_name'] == "Lapsed Donor"

async def test_get_survey_dropoff(session: AsyncSession):
    """
    Тест: Находит пользователей, прошедших опрос, но не записавшихся на мероприятие после этого.
    """
    # Пользователь 1: прошел опрос, не записался -> должен быть в списке
    user1 = User(id=38, full_name="Dropoff User", telegram_id=380, phone_number="380", university="Test")
    survey1 = Survey(user_id=38, passed=True, answers_json={}, created_at=datetime.datetime.now() - datetime.timedelta(days=10))

    # Пользователь 2: прошел опрос и записался ПОСЛЕ
    user2 = User(id=39, full_name="Registered User", telegram_id=390, phone_number="390", university="Test")
    survey2 = Survey(user_id=39, passed=True, answers_json={}, created_at=datetime.datetime.now() - datetime.timedelta(days=10))
    event1 = Event(name="event 1", event_datetime=datetime.datetime.now(), location="Центр крови", donation_type="d", points_per_donation=1, participant_limit=1)
    session.add(event1)
    await session.commit()
    reg2 = EventRegistration(user_id=39, event_id=event1.id, registration_date=datetime.datetime.now() - datetime.timedelta(days=5))

    # Пользователь 3: опрос не пройден
    user3 = User(id=40, full_name="Failed Survey User", telegram_id=400, phone_number="400", university="Test")
    survey3 = Survey(user_id=40, passed=False, answers_json={}, created_at=datetime.datetime.now() - datetime.timedelta(days=10))

    session.add_all([user1, survey1, user2, survey2, reg2, user3, survey3])
    await session.commit()
    
    dropoff_users = await analytics_requests.get_survey_dropoff(session)

    assert len(dropoff_users) == 1
    assert dropoff_users[0]['full_name'] == "Dropoff User"

--- КОНЕЦ ФАЙЛА: tests/test_analytics.py ---

--- НАЧАЛО ФАЙЛА: tests/test_calendar_service.py ---

import pytest
import datetime
from bot.utils.calendar_service import generate_ics_file
from bot.db.models import Event

def test_generate_ics_file():
    """
    Тестирует корректность генерации содержимого .ics файла.
    Адаптирован для ics==0.7.2, который конвертирует время в UTC.
    """
    # 1. Подготовка "фейкового" мероприятия.
    # Используем английский ключ, как в БД.
    mock_event = Event(
        id=123,
        name="Тестовое мероприятие",
        event_datetime=datetime.datetime(2025, 10, 26, 14, 0, 0), 
        location="НИЯУ МИФИ, Каширское ш. 31",
        donation_type="plasma" 
    )

    # 2. Генерация контента
    ics_string = generate_ics_file(mock_event)

    # 3. Проверки
    assert "BEGIN:VCALENDAR" in ics_string
    assert "SUMMARY:Донация: Тестовое мероприятие" in ics_string
    assert "LOCATION:НИЯУ МИФИ\\, Каширское ш. 31" in ics_string
    assert "DESCRIPTION:Тип донации: Плазма" in ics_string
    assert "DTSTART:20251026T110000Z" in ics_string
    assert "DTEND:20251026T130000Z" in ics_string

    # Проверяем наличие будильника
    assert "ACTION:DISPLAY" in ics_string
    assert "TRIGGER:-PT1H" in ics_string

--- КОНЕЦ ФАЙЛА: tests/test_calendar_service.py ---

--- НАЧАЛО ФАЙЛА: tests/test_db_requests.py ---

import pytest
import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from bot.db import user_requests, admin_requests, event_requests, merch_requests, info_requests
from bot.db.models import User, Event, EventRegistration, MedicalWaiver, Donation, MerchItem, UserBlock, MerchOrder, InfoText

# Маркируем все тесты в этом файле для pytest-asyncio
pytestmark = pytest.mark.asyncio

async def test_add_user_with_custom_university(session: AsyncSession):
    """
    Тестирует добавление пользователя с кастомным ВУЗом и его корректное сохранение.
    """
    # 1. Подготовка данных
    user_data = {
        "phone_number": "+79991112233",
        "telegram_id": 987654321,
        "telegram_username": "msu_student",
        "full_name": "Студент Другого ВУЗа",
        "university": "МГУ им. Ломоносова", 
        "faculty": "ВМК",
        "study_group": "101",
        "gender": "male"
    }

    # 2. Выполнение
    new_user = await user_requests.add_user(session, user_data)
    await session.commit()
    
    retrieved_user = await user_requests.get_user_by_tg_id(session, 987654321)

    # 3. Проверка
    assert new_user.id is not None
    assert retrieved_user is not None
    assert retrieved_user.full_name == "Студент Другого ВУЗа"
    assert retrieved_user.university == "МГУ им. Ломоносова" # Главная проверка
    assert retrieved_user.role == "student"


# --- НОВЫЙ ТЕСТ ДЛЯ ПРОВЕРКИ СОХРАНЕНИЯ КООРДИНАТ ---
async def test_create_event_with_location(session: AsyncSession):
    """
    Тестирует создание мероприятия с координатами и их корректное сохранение в БД.
    """
    # 1. Подготовка данных
    event_data = {
        "name": "Event with Location",
        "event_datetime": datetime.datetime(2030, 5, 20, 10, 0),
        "location": "НИЯУ МИФИ, Каширское ш. 31",
        "latitude": 55.649917,
        "longitude": 37.662128,
        "donation_type": "whole_blood",
        "points_per_donation": 100,
        "participant_limit": 50,
    }

    # 2. Выполнение
    new_event = await admin_requests.create_event(session, event_data)
    await session.commit()

    # 3. Проверка
    retrieved_event = await session.get(Event, new_event.id)
    assert retrieved_event is not None
    assert retrieved_event.name == "Event with Location"
    assert retrieved_event.latitude == 55.649917
    assert retrieved_event.longitude == 37.662128
# --- КОНЕЦ НОВОГО ТЕСТА ---


async def test_add_and_get_user(session: AsyncSession):
    """
    Тестирует добавление пользователя в БД и его последующее получение.
    """
    # 1. Подготовка данных
    user_data = {
        "phone_number": "+79991234567",
        "telegram_id": 123456789,
        "telegram_username": "testuser",
        "full_name": "Тестовый Пользователь",
        "university": "НИЯУ МИФИ",
    }

    # 2. Выполнение
    new_user = await user_requests.add_user(session, user_data)
    await session.commit()
    
    retrieved_user = await user_requests.get_user_by_tg_id(session, 123456789)

    # 3. Проверка
    assert new_user.id is not None
    assert retrieved_user is not None
    assert retrieved_user.full_name == "Тестовый Пользователь"
    assert retrieved_user.telegram_id == 123456789

async def test_find_user_for_admin(session: AsyncSession):
    """
    Тестирует поиск пользователя по разным критериям.
    """
    # 1. Подготовка (создаем несколько пользователей)
    users_to_add = [
        User(phone_number="+7001", telegram_id=1, telegram_username="john_doe", full_name="John Doe", university="A"),
        User(phone_number="+7002", telegram_id=2, telegram_username="jane_smith", full_name="Jane Smith", university="B"),
        User(phone_number="+7003", telegram_id=3, telegram_username="tester", full_name="Another Tester", university="C"),
    ]
    session.add_all(users_to_add)
    await session.commit()

    # 2. Выполнение и Проверка
    # Поиск по части ФИО
    found_by_name = await admin_requests.find_user_for_admin(session, "Smith")
    assert len(found_by_name) == 1
    assert found_by_name[0].full_name == "Jane Smith"

    # Поиск по username
    found_by_username = await admin_requests.find_user_for_admin(session, "john_doe")
    assert len(found_by_username) == 1
    assert found_by_username[0].telegram_id == 1

    # Поиск по ID
    found_by_id = await admin_requests.find_user_for_admin(session, "3")
    assert len(found_by_id) == 1
    assert found_by_id[0].full_name == "Another Tester"

    # Поиск по части телефона
    found_by_phone = await admin_requests.find_user_for_admin(session, "001")
    assert len(found_by_phone) == 1
    assert found_by_phone[0].telegram_id == 1

async def test_check_registration_eligibility(session: AsyncSession):
    """
    Тестирует логику проверки возможности регистрации на мероприятие.
    """
    # 1. Подготовка
    user = User(
        phone_number="+7111", telegram_id=111, full_name="Eligible User", gender="male",
        is_blocked=False, university="TestUni"
    )
    event = Event(
        name="Test Event",
        event_datetime=datetime.datetime.now() + datetime.timedelta(days=10),
        location="Тестовая локация, г. Москва",
        donation_type="whole_blood",
        participant_limit=5,
        registration_is_open=True,
        points_per_donation=10
    )
    session.add_all([user, event])
    await session.commit()

    # 2. Выполнение и Проверка
    # Сценарий 1: Успешная регистрация
    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    assert is_eligible is True
    assert "пройдены" in reason

    # Сценарий 2: Регистрация закрыта
    event.registration_is_open = False
    await session.commit()
    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    assert is_eligible is False
    assert "закрыта" in reason
    event.registration_is_open = True 
    await session.commit()

    # Сценарий 3: Пользователь уже зарегистрирован
    reg = EventRegistration(user_id=user.id, event_id=event.id)
    session.add(reg)
    await session.commit()
    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    assert is_eligible is False
    assert "уже зарегистрированы" in reason
    await session.delete(reg) 
    await session.commit()

    # Сценарий 4: У пользователя есть медотвод
    waiver = MedicalWaiver(
        user_id=user.id,
        start_date=datetime.date.today(),
        end_date=datetime.date.today() + datetime.timedelta(days=30), 
        reason="Test Waiver",
        created_by="system"
    )
    session.add(waiver)
    await session.commit()
    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    assert is_eligible is False
    assert "действует отвод" in reason


# --- НОВЫЕ ТЕСТЫ ---

async def test_change_user_role(session: AsyncSession):
    """Тестирует повышение и понижение роли пользователя."""
    # 1. Подготовка
    user = User(phone_number="+7111", telegram_id=111, full_name="Test User", role="student", university="TestUni")
    session.add(user)
    await session.commit()

    # 2. Повышаем до волонтера
    await admin_requests.change_user_role(session, user.id, "volunteer")
    
    # 3. Проверяем
    updated_user_1 = await session.get(User, user.id)
    assert updated_user_1.role == "volunteer"

    # 4. Понижаем до студента
    await admin_requests.change_user_role(session, user.id, "student")

    # 5. Проверяем
    updated_user_2 = await session.get(User, user.id)
    assert updated_user_2.role == "student"


async def test_block_and_unblock_user(session: AsyncSession):
    """Тестирует блокировку и разблокировку пользователя."""
    # 1. Подготовка
    admin = User(phone_number="+7_admin", telegram_id=999, full_name="Admin", university="TestUni")
    target_user = User(phone_number="+7_target", telegram_id=123, full_name="Target", university="TestUni")
    session.add_all([admin, target_user])
    await session.commit()

    # 2. Блокируем пользователя
    await admin_requests.block_user(session, target_user.id, admin.id, "Test block reason")
    
    # 3. Проверяем
    blocked_user = await session.get(User, target_user.id)
    block_record = (await session.execute(select(UserBlock))).scalar_one_or_none()
    assert blocked_user.is_blocked is True
    assert block_record is not None
    assert block_record.reason == "Test block reason"
    assert block_record.is_active is True

    # 4. Разблокируем
    await admin_requests.unblock_user(session, target_user.id)
    
    # 5. Проверяем
    unblocked_user = await session.get(User, target_user.id)
    await session.refresh(block_record) # Обновляем запись о блокировке из БД
    assert unblocked_user.is_blocked is False
    assert block_record.is_active is False


async def test_confirm_donation_transaction(session: AsyncSession):
    """Тестирует полную транзакцию подтверждения донации."""
    # 1. Подготовка
    user = User(phone_number="+7", telegram_id=1, full_name="Donor", gender="male", points=0, university="TestUni")
    event_date = datetime.date.today()
    event_dt = datetime.datetime.combine(event_date, datetime.time.min)
    event = Event(
        name="Transaction Test Event",
        event_datetime=event_dt,
        location="Test",
        donation_type="whole_blood",
        points_per_donation=50,
        participant_limit=5
    )
    session.add_all([user, event])
    await session.commit()
    registration = EventRegistration(user_id=user.id, event_id=event.id)
    session.add(registration)
    await session.commit()

    # 2. Выполнение
    points, waiver_end_date = await event_requests.confirm_donation_transaction(session, user, registration)
    
    # 3. Проверка
    # Проверяем начисление баллов
    updated_user = await session.get(User, user.id)
    assert points == 50
    assert updated_user.points == 50
    
    # Проверяем запись о донации
    donation = (await session.execute(select(Donation))).scalar_one()
    assert donation.user_id == user.id
    assert donation.points_awarded == 50
    
    # Проверяем создание медотвода
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one()
    expected_end_date = event_date + datetime.timedelta(days=60) # 60 дней для мужчины
    assert waiver.end_date == expected_end_date
    assert waiver_end_date == expected_end_date
    assert waiver.created_by == "system"

    # Проверяем статус регистрации
    updated_reg = await session.get(EventRegistration, registration.id)
    assert updated_reg.status == "attended"


async def test_create_merch_order_success_and_fail(session: AsyncSession):
    """Тестирует успешное создание заказа и отказ при нехватке баллов."""
    # 1. Подготовка
    user_rich = User(phone_number="+1", telegram_id=1, full_name="Rich", points=100, university="TestUni")
    user_poor = User(phone_number="+2", telegram_id=2, full_name="Poor", points=10, university="TestUni")
    item = MerchItem(name="Test Mug", description="A mug", price=50, photo_file_id="123")
    session.add_all([user_rich, user_poor, item])
    await session.commit()

    # 2. Успешная покупка
    success, msg = await merch_requests.create_merch_order(session, user_rich, item)
    await session.commit()

    # 3. Проверка успешной покупки
    order = (await session.execute(select(MerchOrder).where(MerchOrder.user_id == user_rich.id))).scalar_one()
    assert success is True
    assert "Покупка совершена" in msg
    assert user_rich.points == 50
    assert order is not None

    # 4. Неуспешная покупка
    success_fail, msg_fail = await merch_requests.create_merch_order(session, user_poor, item)
    await session.commit()

    # 5. Проверка неуспешной покупки
    order_fail = (await session.execute(select(MerchOrder).where(MerchOrder.user_id == user_poor.id))).scalar_one_or_none()
    assert success_fail is False
    assert "Недостаточно баллов" in msg_fail
    assert user_poor.points == 10 # Баллы не должны были списаться
    assert order_fail is None


async def test_user_can_delete_own_waiver_but_not_system(session: AsyncSession):
    """
    Тестирует, что пользователь может удалить свой медотвод, но не системный.
    """
    # 1. Подготовка
    user = User(phone_number="+1", telegram_id=1, full_name="Waiver User", university="TestUni")
    session.add(user)
    await session.commit()

    # --- ИЗМЕНЕНИЕ: ДОБАВЛЯЕМ start_date ---
    today = datetime.date.today()
    waiver_by_user = MedicalWaiver(
        user_id=user.id,
        start_date=today, # <-- Добавлено
        end_date=datetime.date.max,
        reason="self",
        created_by="user"
    )
    waiver_by_system = MedicalWaiver(
        user_id=user.id,
        start_date=today, # <-- Добавлено
        end_date=datetime.date.max,
        reason="donation",
        created_by="system"
    )
    # ----------------------------------------
    
    session.add_all([waiver_by_user, waiver_by_system])
    await session.commit()
    
    # 2. Выполнение и проверка
    # Пытаемся удалить свой
    can_delete_own = await user_requests.delete_user_waiver(session, waiver_by_user.id, user.id)
    assert can_delete_own is True
    
    # Пытаемся удалить системный
    can_delete_system = await user_requests.delete_user_waiver(session, waiver_by_system.id, user.id)
    assert can_delete_system is False

    # Проверяем, что в БД остался только системный
    remaining_waivers = (await session.execute(select(MedicalWaiver))).scalars().all()
    assert len(remaining_waivers) == 1
    assert remaining_waivers[0].id == waiver_by_system.id
    
@pytest.mark.parametrize(
    "user_data, donations, waivers, expected_in_list",
    [
        # Сценарий 1: Чистый пользователь, должен попасть в рассылку
        ({"gender": "male", "id": 1, "tg_id": 1}, [], [], True),
        
        # Сценарий 2: Пользователь с активным медотводом, НЕ должен попасть
        ({"gender": "male", "id": 2, "tg_id": 2}, [], [{"days_ago": 10, "duration": 30}], False),
        
        # Сценарий 3: Мужчина, сдача крови < 60 дней назад, НЕ должен попасть
        ({"gender": "male", "id": 3, "tg_id": 3}, [{"type": "whole_blood", "days_ago": 45}], [], False),
        
        # Сценарий 4: Мужчина, сдача крови > 60 дней назад, должен попасть
        ({"gender": "male", "id": 4, "tg_id": 4}, [{"type": "whole_blood", "days_ago": 70}], [], True),
        
        # Сценарий 5: Женщина, сдача крови 80 дней назад. Интервал 90 дней. 80+15=95 > 90. ДОЛЖНА ПОПАСТЬ.
        ({"gender": "female", "id": 5, "tg_id": 5}, [{"type": "whole_blood", "days_ago": 80}], [], True), 

        # Сценарий 6: Женщина, сдача крови 100 дней назад. ДОЛЖНА ПОПАСТЬ.
        ({"gender": "female", "id": 6, "tg_id": 6}, [{"type": "whole_blood", "days_ago": 100}], [], True),

        # Сценарий 7: Сдача плазмы 10 дней назад. Интервал 14 дней. 10+15=25 > 14. ДОЛЖЕН ПОПАСТЬ.
        ({"gender": "male", "id": 7, "tg_id": 7}, [{"type": "plasma", "days_ago": 10}], [], True),
        
        # Сценарий 8: Сдача компонентов > 14 дней назад, должен попасть
        ({"gender": "male", "id": 8, "tg_id": 8}, [{"type": "plasma", "days_ago": 20}], [], True),

        # Сценарий 9: Мужчина, достиг лимита (5) по цельной крови, НЕ должен попасть
        ({"gender": "male", "id": 9, "tg_id": 9}, [{"type": "whole_blood", "days_ago": d} for d in [70, 140, 210, 280, 350]], [], False),

        # Сценарий 10: Пользователь со старым медотводом, должен попасть
        ({"gender": "male", "id": 10, "tg_id": 10}, [], [{"days_ago": 100, "duration": 30}], True),
    ]
)
async def test_get_users_for_event_notification(session: AsyncSession, user_data, donations, waivers, expected_in_list):
    """
    Тестирует сложную логику фильтрации пользователей для уведомления о новом мероприятии.
    Использует параметризацию для проверки множества сценариев.
    """
    # 1. Подготовка
    today = datetime.date.today()
    
    # Создаем тестовое мероприятие для сдачи цельной крови через 15 дней
    event = Event(
        name="Notification Test Event",
        event_datetime=datetime.datetime.now() + datetime.timedelta(days=15),
        location="Test",
        donation_type="whole_blood",
        points_per_donation=10,
        participant_limit=100
    )
    
    # Создаем пользователя
    user = User(
        id=user_data["id"],
        telegram_id=user_data["tg_id"],
        phone_number=f"+{user_data['id']}",
        full_name=f"User {user_data['id']}",
        gender=user_data["gender"],
        university="TestUni"
    )
    session.add(user)

    # Создаем его историю донаций
    for don in donations:
        donation = Donation(
            user_id=user.id,
            donation_type=don["type"],
            donation_date=today - datetime.timedelta(days=don["days_ago"]),
            points_awarded=10
        )
        session.add(donation)
    
    # Создаем его историю медотводов
    for wav in waivers:
        waiver = MedicalWaiver(
            user_id=user.id,
            start_date=today - datetime.timedelta(days=wav["days_ago"]),
            end_date=today - datetime.timedelta(days=wav["days_ago"]) + datetime.timedelta(days=wav["duration"]),
            reason="test",
            created_by="system"
        )
        session.add(waiver)
        
    await session.commit()

    # 2. Выполнение
    users_to_notify = await user_requests.get_users_for_event_notification(session, event)
    user_ids_to_notify = {u.id for u in users_to_notify}

    # 3. Проверка
    if expected_in_list:
        assert user.id in user_ids_to_notify, f"User {user.id} should be in the list but was NOT"
    else:
        assert user.id not in user_ids_to_notify, f"User {user.id} should NOT be in the list but was"
        
        
async def test_admin_create_manual_waiver(session: AsyncSession):
    """
    Тестирует создание медотвода администратором.
    """
    # 1. Подготовка
    admin = User(phone_number="+1", telegram_id=101, full_name="Admin", university="TestUni")
    user = User(phone_number="+2", telegram_id=102, full_name="User", university="TestUni")
    session.add_all([admin, user])
    await session.commit()
    
    end_date = datetime.date.today() + datetime.timedelta(days=30)
    
    # 2. Выполнение
    await admin_requests.create_manual_waiver(session, user_id=user.id, end_date=end_date, reason="Manual by admin", admin_id=admin.id)
    
    # 3. Проверка
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one_or_none()
    
    assert waiver is not None
    assert waiver.user_id == user.id
    assert waiver.reason == "Manual by admin"
    # Проверяем, что ID админа записался как строка
    assert waiver.created_by == str(admin.id)
    
    
async def test_create_event_with_datetime(session: AsyncSession):
    """
    Тестирует создание мероприятия с датой и временем и их корректное сохранение.
    """
    event_dt = datetime.datetime(2030, 11, 25, 15, 30)
    event_data = {
        "name": "Event with Time",
        "event_datetime": event_dt,
        "location": "НИЯУ МИФИ",
        "donation_type": "platelets",
        "points_per_donation": 200,
        "participant_limit": 20,
    }

    new_event = await admin_requests.create_event(session, event_data)
    await session.commit()

    retrieved_event = await session.get(Event, new_event.id)
    assert retrieved_event is not None
    assert retrieved_event.name == "Event with Time"
    assert retrieved_event.event_datetime == event_dt
    
    
async def test_update_info_text(session: AsyncSession):
    """
    Тестирует прямое обновление текста инфо-раздела через DB-запрос.
    """
    # 1. Подготовка
    section_key = "test_section"
    original_text = "This is the original text."
    new_text = "This is the updated text."
    
    session.add(InfoText(
        section_key=section_key, 
        section_title="Test Section", 
        section_text=original_text
    ))
    await session.commit()
    
    # 2. Выполнение
    await info_requests.update_info_text(session, section_key, new_text)
    
    # 3. Проверка
    updated_section = await session.get(InfoText, section_key)
    assert updated_section is not None
    assert updated_section.section_text == new_text

--- КОНЕЦ ФАЙЛА: tests/test_db_requests.py ---

--- НАЧАЛО ФАЙЛА: tests/test_filters.py ---

import pytest
from unittest.mock import Mock
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db.models import User
from bot.filters.role import RoleFilter

# Маркируем все тесты в этом файле для pytest-asyncio
pytestmark = pytest.mark.asyncio

# Создадим "заглушку" для объекта CallbackQuery, чтобы не импортировать aiogram
class MockUser:
    def __init__(self, id):
        self.id = id

class MockCallback:
    def __init__(self, user_id):
        self.from_user = MockUser(id=user_id)

async def test_role_filter(session: AsyncSession):
    """
    Тестирует логику фильтра RoleFilter для разных ролей и статусов.
    """
    # 1. Подготовка: создаем пользователей с разными ролями
    # --- ИСПРАВЛЕНИЕ: Добавляем обязательное поле university ---
    student = User(phone_number="+1", telegram_id=101, full_name="Student", role="student", university="TestUni")
    volunteer = User(phone_number="+2", telegram_id=102, full_name="Volunteer", role="volunteer", university="TestUni")
    admin = User(phone_number="+3", telegram_id=103, full_name="Admin", role="admin", university="TestUni")
    main_admin = User(phone_number="+4", telegram_id=104, full_name="Main Admin", role="main_admin", university="TestUni")
    blocked_admin = User(phone_number="+5", telegram_id=105, full_name="Blocked Admin", role="admin", is_blocked=True, university="TestUni")
    # --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    session.add_all([student, volunteer, admin, main_admin, blocked_admin])
    await session.commit()

    # 2. Выполнение и Проверка
    
    # --- Проверяем доступ к "admin" уровню ---
    admin_filter = RoleFilter(required_role="admin")
    
    # Студент не должен пройти
    assert not await admin_filter(MockCallback(user_id=101), session)
    # Волонтер не должен пройти
    assert not await admin_filter(MockCallback(user_id=102), session)
    # Админ должен пройти
    assert await admin_filter(MockCallback(user_id=103), session)
    # Главный админ тоже должен пройти (иерархия)
    assert await admin_filter(MockCallback(user_id=104), session)
    # Заблокированный админ не должен пройти
    assert not await admin_filter(MockCallback(user_id=105), session)
    # Несуществующий пользователь не должен пройти
    assert not await admin_filter(MockCallback(user_id=999), session)

    # --- Проверяем доступ к "volunteer" уровню ---
    volunteer_filter = RoleFilter(required_role="volunteer")
    
    # Студент не должен пройти
    assert not await volunteer_filter(MockCallback(user_id=101), session)
    # Волонтер должен пройти
    assert await volunteer_filter(MockCallback(user_id=102), session)
    # Админ должен пройти (иерархия)
    assert await volunteer_filter(MockCallback(user_id=103), session)

--- КОНЕЦ ФАЙЛА: tests/test_filters.py ---

--- НАЧАЛО ФАЙЛА: tests/test_graduation.py ---

import pytest
from bot.utils.graduation import calculate_graduation_year

@pytest.mark.parametrize(
    "group, expected_year",
    [
        ("Б20-505", 2024),
        ("С20-2131", 2025),
        ("М22-1232", 2024),
        ("b20-505", 2024),
        ("c20-2131", 2025),
        ("m22-1232", 2024),
        ("asdf", None),
        (None, None),
        ("", None),
    ],
)
def test_calculate_graduation_year(group, expected_year):
    assert calculate_graduation_year(group) == expected_year


--- КОНЕЦ ФАЙЛА: tests/test_graduation.py ---

--- НАЧАЛО ФАЙЛА: tests/test_handlers_logic.py ---

import pytest
from unittest.mock import AsyncMock, Mock
import datetime

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram import Bot, types
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage

from bot.db.models import User, Event, MedicalWaiver, Feedback
from bot.states.states import Registration, EventCreation, PointsChange, FeedbackSurvey
from bot.handlers import common as common_handlers
from bot.handlers.admin import event_management
from bot.handlers.admin import user_management as user_management_handlers
from bot.handlers import student as student_handlers
from bot.keyboards import inline
from bot.utils.text_messages import Text

pytestmark = pytest.mark.asyncio

class MockMessage:
    """Полностью контролируемая заглушка для Message, не наследуется от Mock."""
    def __init__(self, text=None, from_user_id=123, from_user_username=None, location=None, contact=None):
        self.text = text
        self.from_user = Mock(id=from_user_id, username=from_user_username)
        self.location = location
        self.contact = contact
        self.message_id = 12345
        # Явно определяем все методы, которые могут быть вызваны
        self.answer = AsyncMock()
        self.edit_text = AsyncMock()
        self.delete = AsyncMock()
        self.answer_photo = AsyncMock()
        self.answer_document = AsyncMock()
        self.edit_reply_markup = AsyncMock()

class MockCallbackQuery:
    """Полностью контролируемая заглушка для CallbackQuery."""
    def __init__(self, data, from_user_id=123, from_user_username=None, message=None):
        self.data = data
        self.from_user = Mock(id=from_user_id, username=from_user_username)
        self.message = message if message else MockMessage(from_user_id=from_user_id)
        self.answer = AsyncMock()

class MockFSMContext:
    """Упрощенная заглушка для FSMContext, хранящая состояние в словаре"""
    def __init__(self):
        self._state = None
        self._data = {}
    async def get_state(self): return self._state
    async def set_state(self, state): self._state = state
    async def get_data(self): return self._data.copy()
    async def update_data(self, **kwargs): self._data.update(kwargs)
    async def clear(self):
        self._state = None
        self._data = {}

class MockLocation:
    """Упрощенная заглушка для объекта Location aiogram"""
    def __init__(self, latitude, longitude):
        self.latitude = latitude
        self.longitude = longitude



@pytest.mark.parametrize(
    "scenario, user_inputs, expected_fsm_data",
    [
        (
            "mifi_standard_faculty",
            [
                ("callback", "category_student"),
                ("callback", "university_mifi"), 
                ("callback", "faculty_ИИКС"),
                ("message", "Б20-505"),
                ("callback", "gender_male"),
                ("callback", "consent_given"),
            ],
            {"category": "student", "university": "НИЯУ МИФИ", "faculty": "ИИКС", "study_group": "Б20-505"}
        ),
        (
            "mifi_custom_faculty",
            [
                ("callback", "category_employee"),
                ("callback", "university_mifi"),
                ("callback", "faculty_Other"),
                ("message", "Институт ЛаПлаз"),
                ("message", "Л2-101"),
                ("callback", "gender_female"),
                ("callback", "consent_given"),
            ],
            {"category": "employee", "university": "НИЯУ МИФИ", "faculty": "Институт ЛаПлаз", "study_group": "Л2-101"}
        ),
        (
            "other_university_external_donor",
            [
                ("callback", "category_external"),
                ("callback", "gender_male"),
                ("callback", "consent_given"),
            ],
            {
                "category": "external",
                "university": "Внешний донор", 
                "faculty": "Не применимо", 
                "study_group": "-"
            }
        )
    ]
)
async def test_registration_fsm_scenarios(scenario, user_inputs, expected_fsm_data, session: AsyncSession):
    """
    Тестирует различные сценарии прохождения регистрации FSM (ОБНОВЛЕННАЯ ВЕРСИЯ).
    """
    state = MockFSMContext()
    
    contact_mock = Mock(phone_number="+71234567890")
    start_message = MockMessage(contact=contact_mock, from_user_id=123, from_user_username="test_user_fsm")
    await common_handlers.handle_contact(start_message, session, state)
    assert await state.get_state() == Registration.awaiting_full_name
    
    fio_message = MockMessage("Тестовый Тест Тестович")
    await common_handlers.process_full_name(fio_message, state)
    assert await state.get_state() == Registration.awaiting_category
    

    for input_type, value in user_inputs:
        current_state_before = await state.get_state()
        
        if input_type == "callback":
            callback = MockCallbackQuery(data=value)
            
            if current_state_before == Registration.awaiting_category:
                await common_handlers.process_category(callback, state)
            elif current_state_before == Registration.awaiting_university:
                await common_handlers.process_university_choice(callback, state)
            elif current_state_before == Registration.awaiting_faculty:
                await common_handlers.process_faculty(callback, state)
            elif current_state_before == Registration.awaiting_gender:
                await common_handlers.process_gender(callback, state)
            elif current_state_before == Registration.awaiting_consent:
                await common_handlers.process_consent(callback, state, session)
        
        elif input_type == "message":
            message = MockMessage(text=value)
            
            if current_state_before == Registration.awaiting_custom_university_name:
                await common_handlers.process_custom_university_name(message, state)
            elif current_state_before == Registration.awaiting_custom_faculty_name:
                await common_handlers.process_custom_faculty_name(message, state)
            elif current_state_before == Registration.awaiting_study_group:
                await common_handlers.process_study_group(message, state)
                
    assert await state.get_state() is None 
    
    created_user = (await session.execute(select(User).where(User.telegram_id == 123))).scalar_one()
    assert created_user is not None
    assert created_user.university == expected_fsm_data["university"]
    assert created_user.faculty == expected_fsm_data["faculty"]
    assert created_user.study_group == expected_fsm_data["study_group"]
    assert created_user.category == expected_fsm_data["category"]
    assert created_user.consent_given is True
    assert created_user.full_name == "Тестовый Тест Тестович"
    assert created_user.telegram_username == "test_user_fsm"


async def test_add_points_to_user(session: AsyncSession, mocker):
    """
    Тестирует логику добавления баллов администратором, включая уведомление.
    """
    mock_bot = Mock()
    mock_bot.send_message = AsyncMock()
    
    user = User(phone_number="+1", telegram_id=101, full_name="User For Points", points=100, university="TestUni")
    session.add(user)
    await session.commit()
    
    state = MockFSMContext()
    await state.set_state(PointsChange.awaiting_reason)
    await state.update_data(user_id=user.id, points=50)
    
    msg_reason = MockMessage("За хорошую работу")
    await user_management_handlers.change_points_reason(msg_reason, state, session, mock_bot)
    
    await session.refresh(user)
    assert user.points == 150
    
    mock_bot.send_message.assert_called_once()
    call_args = mock_bot.send_message.call_args
    assert call_args.kwargs['chat_id'] == user.telegram_id
    assert "изменил ваш баланс на 50" in call_args.kwargs['text']
    assert call_args.kwargs['parse_mode'] == "HTML"


async def test_user_receives_location_link_on_registration(session: AsyncSession, mocker):
    """
    Тестирует, что пользователь получает кликабельную ссылку на локацию
    в сообщении после успешной регистрации на мероприятие с координатами.
    """
    # 1. Подготовка
    mock_callback_message = MockMessage()
    mock_callback_message.edit_text = AsyncMock()

    user = User(phone_number="+1", telegram_id=101, full_name="Location User", university="TestUni")
    event = Event(
        name="Event With Coords",
        event_datetime=datetime.datetime.now() + datetime.timedelta(days=5),
        location="Москва, ул. Пушкина, д. Колотушкина",
        latitude=55.123,
        longitude=37.456,
        donation_type="plasma",
        points_per_donation=1,
        participant_limit=10,
        registration_is_open=True
    )
    session.add_all([user, event])
    await session.commit()
    
    callback = MockCallbackQuery(
        data=f"reg_event_{event.id}",
        from_user_id=user.telegram_id,
        message=mock_callback_message
    )
    
    # 2. Выполнение
    await student_handlers.process_event_registration(callback, session)

    # 3. Проверка
    mock_callback_message.edit_text.assert_called_once()
    call_args = mock_callback_message.edit_text.call_args.kwargs
    sent_text = call_args['text']
    
    expected_link_part = f'href="https://yandex.ru/maps/?pt={event.longitude},{event.latitude}&z=18&l=map"'
    assert expected_link_part in sent_text
    
    assert ">Москва, ул. Пушкина, д. Колотушкина</a>" in sent_text
    assert call_args['parse_mode'] == "HTML"


async def test_add_to_calendar_handler(session: AsyncSession, mocker):
    """
    Тестирует, что хендлер 'add_to_calendar' корректно формирует и отправляет .ics файл.
    """
    user = User(phone_number="+987", telegram_id=987, full_name="Calendar User", university="Test")
    event = Event(
        name="Calendar Event",
        event_datetime=datetime.datetime.now(),
        location="Test Location",
        donation_type="blood", points_per_donation=1, participant_limit=1
    )
    session.add_all([user, event])
    await session.commit()

    mock_message = MockMessage()
    mock_message.answer_document = AsyncMock()

    callback = MockCallbackQuery(
        data=f"add_to_calendar_{event.id}",
        from_user_id=user.telegram_id,
        message=mock_message
    )

    await student_handlers.send_calendar_file(callback, session)

    mock_message.answer_document.assert_called_once()
    
    call_args = mock_message.answer_document.call_args.kwargs
    document = call_args['document']
    
    assert "Календарный файл" in call_args['caption']
    assert f"event_{event.id}.ics" == document.filename
    
    mock_bot = Mock(spec=Bot)
    
    file_chunks = []
    async for chunk in document.read(bot=mock_bot):
        file_chunks.append(chunk)
    
    file_content_bytes = b"".join(file_chunks)
    file_content = file_content_bytes.decode('utf-8')

    assert "BEGIN:VCALENDAR" in file_content
    assert "SUMMARY:Донация: Calendar Event" in file_content
    
async def test_feedback_survey_fsm_full_pass(session: AsyncSession, mocker):
    """
    Тестирует полную цепочку FSM опроса с заполнением всех полей.
    """
    # 1. Подготовка
    user = User(phone_number="+1", telegram_id=101, full_name="Feedback User", university="TestUni")
    session.add(user)
    await session.commit()

    state = MockFSMContext()
    await state.set_state(FeedbackSurvey.awaiting_well_being)
    await state.update_data(event_id=1, donation_id=1)

    mock_message_to_edit = MockMessage()

    # 2. Прохождение FSM
    # Шаг 1: Оценка самочувствия
    cb_wb = MockCallbackQuery(data="fb_wb_5", from_user_id=user.telegram_id, message=mock_message_to_edit)
    await student_handlers.process_well_being(cb_wb, state)
    assert await state.get_state() == FeedbackSurvey.awaiting_organization_score

    # Шаг 2: Оценка организации
    cb_org = MockCallbackQuery(data="fb_org_9", from_user_id=user.telegram_id, message=mock_message_to_edit)
    await student_handlers.process_org_score(cb_org, state)
    assert await state.get_state() == FeedbackSurvey.awaiting_what_liked

    # Шаг 3: Что понравилось (отвечаем текстом)
    msg_liked = MockMessage(text="Вкусный чай", from_user_id=user.telegram_id)
    await student_handlers.process_what_liked(msg_liked, state)
    assert await state.get_state() == FeedbackSurvey.awaiting_what_disliked

    # Шаг 4: Что не понравилось (пропускаем)
    cb_skip_disliked = MockCallbackQuery(data="fb_skip_step", from_user_id=user.telegram_id, message=mock_message_to_edit)
    await student_handlers.process_what_disliked(cb_skip_disliked, state)
    assert await state.get_state() == FeedbackSurvey.awaiting_other_suggestions

    # Шаг 5: Предложения (отвечаем текстом)
    msg_suggestions = MockMessage(text="Давать больше печенья", from_user_id=user.telegram_id)
    await student_handlers.process_other_suggestions(msg_suggestions, state, session)

    # 3. Проверка
    assert await state.get_state() is None

    feedback_entry = (await session.execute(select(Feedback))).scalar_one_or_none()
    assert feedback_entry is not None
    assert feedback_entry.user_id == user.id
    assert feedback_entry.event_id == 1
    assert feedback_entry.well_being_score == 5
    assert feedback_entry.well_being_comment is None
    assert feedback_entry.organization_score == 9
    assert feedback_entry.what_liked == "Вкусный чай"
    assert feedback_entry.what_disliked == "Пропущено"
    assert feedback_entry.other_suggestions == "Давать больше печенья"

async def test_admin_can_view_feedback(session: AsyncSession):
    """
    Тестирует функцию просмотра отзывов администратором.
    """
    admin = User(phone_number="+0", telegram_id=100, full_name="Admin", university="TestUni")
    user1 = User(phone_number="+1", telegram_id=101, full_name="User One", university="TestUni")
    event = Event(name="Event With Feedback", event_datetime=datetime.datetime.now(), location="Loc", donation_type="d", points_per_donation=1, participant_limit=1)
    session.add_all([admin, user1, event])
    await session.commit()

    fb1 = Feedback(user_id=user1.id, event_id=event.id, organization_score=10, what_liked="Всё")
    session.add(fb1)
    await session.commit()

    mock_message = MockMessage()
    callback = MockCallbackQuery(data=f"admin_view_feedback_{event.id}", from_user_id=admin.telegram_id, message=mock_message)

    await event_management.view_event_feedback(callback, session)

    # Проверяем, что исходное сообщение было отредактировано
    mock_message.answer.assert_called_once()
    
    # Проверяем содержимое отредактированного сообщения
    call_args = mock_message.answer.call_args
    sent_text = call_args.args[0]
    
    assert "Отзывы по мероприятию" in sent_text
    assert "Event With Feedback" in sent_text
    assert "User One" in sent_text
    assert "Всё" in sent_text

@pytest.mark.asyncio
async def test_process_category_external_donor():
    # Arrange
    storage = MemoryStorage()
    state = FSMContext(storage, key=Mock(bot_id=1, chat_id=1, user_id=1))

    message = Mock(
        edit_text=AsyncMock()
    )
    callback = Mock(
        data="category_external",
        message=message,
        answer=AsyncMock()
    )

    # Act
    await common_handlers.process_category(callback, state)

    # Assert
    data = await state.get_data()
    assert data['category'] == 'external'
    assert data['university'] == 'Внешний донор'
    assert data['faculty'] == 'Не применимо'
    assert data['study_group'] == '-'

    current_state = await state.get_state()
    assert current_state == Registration.awaiting_gender

    message.edit_text.assert_called_once_with(
        Text.GET_GENDER,
        reply_markup=inline.get_gender_inline_keyboard()
    )
    callback.answer.assert_called_once()

--- КОНЕЦ ФАЙЛА: tests/test_handlers_logic.py ---

--- НАЧАЛО ФАЙЛА: tests/test_keyboards.py ---

import pytest
from bot.keyboards import inline

def get_button_texts(keyboard):
    """Вспомогательная функция для извлечения текста со всех кнопок."""
    return [button.text for row in keyboard.inline_keyboard for button in row]

def test_get_student_main_menu():
    """Тестирует, что в меню студента есть правильные кнопки, в т.ч. для админа."""
    # Сценарий 1: Обычный студент
    student_keyboard = inline.get_student_main_menu(viewer_role='student')
    student_buttons = get_button_texts(student_keyboard)
    
    assert "📅 Записаться на донацию" in student_buttons
    assert "🎁 Магазин мерча" in student_buttons
    assert "⚙️ Вернуться в админ-панель" not in student_buttons

    # Сценарий 2: Админ просматривает меню как студент
    admin_keyboard = inline.get_student_main_menu(viewer_role='admin')
    admin_buttons = get_button_texts(admin_keyboard)

    assert "📅 Записаться на донацию" in admin_buttons
    assert "⭐ Перейти в режим волонтера" in admin_buttons
    assert "⚙️ Вернуться в админ-панель" in admin_buttons

def test_get_admin_panel_keyboard():
    """Тестирует, что у главного админа есть кнопка экспорта, а у обычного - нет."""
    # Сценарий 1: Обычный админ
    admin_keyboard = inline.get_admin_panel_keyboard(viewer_role='admin')
    admin_buttons = get_button_texts(admin_keyboard)
    
    assert "👥 Упр. пользователями" in admin_buttons
    assert "💾 Экспорт данных" not in admin_buttons

    # Сценарий 2: Главный админ
    main_admin_keyboard = inline.get_admin_panel_keyboard(viewer_role='main_admin')
    main_admin_buttons = get_button_texts(main_admin_keyboard)

    assert "👥 Упр. пользователями" in main_admin_buttons
    assert "💾 Экспорт данных" in main_admin_buttons

def test_get_user_management_keyboard_permissions():
    """
    Тестирует логику отображения кнопок управления пользователем
    в зависимости от ролей смотрящего и цели.
    """
    # Сценарий 1: Главный админ смотрит на обычного студента
    kbd1 = inline.get_user_management_keyboard(
        target_user_id=1, target_user_role='student', viewer_role='main_admin', is_blocked=False
    )
    btn1 = get_button_texts(kbd1)
    assert "👑➕ Назначить админом" in btn1
    assert "🚫 Заблокировать" in btn1
    assert "👑➖ Разжаловать админа" not in btn1

    # Сценарий 2: Главный админ смотрит на обычного админа
    kbd2 = inline.get_user_management_keyboard(
        target_user_id=1, target_user_role='admin', viewer_role='main_admin', is_blocked=False
    )
    btn2 = get_button_texts(kbd2)
    assert "👑➖ Разжаловать админа" in btn2
    assert "👑➕ Назначить админом" not in btn2

    # Сценарий 3: Обычный админ смотрит на волонтера (не может управлять админами/блокировками)
    kbd3 = inline.get_user_management_keyboard(
        target_user_id=1, target_user_role='volunteer', viewer_role='admin', is_blocked=False
    )
    btn3 = get_button_texts(kbd3)
    assert "🧑‍🎓 Снять с должности волонтера" in btn3
    assert "👑➕ Назначить админом" not in btn3
    assert "🚫 Заблокировать" not in btn3
    
    
def test_admin_panel_keyboard_for_admin():
    """
    Тестирует, что обычный админ видит свою клавиатуру БЕЗ кнопки экспорта.
    """
    keyboard = inline.get_admin_panel_keyboard(viewer_role='admin')
    
    # Преобразуем клавиатуру в простой список callback_data для удобства проверки
    callbacks = []
    for row in keyboard.inline_keyboard:
        for button in row:
            callbacks.append(button.callback_data)

    assert "admin_manage_users" in callbacks
    assert "ma_export_data" not in callbacks # Главная проверка

def test_admin_panel_keyboard_for_main_admin():
    """
    Тестирует, что главный админ видит свою клавиатуру С кнопкой экспорта.
    """
    keyboard = inline.get_admin_panel_keyboard(viewer_role='main_admin')
    
    callbacks = []
    for row in keyboard.inline_keyboard:
        for button in row:
            callbacks.append(button.callback_data)

    assert "admin_manage_users" in callbacks
    assert "ma_export_data" in callbacks # Главная проверка

def test_user_management_keyboard_roles():
    """
    Тестирует, что кнопки управления ролями и блокировки появляются/исчезают правильно.
    """
    # Сценарий 1: Главный админ смотрит на обычного админа
    kb1 = inline.get_user_management_keyboard(
        target_user_id=1, target_user_role='admin', viewer_role='main_admin', is_blocked=False
    )
    cb1 = {b.callback_data for r in kb1.inline_keyboard for b in r}
    assert "ma_demote_admin_1" in cb1
    assert "ma_promote_admin_1" not in cb1
    assert "ma_block_user_1" in cb1

    # Сценарий 2: Главный админ смотрит на волонтера
    kb2 = inline.get_user_management_keyboard(
        target_user_id=2, target_user_role='volunteer', viewer_role='main_admin', is_blocked=False
    )
    cb2 = {b.callback_data for r in kb2.inline_keyboard for b in r}
    assert "ma_promote_admin_2" in cb2
    assert "admin_demote_volunteer_2" in cb2

    # Сценарий 3: Обычный админ смотрит на волонтера (не должен видеть кнопки гл. админа)
    kb3 = inline.get_user_management_keyboard(
        target_user_id=3, target_user_role='volunteer', viewer_role='admin', is_blocked=False
    )
    cb3 = {b.callback_data for r in kb3.inline_keyboard for b in r}
    assert "ma_promote_admin_3" not in cb3
    assert "ma_block_user_3" not in cb3
    assert "admin_demote_volunteer_3" in cb3

--- КОНЕЦ ФАЙЛА: tests/test_keyboards.py ---

--- НАЧАЛО ФАЙЛА: tests/test_mailing_logic.py ---

# tests/test_mailing_logic.py

import pytest
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db.models import User
from bot.db import user_requests, admin_requests

# Маркируем все тесты в этом файле для pytest-asyncio
pytestmark = pytest.mark.asyncio

# Данные для тестовых пользователей
users_data = [
    # ... (данные без изменений) ...
    {"id": 1, "university": "НИЯУ МИФИ", "faculty": "ИИКС", "role": "student"},
    {"id": 2, "university": "НИЯУ МИФИ", "faculty": "ИИКС", "role": "student"},
    {"id": 3, "university": "НИЯУ МИФИ", "faculty": "ИФИБ", "role": "volunteer"},
    {"id": 4, "university": "МГУ", "faculty": "ВМК", "role": "student"},
    {"id": 5, "university": "МГУ", "faculty": "ВМК", "role": "admin"},
    {"id": 6, "university": "Другой ВУЗ", "faculty": None, "role": "student"},
    {"id": 7, "university": "НИЯУ МИФИ", "faculty": "Администрация", "role": "main_admin"},
]

# --- ИЗМЕНЕНИЕ ФИКСТУРЫ ---
@pytest.fixture(scope="function", autouse=True)
async def setup_users(session: AsyncSession):
    """
    Фикстура для создания пользователей перед каждым тестом в этом файле.
    Теперь имеет scope="function" и использует фикстуру session.
    """
    users_to_add = [
        User(
            id=u["id"], phone_number=f"+{u['id']}", telegram_id=u["id"],
            full_name=f"User {u['id']}", university=u["university"],
            faculty=u.get("faculty"), role=u.get("role")
        ) for u in users_data
    ]
    session.add_all(users_to_add)
    await session.commit()
    yield # Передаем управление тесту
# --- КОНЕЦ ИЗМЕНЕНИЙ В ФИКСТУРЕ ---


@pytest.mark.parametrize(
    "filters, expected_user_ids",
    [
        # --- ПРОСТЫЕ ФИЛЬТРЫ ---
        ({}, {1, 2, 3, 4, 5, 6, 7}), # Фильтр 'all' или пустой -> все пользователи
        ({"role": "all"}, {1, 2, 3, 4, 5, 6, 7}),
        ({"university": "НИЯУ МИФИ"}, {1, 2, 3, 7}),
        ({"faculty": "ИИКС"}, {1, 2}),
        
        # --- РОЛЕВЫЕ ФИЛЬТРЫ ---
        ({"role": "volunteers"}, {3, 5, 7}), # volunteer, admin, main_admin
        ({"role": "admins"}, {5, 7}), # admin, main_admin
        
        # --- КОМПЛЕКСНЫЕ ФИЛЬТРЫ С РОЛЯМИ ---
        # Сценарий 1: Волонтеры из НИЯУ МИФИ
        ({"role": "volunteers", "university": "НИЯУ МИФИ"}, {3, 7}),

        # Сценарий 3: Волонтеры с факультета ВМК -> только пользователь 5 (т.к. админ - тоже волонтер)
        ({"role": "volunteers", "faculty": "ВМК"}, {5}),

        # Сценарий 5: Админы из НИЯУ МИФИ
        ({"role": "admins", "university": "НИЯУ МИФИ"}, {7}),
    ]
)
# --- ВАЖНО: УБИРАЕМ session ИЗ ПАРАМЕТРОВ ТЕСТА, Т.К. ОН НЕ ИСПОЛЬЗУЕТСЯ НАПРЯМУЮ, А НУЖЕН ФИКСТУРЕ ---
async def test_get_users_for_mailing_complex_with_roles(session: AsyncSession, filters, expected_user_ids):
    """
    Тестирует функцию фильтрации пользователей с комплексными фильтрами, включая роли.
    """
    # Фикстура setup_users уже выполнилась и создала пользователей
    users = await user_requests.get_users_for_mailing(session, filters)
    actual_user_ids = {user.id for user in users}
    assert actual_user_ids == expected_user_ids

# Этот тест также будет использовать фикстуру setup_users
async def test_get_distinct_faculties(session: AsyncSession):
    """Тестирует получение списка уникальных факультетов, исключая None."""
    faculties = await admin_requests.get_distinct_faculties(session)
    assert sorted(faculties) == ["Администрация", "ВМК", "ИИКС", "ИФИБ"]

--- КОНЕЦ ФАЙЛА: tests/test_mailing_logic.py ---

--- НАЧАЛО ФАЙЛА: tests/test_middlewares.py ---

# tests/test_middlewares.py

import pytest
from unittest.mock import AsyncMock, Mock

from sqlalchemy.ext.asyncio import AsyncSession
# Импортируем Message, чтобы использовать его как спецификацию для Mock
from aiogram.types import Message, CallbackQuery 

from bot.db.models import User
from bot.middlewares.block import BlockUserMiddleware
from bot.middlewares.db import DbSessionMiddleware

# Помечаем все тесты как асинхронные
pytestmark = pytest.mark.asyncio


# --- Фикстуры для подготовки пользователей ---

@pytest.fixture
async def blocked_user(session: AsyncSession) -> User:
    """Создает заблокированного пользователя в БД."""
    user = User(
        phone_number="+7-blocked", telegram_id=9001, full_name="Blocked User",
        university="Test", is_blocked=True
    )
    session.add(user)
    await session.commit()
    await session.refresh(user)
    return user

@pytest.fixture
async def active_user(session: AsyncSession) -> User:
    """Создает активного (не заблокированного) пользователя в БД."""
    user = User(
        phone_number="+7-active", telegram_id=9002, full_name="Active User",
        university="Test", is_blocked=False
    )
    session.add(user)
    await session.commit()
    await session.refresh(user)
    return user


# --- Тесты Middleware (ИСПРАВЛЕННАЯ ВЕРСИЯ) ---

async def test_block_middleware_for_blocked_user(session: AsyncSession, blocked_user: User):
    """
    Тест: Middleware должна остановить обработку для заблокированного пользователя.
    """
    block_mw = BlockUserMiddleware()
    handler_mock = AsyncMock()
    
    # ИСПРАВЛЕНИЕ: Создаем mock, который является "похожим" на Message
    # и будет проходить проверку isinstance(event, Message)
    event = Mock(spec=Message)
    event.from_user = Mock(id=blocked_user.telegram_id)
    event.answer = AsyncMock()

    await block_mw(
        handler=handler_mock, 
        event=event, 
        data={"session": session}
    )
    
    # Теперь handler не должен быть вызван
    handler_mock.assert_not_called()
    # А пользователю должно быть отправлено сообщение о блокировке
    event.answer.assert_called_once()
    assert "заблокированы" in event.answer.call_args.args[0]


async def test_block_middleware_for_active_user(session: AsyncSession, active_user: User):
    """
    Тест: Middleware должна пропустить обработку для активного пользователя.
    """
    block_mw = BlockUserMiddleware()
    handler_mock = AsyncMock()

    # ИСПРАВЛЕНИЕ: Используем тот же корректный mock
    event = Mock(spec=Message)
    event.from_user = Mock(id=active_user.telegram_id)
    event.answer = AsyncMock()
    
    await block_mw(
        handler=handler_mock, 
        event=event, 
        data={"session": session}
    )
    
    # Handler должен быть вызван, т.к. пользователь активен
    handler_mock.assert_called_once()
    # Сообщение о блокировке не отправляется
    event.answer.assert_not_called()


async def test_block_middleware_for_unregistered_user(session: AsyncSession):
    """
    Тест: Middleware должна пропустить обработку для пользователя, которого еще нет в БД.
    """
    block_mw = BlockUserMiddleware()
    handler_mock = AsyncMock()
    
    # ИСПРАВЛЕНИЕ: Используем тот же корректный mock
    event = Mock(spec=Message)
    event.from_user = Mock(id=999999) # ID, которого нет в БД
    event.answer = AsyncMock()
    
    await block_mw(
        handler=handler_mock, 
        event=event, 
        data={"session": session}
    )
    
    # Handler должен быть вызван, т.к. незарегистрированный пользователь не заблокирован
    handler_mock.assert_called_once()
    event.answer.assert_not_called()


async def test_db_middleware_adds_session(session_pool):  # <--- ИЗМЕНЕНИЕ ЗДЕСЬ
    """
    Тест для DbSessionMiddleware: проверяем, что он корректно добавляет сессию в данные.
    """
    # session_maker заменен на session_pool
    db_mw = DbSessionMiddleware(session_pool=session_pool)  # <--- ИЗМЕНЕНИЕ ЗДЕСЬ
    handler_mock = AsyncMock()
    event = Mock()
    data = {}

    await db_mw(handler=handler_mock, event=event, data=data)

    handler_mock.assert_called_once()
    data_passed_to_handler = handler_mock.call_args.args[1]
    assert 'session' in data_passed_to_handler
    assert isinstance(data_passed_to_handler['session'], AsyncSession)

--- КОНЕЦ ФАЙЛА: tests/test_middlewares.py ---

--- НАЧАЛО ФАЙЛА: tests/test_registration_logic.py ---

import pytest
import pytest_asyncio
import datetime
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession

from bot.db.models import Base, User, Event, EventRegistration, Donation, MedicalWaiver
from bot.db.event_requests import check_registration_eligibility, add_event_registration
from bot.db.models import Event as DbEvent # Чтобы избежать конфликта имен

# --- Настройка тестовой базы данных в памяти ---

TEST_DATABASE_URL = "sqlite+aiosqlite:///file:memdb1?mode=memory&cache=shared&uri=true"
test_engine = create_async_engine(TEST_DATABASE_URL, echo=False)
test_async_session_maker = async_sessionmaker(test_engine, class_=AsyncSession, expire_on_commit=False)

@pytest_asyncio.fixture(scope="function")
async def db_session() -> AsyncSession:
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    async with test_async_session_maker() as session:
        yield session
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

# --- Фикстуры для создания тестовых данных ---

@pytest_asyncio.fixture
async def male_user(db_session: AsyncSession) -> User:
    user = User(
        phone_number="+79991112233",
        telegram_id=1,
        full_name="Тестовый Пользователь Мужчина",
        gender="male",
        university="Тестовый ВУЗ"  # <-- ИСПРАВЛЕНО
    )
    db_session.add(user)
    await db_session.commit()
    return user

@pytest_asyncio.fixture
async def female_user(db_session: AsyncSession) -> User:
    user = User(
        phone_number="+79994445566",
        telegram_id=2,
        full_name="Тестовый Пользователь Женщина",
        gender="female",
        university="Тестовый ВУЗ" # <-- ИСПРАВЛЕНО
    )
    db_session.add(user)
    await db_session.commit()
    return user

# --- Тесты для новой логики ---

@pytest.mark.asyncio
async def test_successful_registration(db_session: AsyncSession, male_user: User):
    """Тест: Успешная регистрация при отсутствии конфликтов."""
    event_date = datetime.date.today() + datetime.timedelta(days=10)
    event = DbEvent(  # <-- ИСПРАВЛЕНО: Явное указание модели
        name="Тестовая донация",
        event_datetime=datetime.datetime.combine(event_date, datetime.time(10, 0)), # <-- ИСПРАВЛЕНО
        donation_type="whole_blood",
        participant_limit=10,
        location="Тестовая локация",
        points_per_donation=100
    )
    db_session.add(event)
    await db_session.commit()

    is_eligible, reason = await check_registration_eligibility(db_session, male_user, event)
    
    assert is_eligible is True
    assert reason == "Все проверки пройдены."

@pytest.mark.asyncio
async def test_blocked_by_potential_waiver(db_session: AsyncSession, male_user: User):
    """
    Тест: Блокировка из-за ПОТЕНЦИАЛЬНОГО медотвода от другой будущей регистрации.
    """
    event_A_date = datetime.date.today() + datetime.timedelta(days=10)
    event_B_date = datetime.date.today() + datetime.timedelta(days=15)
    
    event_A = DbEvent(
        name="Донация А",
        event_datetime=datetime.datetime.combine(event_A_date, datetime.time(10, 0)), # <-- ИСПРАВЛЕНО
        donation_type="whole_blood",
        participant_limit=10,
        location="Локация А",
        points_per_donation=100
    )
    event_B = DbEvent(
        name="Донация Б",
        event_datetime=datetime.datetime.combine(event_B_date, datetime.time(10, 0)), # <-- ИСПРАВЛЕНО
        donation_type="plasma",
        participant_limit=10,
        location="Локация Б",
        points_per_donation=50
    )
    db_session.add_all([event_A, event_B])
    await db_session.commit()
    
    await add_event_registration(db_session, male_user.id, event_A.id)

    is_eligible, reason = await check_registration_eligibility(db_session, male_user, event_B)
    
    assert is_eligible is False
    assert "запланирована донация" in reason
    assert "Донация А" in reason

@pytest.mark.asyncio
async def test_not_blocked_if_waiver_ends(db_session: AsyncSession, male_user: User):
    """
    Тест: Регистрация разрешена, если потенциальный медотвод закончится.
    """
    event_A_date = datetime.date.today() + datetime.timedelta(days=10)
    event_C_date = datetime.date.today() + datetime.timedelta(days=80)

    event_A = DbEvent(
        name="Донация А",
        event_datetime=datetime.datetime.combine(event_A_date, datetime.time(10, 0)), # <-- ИСПРАВЛЕНО
        donation_type="whole_blood",
        participant_limit=10,
        location="Локация А",
        points_per_donation=100
    )
    event_C = DbEvent(
        name="Донация С",
        event_datetime=datetime.datetime.combine(event_C_date, datetime.time(10, 0)), # <-- ИСПРАВЛЕНО
        donation_type="plasma",
        participant_limit=10,
        location="Локация C",
        points_per_donation=50
    )
    db_session.add_all([event_A, event_C])
    await db_session.commit()
    
    await add_event_registration(db_session, male_user.id, event_A.id)

    is_eligible, reason = await check_registration_eligibility(db_session, male_user, event_C)
    
    assert is_eligible is True

@pytest.mark.asyncio
async def test_blocked_by_yearly_limit_combined(db_session: AsyncSession, female_user: User):
    """
    Тест: Блокировка из-за годового лимита, учитывая прошлые и будущие донации.
    """
    # 2 прошлые донации
    db_session.add_all([
        Donation(user_id=female_user.id, donation_date=datetime.date.today() - datetime.timedelta(days=200), donation_type="whole_blood", points_awarded=10),
        Donation(user_id=female_user.id, donation_date=datetime.date.today() - datetime.timedelta(days=300), donation_type="whole_blood", points_awarded=10)
    ])

    # 1 будущая регистрация (донация №3)
    future_event_1_date = datetime.date.today() + datetime.timedelta(days=20)
    future_event_1 = DbEvent(
        name="Будущая 1", event_datetime=datetime.datetime.combine(future_event_1_date, datetime.time(10,0)), # <-- ИСПРАВЛЕНО
        donation_type="whole_blood", participant_limit=10, location="Локация 1", points_per_donation=100
    )
    db_session.add(future_event_1)
    await db_session.commit()
    await add_event_registration(db_session, female_user.id, future_event_1.id)

    # Записываемся на 4-ю донацию. Должно быть успешно.
    event_ok_date = datetime.date.today() + datetime.timedelta(days=120)
    event_to_register_ok = DbEvent(
        name="Будущая 2 (OK)", event_datetime=datetime.datetime.combine(event_ok_date, datetime.time(10,0)), # <-- ИСПРАВЛЕНО
        donation_type="whole_blood", participant_limit=10, location="Локация 2", points_per_donation=100
    )
    db_session.add(event_to_register_ok)
    await db_session.commit()

    is_eligible, reason = await check_registration_eligibility(db_session, female_user, event_to_register_ok)
    assert is_eligible is True, f"Регистрация на 4-ю донацию должна была пройти. Причина отказа: {reason}"
    
    await add_event_registration(db_session, female_user.id, event_to_register_ok.id)

    # Пытаемся записаться на 5-ю. Должны получить отказ именно по причине лимита.
    event_fail_date = datetime.date.today() + datetime.timedelta(days=220)
    event_to_register_fail = DbEvent(
        name="Будущая 3 (FAIL)", event_datetime=datetime.datetime.combine(event_fail_date, datetime.time(10,0)), # <-- ИСПРАВЛЕНО
        donation_type="whole_blood", participant_limit=10, location="Локация 3", points_per_donation=100
    )
    db_session.add(event_to_register_fail)
    await db_session.commit()

    is_eligible_fail, reason_fail = await check_registration_eligibility(db_session, female_user, event_to_register_fail)
    
    assert is_eligible_fail is False
    assert "годового лимита" in reason_fail, f"Ожидалась ошибка лимита, но получено: '{reason_fail}'"

@pytest.mark.asyncio
async def test_yearly_limit_not_blocked_by_other_type(db_session: AsyncSession, male_user: User):
    """
    Тест: Годовой лимит не должен блокировать запись, если типы донаций разные.
    """
    for i in range(5):
         db_session.add(Donation(user_id=male_user.id, donation_date=datetime.date.today() - datetime.timedelta(days=30*(i+1)), donation_type="plasma", points_awarded=10))
    await db_session.commit()

    blood_event_date = datetime.date.today() + datetime.timedelta(days=10)
    blood_event = DbEvent(
        name="Донация крови",
        event_datetime=datetime.datetime.combine(blood_event_date, datetime.time(10,0)), # <-- ИСПРАВЛЕНО
        donation_type="whole_blood",
        participant_limit=10,
        location="Тестовая локация",
        points_per_donation=100
    )
    db_session.add(blood_event)
    await db_session.commit()

    is_eligible, reason = await check_registration_eligibility(db_session, male_user, blood_event)

    assert is_eligible is True

--- КОНЕЦ ФАЙЛА: tests/test_registration_logic.py ---

--- НАЧАЛО ФАЙЛА: tests/test_scheduler_logic.py ---

import pytest
import datetime
from unittest.mock import AsyncMock, Mock
from aiogram import Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from sqlalchemy.ext.asyncio import AsyncSession

from bot.utils.scheduler import send_reminders_for_interval, send_post_donation_feedback
from bot.db.models import User, Event, EventRegistration, Donation
from bot.states.states import FeedbackSurvey
from bot.utils.text_messages import Text
from bot.keyboards import inline

pytestmark = pytest.mark.asyncio

@pytest.mark.parametrize(
    "time_delta_to_event, check_interval, check_window, expected_text_template, should_be_called",
    [
        (datetime.timedelta(days=7), datetime.timedelta(days=7), datetime.timedelta(days=1), Text.REMINDER_WEEK, True),
        (datetime.timedelta(days=2), datetime.timedelta(days=2), datetime.timedelta(days=1), Text.REMINDER_2_DAYS, True),
        (datetime.timedelta(hours=2), datetime.timedelta(hours=2), datetime.timedelta(hours=1), Text.REMINDER_2_HOURS, True),
        (datetime.timedelta(days=3), datetime.timedelta(days=2), datetime.timedelta(days=1), None, False),
        (datetime.timedelta(days=8), datetime.timedelta(days=7), datetime.timedelta(days=1), None, False),
        (datetime.timedelta(hours=3), datetime.timedelta(hours=2), datetime.timedelta(hours=1), None, False),
        (datetime.timedelta(days=-1), datetime.timedelta(days=2), datetime.timedelta(days=1), None, False),
    ]
)
async def test_send_event_reminders_multi_interval(
    session: AsyncSession,
    session_pool,
    mocker,
    time_delta_to_event,
    check_interval,
    check_window,
    expected_text_template,
    should_be_called
):
    """
    Тестирует отправку напоминаний для разных временных интервалов.
    """
    fixed_now = datetime.datetime(2024, 1, 1, 12, 0, 0)
    mocker.patch('datetime.datetime', Mock(now=lambda: fixed_now))

    mock_send_message = mocker.patch('aiogram.Bot.send_message', new_callable=AsyncMock)
    mock_bot = Mock(spec=Bot)
    mock_bot.send_message = mock_send_message

    user = User(phone_number="+1", telegram_id=101, full_name="UserToRemind", university="TestUni")
    event_time = fixed_now + time_delta_to_event
    event = Event(name="Test-Event", event_datetime=event_time, location="Test Location", donation_type="plasma", points_per_donation=10, participant_limit=5, is_active=True)
    session.add_all([user, event])
    await session.commit()
    registration = EventRegistration(user_id=user.id, event_id=event.id)
    session.add(registration)
    await session.commit()

    await send_reminders_for_interval(
        bot=mock_bot,
        session_pool=session_pool,  
        time_from_now=check_interval,
        time_window=check_window,
        text_template=expected_text_template or "dummy"
    )
    
    if should_be_called:
        mock_send_message.assert_called_once()
        call_args = mock_send_message.call_args.kwargs
        sent_text = call_args['text']
        
        assert call_args['parse_mode'] == "HTML"
        assert "<b>Напоминание" in sent_text or "<b>Донация уже скоро" in sent_text
        assert "Test-Event" in sent_text
        assert "Test Location" in sent_text
    else:
        mock_send_message.assert_not_called()

async def test_send_post_donation_feedback(session: AsyncSession, session_pool, mocker):
    """
    Тестирует отправку запроса на обратную связь на следующий день после донации.
    """
    # 1. Подготовка
    fixed_today = datetime.date(2024, 10, 27)
    fixed_yesterday = fixed_today - datetime.timedelta(days=1)
    fixed_day_before = fixed_today - datetime.timedelta(days=2)
    mocker.patch('datetime.date', Mock(today=lambda: fixed_today))

    mock_send_message = mocker.patch('aiogram.Bot.send_message', new_callable=AsyncMock)
    mock_bot = Mock(spec=Bot)
    mock_bot.send_message = mock_send_message

    user_to_notify = User(phone_number="+1", telegram_id=101, full_name="Feedback User", university="TestUni")
    user_to_ignore_old = User(phone_number="+2", telegram_id=102, full_name="Old Donor", university="TestUni")
    user_to_ignore_duplicate = User(phone_number="+3", telegram_id=103, full_name="Duplicate", university="TestUni")
    session.add_all([user_to_notify, user_to_ignore_old, user_to_ignore_duplicate])
    await session.commit()
    
    donation_to_notify = Donation(user_id=user_to_notify.id, event_id=1, donation_date=fixed_yesterday, donation_type="plasma", points_awarded=1)
    donation_to_ignore_old = Donation(user_id=user_to_ignore_old.id, event_id=2, donation_date=fixed_day_before, donation_type="plasma", points_awarded=1)
    donation_to_ignore_duplicate = Donation(user_id=user_to_ignore_duplicate.id, event_id=3, donation_date=fixed_yesterday, donation_type="plasma", points_awarded=1, feedback_requested=True)
    session.add_all([donation_to_notify, donation_to_ignore_old, donation_to_ignore_duplicate])
    await session.commit()

    # 2. Выполнение
    await send_post_donation_feedback(
        bot=mock_bot,
        session_pool=session_pool, 
        storage=MemoryStorage()
    )

    # 3. Проверка
    mock_send_message.assert_called_once_with(
        chat_id=user_to_notify.telegram_id,
        text=Text.FEEDBACK_START,
        reply_markup=inline.get_feedback_well_being_keyboard()
    )
    
    await session.refresh(donation_to_notify)
    await session.refresh(donation_to_ignore_old)
    await session.refresh(donation_to_ignore_duplicate)
    
    assert donation_to_notify.feedback_requested is True
    assert donation_to_ignore_old.feedback_requested is False
    assert donation_to_ignore_duplicate.feedback_requested is True

--- КОНЕЦ ФАЙЛА: tests/test_scheduler_logic.py ---

--- НАЧАЛО ФАЙЛА: tests/test_security.py ---

# tests/test_security.py

import pytest
import hmac
import hashlib
import json
from urllib.parse import urlencode
from fastapi import HTTPException

# Импортируем тестируемую функцию и конфиг
from main import validate_telegram_data
from bot.config_reader import config

# --- Вспомогательная функция для генерации корректной строки авторизации ---
def generate_test_auth_data(user_data_dict: dict, bot_token: str) -> str:
    """Генерирует валидную строку initData для тестов."""
    
    # ИСПРАВЛЕНИЕ: Используем json.dumps для корректной сериализации Python-словаря в JSON-строку.
    # separators убирает лишние пробелы, sort_keys обеспечивает одинаковый порядок ключей.
    user_data_str = json.dumps(user_data_dict, separators=(',', ':'), sort_keys=True)
    
    # Собираем данные для хеширования (кроме самого хеша)
    data_to_sign = {
        'auth_date': '1700000000',
        'query_id': 'AAg123456789',
        'user': user_data_str
    }
    
    # Сортируем и формируем строку для проверки (data_check_string)
    sorted_items = sorted(data_to_sign.items())
    data_check_string = "\n".join([f"{k}={v}" for k, v in sorted_items])
    
    # Вычисляем хеш точно так же, как это делает Telegram
    secret_key = hmac.new("WebAppData".encode(), bot_token.encode(), hashlib.sha256).digest()
    calculated_hash = hmac.new(secret_key, data_check_string.encode(), hashlib.sha256).hexdigest()
    
    # Добавляем хеш к данным и формируем финальную строку
    data_to_sign['hash'] = calculated_hash
    
    return urlencode(data_to_sign)


# --- Тесты ---

def test_validate_telegram_data_success():
    """Тест успешной валидации с корректными данными."""
    bot_token = config.bot_token.get_secret_value()
    user_data = {
        "id": 12345678,
        "first_name": "John",
        "last_name": "Doe",
        "username": "johndoe",
        "language_code": "en",
        "is_premium": True
    }
    
    auth_string = generate_test_auth_data(user_data, bot_token)
    
    # Выполняем валидацию
    validated_user_data = validate_telegram_data(auth_string)
    
    # Проверяем, что результат совпадает с исходными данными
    assert validated_user_data['id'] == user_data['id']
    assert validated_user_data['username'] == user_data['username']
    assert validated_user_data['is_premium'] is True


def test_validate_telegram_data_invalid_hash():
    """Тест провала валидации из-за неверного хеша."""
    bot_token = config.bot_token.get_secret_value()
    user_data = {"id": 123, "username": "test"}
    
    auth_string = generate_test_auth_data(user_data, bot_token)
    
    # Искажаем хеш
    tampered_auth_string = auth_string[:-10] + "abcdefghij"
    
    with pytest.raises(HTTPException) as excinfo:
        validate_telegram_data(tampered_auth_string)
        
    assert excinfo.value.status_code == 403
    # ИСПРАВЛЕНИЕ: Проверяем конкретное сообщение об ошибке, а не общее
    assert "Invalid hash" in str(excinfo.value.detail)


def test_validate_telegram_data_missing_hash():
    """Тест провала валидации из-за отсутствия хеша."""
    auth_string = "user=%7B%22id%22%3A+123%7D&auth_date=1700000000"
    
    with pytest.raises(HTTPException) as excinfo:
        validate_telegram_data(auth_string)
        
    assert excinfo.value.status_code == 403
    assert "Hash not found" in str(excinfo.value.detail)


def test_validate_telegram_data_tampered_data():
    """Тест провала валидации, если данные были изменены без пересчета хеша."""
    bot_token = config.bot_token.get_secret_value()
    user_data = {"id": 123}
    
    auth_string = generate_test_auth_data(user_data, bot_token)
    
    # Добавляем в строку новый параметр, который не участвовал в хешировании
    tampered_auth_string = auth_string + "&new_param=hacker"
    
    with pytest.raises(HTTPException) as excinfo:
        validate_telegram_data(tampered_auth_string)
        
    assert excinfo.value.status_code == 403
    assert "Invalid hash" in str(excinfo.value.detail)

--- КОНЕЦ ФАЙЛА: tests/test_security.py ---

--- НАЧАЛО ФАЙЛА: tests/test_survey_logic.py ---

import pytest
import datetime
from unittest.mock import AsyncMock, Mock

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

# Мы тестируем process_survey_rules из main, так что импортируем оттуда
from main import process_survey_rules, SurveyAnswers
# А вот submit_survey_logic мы теперь тестируем по-новому
from main import submit_survey_logic, SurveyPayload 
from bot.db.models import User, Survey, MedicalWaiver, UserBlock

# Маркируем все тесты в этом файле для pytest-asyncio
pytestmark = pytest.mark.asyncio

# Создаем базовый набор "здоровых" ответов
default_answers = {
    "feeling": "good", "weight": "no", "symptoms": "no",
    "tattoo": "no", "tooth": "no", "vaccine": "no", "vaccine_type": None,
    "antibiotics": "no", "aspirin": "no", "contact_hepatitis": "no",
    "diseases_absolute": "no", "diseases_chronic": "no",
    "travel": "no", "alcohol": "no"
}

# --- Тест 1: Проверка "движка правил" ---
@pytest.mark.parametrize("modified_answer, expected_status, expected_days, expected_reason_part", [
    # Сценарий "OK"
    ({}, "ok", 0, "Противопоказаний не выявлено"),
    # Сценарии временных отводов
    ({"symptoms": "yes"}, "temp_waiver", 14, "Симптомы ОРВИ"),
    ({"feeling": "bad"}, "temp_waiver", 3, "Плохое самочувствие"),
    ({"tattoo": "yes"}, "temp_waiver", 120, "татуировки"),
    ({"alcohol": "yes"}, "temp_waiver", 2, "алкоголя"),
    ({"vaccine": "yes", "vaccine_type": "live"}, "temp_waiver", 30, "вакцинация"),
    ({"vaccine": "yes", "vaccine_type": "killed"}, "temp_waiver", 10, "вакцинация"),
    
    # --- ИСПРАВЛЕННЫЕ СЦЕНАРИИ "ПОСТОЯННЫХ" ОТВОДОВ ---
    # Теперь это временный отвод на 1000 лет
    ({"diseases_absolute": "yes"}, "temp_waiver", 365000, "Абсолютное противопоказание"),
    # Это тоже временный отвод на 1000 лет
    ({"weight": "yes"}, "temp_waiver", 365000, "Вес менее 50 кг"),
])
async def test_process_survey_rules(modified_answer, expected_status, expected_days, expected_reason_part):
    """Тестирует обновленный движок правил."""
    answers_dict = default_answers.copy()
    answers_dict.update(modified_answer)
    answers_obj = SurveyAnswers(**answers_dict)
    
    status, days, reason = await process_survey_rules(answers_obj)
    
    assert status == expected_status
    assert days == expected_days
    assert expected_reason_part in reason

# --- Тесты 2: Проверка логики submit_survey_logic ---

async def create_test_user(session: AsyncSession, tg_id=123, is_blocked=False):
    """Вспомогательная функция для создания тестового пользователя."""
    user = User(
        phone_number=f"+{tg_id}", telegram_id=tg_id, full_name="Test User",
        university="Test", is_blocked=is_blocked
    )
    session.add(user)
    await session.commit()
    return user

async def test_api_submit_survey_ok(session: AsyncSession):
    """Тестирует успешный сценарий: submit_survey_logic должна вернуть данные для отправки сообщения."""
    user = await create_test_user(session)
    answers = SurveyAnswers(**default_answers)
    payload = SurveyPayload(survey_data=answers, auth_string="valid_auth_string")
    
    # Мокаем валидатор, чтобы не проверять хеши в этом юнит-тесте
    with pytest.MonkeyPatch.context() as m:
        m.setattr("main.validate_telegram_data", lambda auth_data: {'id': user.telegram_id})
        
        # Вызываем логику и получаем результат
        chat_id, text, markup = await submit_survey_logic(session, payload)

    # Проверяем, что в БД появилась запись об опросе
    survey_record = (await session.execute(select(Survey).where(Survey.user_id == user.id))).scalar_one()
    assert survey_record.passed is True
    assert "Противопоказаний не выявлено" in survey_record.verdict_text
    
    # Проверяем, что не создался медотвод
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one_or_none()
    assert waiver is None
    
    # Проверяем, что функция вернула правильные данные для отправки
    assert chat_id == user.telegram_id
    assert "Противопоказаний не найдено" in text
    assert "мероприятий для записи сейчас нет" in text # т.к. мероприятий мы не создавали
    assert markup is None # Клавиатуры нет, т.к. нет мероприятий

async def test_api_submit_survey_temp_waiver(session: AsyncSession):
    """Тестирует сценарий временного отвода: submit_survey_logic должна создать медотвод."""
    user = await create_test_user(session)
    answers_dict = default_answers.copy()
    answers_dict["symptoms"] = "yes"
    answers = SurveyAnswers(**answers_dict)
    payload = SurveyPayload(survey_data=answers, auth_string="valid_auth_string")

    with pytest.MonkeyPatch.context() as m:
        m.setattr("main.validate_telegram_data", lambda auth_data: {'id': user.telegram_id})
        chat_id, text, markup = await submit_survey_logic(session, payload)
    
    # Проверяем, что создался медотвод на 14 дней
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one()
    expected_end_date = datetime.date.today() + datetime.timedelta(days=14)
    assert waiver is not None
    assert waiver.user_id == user.id
    assert waiver.end_date == expected_end_date
    assert "Симптомы ОРВИ" in waiver.reason
    
    # Проверяем возвращенные данные
    assert chat_id == user.telegram_id
    # --- ИСПРАВЛЕНИЕ 1 ---
    assert "выявлено противопоказание" in text
    assert expected_end_date.strftime('%d.%m.%Y') in text

async def test_api_submit_survey_perm_waiver_is_now_temp(session: AsyncSession):
    """Тестирует, что постоянный отвод теперь работает как временный на 1000 лет."""
    user = await create_test_user(session)
    answers_dict = default_answers.copy()
    answers_dict["diseases_absolute"] = "yes"
    answers = SurveyAnswers(**answers_dict)
    payload = SurveyPayload(survey_data=answers, auth_string="valid_auth_string")

    with pytest.MonkeyPatch.context() as m:
        m.setattr("main.validate_telegram_data", lambda auth_data: {'id': user.telegram_id})
        chat_id, text, markup = await submit_survey_logic(session, payload)

    # Проверяем, что НЕ создалась запись о блокировке
    block_record = (await session.execute(select(UserBlock).where(UserBlock.user_id == user.id))).scalar_one_or_none()      
    assert block_record is None

    # Проверяем, что пользователь НЕ заблокирован
    await session.refresh(user)
    assert user.is_blocked is False

    # Проверяем, что создался медотвод на 365000 дней
    waiver = (await session.execute(select(MedicalWaiver))).scalar_one()
    expected_end_date = datetime.date.today() + datetime.timedelta(days=365000)
    assert waiver is not None
    assert waiver.reason == "Абсолютное противопоказание (хронические/инфекционные заболевания)."
    assert waiver.end_date == expected_end_date

    # Проверяем возвращенные данные
    # --- ИСПРАВЛЕНИЕ 2 ---
    assert "установили вам медотвод" in text
    assert expected_end_date.strftime('%d.%m.%Y') in text

--- КОНЕЦ ФАЙЛА: tests/test_survey_logic.py ---

--- НАЧАЛО ФАЙЛА: tests/test_utils.py ---

import pytest
import datetime
from unittest.mock import AsyncMock, Mock, patch

import datetime
from sqlalchemy import select 
from aiogram import Bot

from bot.utils.qr_service import create_secure_payload, verify_secure_payload
from bot.utils.scheduler import check_waiver_expirations
from bot.db.models import User, Event, EventRegistration, MedicalWaiver


# --- Тесты QR-кодов (без изменений) ---
def test_qr_payload_creation_and_verification():
    original_data = {"user_id": 12345, "event_id": 678}
    payload = create_secure_payload(original_data)
    verified_data = verify_secure_payload(payload)
    assert isinstance(payload, str)
    assert verified_data is not None
    assert verified_data == original_data

def test_qr_verification_failure_with_bad_hash():
    original_data = {"user_id": 999}
    payload = create_secure_payload(original_data)
    tampered_payload = payload[:-5] + "abcde"
    verified_data = verify_secure_payload(tampered_payload)
    assert verified_data is None

def test_qr_verification_failure_with_bad_format():
    bad_payload = "this_is_not_a_valid_payload"
    verified_data = verify_secure_payload(bad_payload)
    assert verified_data is None


@pytest.mark.asyncio
async def test_check_waiver_expirations(mocker, session_pool): # <-- Убираем фикстуру session
    """Тестирует отправку уведомлений об истечении медотводов."""
    
    fixed_today = datetime.date(2024, 5, 20)
    
    # Мокируем `datetime.date` как и раньше
    with patch('bot.utils.scheduler.datetime.date') as mock_date:
        
        mock_date.today.return_value = fixed_today
        yesterday_in_test = fixed_today - datetime.timedelta(days=1)
    
        # --- Создаем данные внутри новой сессии, как это сделала бы реальная функция ---
        async with session_pool() as session:
            user_expired = User(phone_number="+7771", telegram_id=7771, full_name="Expired", university="TestUni")
            user_active = User(phone_number="+7772", telegram_id=7772, full_name="Active", university="TestUni")
            session.add_all([user_expired, user_active])
            await session.flush()
    
            waiver_expired = MedicalWaiver(
                user_id=user_expired.id, 
                start_date=yesterday_in_test - datetime.timedelta(days=30),
                end_date=yesterday_in_test,
                reason="test", created_by="system"
            )
            waiver_active = MedicalWaiver(
                user_id=user_active.id,
                start_date=fixed_today - datetime.timedelta(days=10),
                end_date=fixed_today,
                reason="test", created_by="system"
            )
            session.add_all([waiver_expired, waiver_active])
            await session.commit() # Здесь коммит необходим, чтобы данные сохранились для следующей сессии

        # Настраиваем моки для вызова
        mock_send_message = mocker.patch('aiogram.Bot.send_message', new_callable=AsyncMock)
        mock_bot = Mock(spec=Bot)
        mock_bot.send_message = mock_send_message

        # Вызываем тестируемую функцию
        await check_waiver_expirations(mock_bot, session_pool)
    
        # Проверяем результат
        mock_send_message.assert_called_once()
        call_args = mock_send_message.call_args
        assert call_args.kwargs['chat_id'] == 7771
        
        expected_phrase = "срок вашего медицинского отвода истек"
        actual_text = call_args.kwargs['text']
        assert expected_phrase.lower() in actual_text.lower()

        # Дополнительная проверка, что в БД все чисто для следующего теста
        async with session_pool() as session:
            res = await session.execute(select(User))
            assert len(res.scalars().all()) > 0 # Данные есть
    # После выхода из async with фикстура session в conftest.py очистит данные

--- КОНЕЦ ФАЙЛА: tests/test_utils.py ---

--- НАЧАЛО ФАЙЛА: tests/test_volunteer_fsm.py ---

import pytest
import datetime
from unittest.mock import AsyncMock, Mock

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select 
from aiogram import Bot

# Импортируем необходимые модели и запросы
from bot.db.models import User, Event, EventRegistration, Donation, MedicalWaiver
from bot.db import event_requests

# Импортируем состояния и хендлеры, которые будем тестировать
from bot.states.states import VolunteerActions
from bot.handlers.volunteer import (
    start_qr_confirmation, 
    process_qr_photo, 
    process_donation_confirmation,
    process_qr_invalid_input
)
from bot.utils.text_messages import Text

# Помечаем все тесты как асинхронные
pytestmark = pytest.mark.asyncio

# --- Вспомогательные классы-заглушки (Mocks) ---

class MockMessage:
    """Упрощенная заглушка для объекта Message."""
    def __init__(self, text=None, from_user_id=1, photo=None):
        self.text = text
        self.from_user = Mock(id=from_user_id)
        # Имитируем структуру F.photo (список с последним элементом лучшего качества)
        self.photo = [Mock(file_id="photo_file_id_123")] if photo else None
        self.answer = AsyncMock()
        self.edit_text = AsyncMock()

class MockCallbackQuery:
    """Упрощенная заглушка для объекта CallbackQuery."""
    def __init__(self, data, from_user_id=1, message=None):
        self.data = data
        self.from_user = Mock(id=from_user_id)
        self.message = message if message else MockMessage(from_user_id=from_user_id)
        self.answer = AsyncMock()

class MockFSMContext:
    """Упрощенная заглушка для FSMContext."""
    def __init__(self):
        self._state = None
        self._data = {}
    async def get_state(self): return self._state
    async def set_state(self, state): self._state = state
    async def get_data(self): return self._data.copy()
    async def update_data(self, **kwargs): self._data.update(kwargs)
    async def clear(self):
        self._state = None
        self._data = {}

# --- Фикстуры для подготовки данных в БД ---

@pytest.fixture
async def volunteer_user(session: AsyncSession) -> User:
    user = User(
        phone_number="+7-volunteer", telegram_id=1001, full_name="Волонтер Тестов", 
        role="volunteer", university="TestUni"
    )
    session.add(user)
    await session.commit()
    return user

@pytest.fixture
async def donor_user(session: AsyncSession) -> User:
    user = User(
        phone_number="+7-donor", telegram_id=2002, full_name="Донор Тестов", 
        role="student", university="TestUni", gender="male", points=0
    )
    session.add(user)
    await session.commit()
    return user

@pytest.fixture
async def today_event(session: AsyncSession) -> Event:
    event = Event(
        name="Сегодняшнее Мероприятие", 
        event_datetime=datetime.datetime.now(), 
        location="Тестовая локация", donation_type="whole_blood", 
        points_per_donation=50, participant_limit=10
    )
    session.add(event)
    await session.commit()
    return event

@pytest.fixture
async def future_event(session: AsyncSession) -> Event:
    event = Event(
        name="Будущее Мероприятие", 
        event_datetime=datetime.datetime.now() + datetime.timedelta(days=5), 
        location="Другая локация", donation_type="plasma", 
        points_per_donation=20, participant_limit=5
    )
    session.add(event)
    await session.commit()
    return event

@pytest.fixture
async def registration(session: AsyncSession, donor_user: User, today_event: Event) -> EventRegistration:
    """Создает регистрацию донора на сегодняшнее мероприятие."""
    reg = EventRegistration(user_id=donor_user.id, event_id=today_event.id)
    session.add(reg)
    await session.commit()
    return reg



async def test_volunteer_fsm_happy_path(
    session: AsyncSession, mocker, volunteer_user: User, donor_user: User, today_event: Event, registration: EventRegistration
):
    """
    Тестирует полный успешный сценарий: от сканирования QR до подтверждения донации.
    """
    state = MockFSMContext()
    
    # Мокаем Bot и его метод download, т.к. мы не будем реально скачивать файл
    mock_bot = Mock(spec=Bot)
    mock_bot.download.return_value = AsyncMock(read=AsyncMock(return_value=b'fake_photo_bytes'))

    # Мокаем `read_qr`, чтобы он возвращал нужные нам данные без реального QR
    qr_data = {"user_id": donor_user.telegram_id, "event_id": today_event.id}
    mocker.patch('bot.handlers.volunteer.read_qr', new_callable=AsyncMock, return_value=qr_data)
    
    # 2. ACT & ASSERT (Действие и Проверка)
    
    # --- Шаг 1: Волонтер инициирует процесс ---
    callback_start = MockCallbackQuery(data="confirm_donation_qr", from_user_id=volunteer_user.telegram_id)
    await start_qr_confirmation(callback_start, state)
    
    assert await state.get_state() == VolunteerActions.awaiting_qr_photo
    callback_start.message.edit_text.assert_called_once_with(Text.VOLUNTEER_SEND_QR_PROMPT)

    # --- Шаг 2: Волонтер отправляет фото с QR ---
    message_photo = MockMessage(from_user_id=volunteer_user.telegram_id, photo=True)
    await process_qr_photo(message_photo, state, session, mock_bot)

    assert await state.get_state() == VolunteerActions.awaiting_confirmation
    message_photo.answer.assert_called_once()
    
    # --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
    # Получаем аргументы вызова mock'а
    args, kwargs = message_photo.answer.call_args
    # Текст передается как первый позиционный аргумент
    sent_text = args[0] 
    
    assert donor_user.full_name in sent_text
    assert today_event.name in sent_text
    assert kwargs['parse_mode'] == "HTML"
    
    # --- Шаг 3: Волонтер подтверждает донацию ---
    callback_confirm = MockCallbackQuery(
        data=f"confirm_donation_{donor_user.id}_{today_event.id}",
        from_user_id=volunteer_user.telegram_id
    )
    await process_donation_confirmation(callback_confirm, state, session, mock_bot)
    
    assert await state.get_state() is None # Состояние должно сброситься
    callback_confirm.message.edit_text.assert_called_with(
        Text.DONATION_CONFIRM_SUCCESS.format(
            donor_name=donor_user.full_name,
            event_name=today_event.name,
            points=today_event.points_per_donation
        ),
        reply_markup=mocker.ANY, # Проверяем, что клавиатура была, не важен ее тип
        parse_mode="HTML"
    )

    # --- Финальная проверка изменений в БД ---
    await session.refresh(donor_user)
    await session.refresh(registration)
    
    assert donor_user.points == today_event.points_per_donation
    
    # Теперь этот код будет работать, так как select импортирован
    donation_record_query = await session.execute(
        select(Donation).where(
            Donation.user_id == donor_user.id,
            Donation.event_id == today_event.id
        )
    )
    donation_record = donation_record_query.scalar_one_or_none()
    
    waiver_record_query = await session.execute(
        select(MedicalWaiver).where(MedicalWaiver.user_id == donor_user.id)
    )
    waiver_record = waiver_record_query.scalar_one_or_none()

    assert donation_record is not None
    assert donation_record.user_id == donor_user.id
    
    assert waiver_record is not None
    assert waiver_record.user_id == donor_user.id

# --- Тесты "несчастливых" путей ---

async def test_volunteer_fsm_invalid_input(volunteer_user: User):
    """Тест: волонтер отправляет текст вместо фото."""
    message = MockMessage(text="это не фото", from_user_id=volunteer_user.telegram_id)
    await process_qr_invalid_input(message)
    message.answer.assert_called_once_with(Text.VOLUNTEER_INVALID_INPUT_QR)


async def test_volunteer_fsm_qr_read_fails(mocker, session, volunteer_user: User):
    """Тест: QR-код не распознан."""
    state = MockFSMContext()
    mocker.patch('bot.handlers.volunteer.read_qr', new_callable=AsyncMock, return_value=None)
    mock_bot = Mock(spec=Bot)
    mock_bot.download.return_value = AsyncMock(read=AsyncMock(return_value=b''))

    message_photo = MockMessage(from_user_id=volunteer_user.telegram_id, photo=True)
    await process_qr_photo(message_photo, state, session, mock_bot)

    assert await state.get_state() is None # Состояние сбрасывается при ошибке
    message_photo.answer.assert_called_once_with(Text.QR_READ_ERROR)


async def test_volunteer_fsm_donor_not_registered(mocker, session, volunteer_user, donor_user, today_event):
    """Тест: Донор не зарегистрирован на это мероприятие."""
    # Важно: фикстура 'registration' здесь не используется, т.е. записи в БД нет
    state = MockFSMContext()
    qr_data = {"user_id": donor_user.telegram_id, "event_id": today_event.id}
    mocker.patch('bot.handlers.volunteer.read_qr', new_callable=AsyncMock, return_value=qr_data)
    mock_bot = Mock(spec=Bot)
    mock_bot.download.return_value = AsyncMock(read=AsyncMock(return_value=b''))

    message_photo = MockMessage(from_user_id=volunteer_user.telegram_id, photo=True)
    await process_qr_photo(message_photo, state, session, mock_bot)

    assert await state.get_state() is None
    message_photo.answer.assert_called_once_with(
        Text.QR_DONOR_NOT_REGISTERED_ERROR.format(donor_name=donor_user.full_name),
        parse_mode="HTML"
    )

async def test_volunteer_fsm_wrong_day(mocker, session, volunteer_user, donor_user, future_event):
    """Тест: QR-код от мероприятия, которое проходит не сегодня."""
    state = MockFSMContext()
    # Регистрируем донора на БУДУЩЕЕ мероприятие
    reg = EventRegistration(user_id=donor_user.id, event_id=future_event.id)
    session.add(reg)
    await session.commit()

    qr_data = {"user_id": donor_user.telegram_id, "event_id": future_event.id}
    mocker.patch('bot.handlers.volunteer.read_qr', new_callable=AsyncMock, return_value=qr_data)
    mock_bot = Mock(spec=Bot)
    mock_bot.download.return_value = AsyncMock(read=AsyncMock(return_value=b''))

    message_photo = MockMessage(from_user_id=volunteer_user.telegram_id, photo=True)
    await process_qr_photo(message_photo, state, session, mock_bot)

    assert await state.get_state() is None
    message_photo.answer.assert_called_once_with(Text.QR_WRONG_DAY_ERROR)

--- КОНЕЦ ФАЙЛА: tests/test_volunteer_fsm.py ---

--- НАЧАЛО ФАЙЛА: tests/__init__.py ---



--- КОНЕЦ ФАЙЛА: tests/__init__.py ---

    Внедрить инструмент анализа покрытия (Coverage):

        Проблема: Сейчас оценка покрытия — это экспертное мнение. Вы не знаете точно, какие строки или ветки кода не выполняются во время тестов.

        Решение: Интегрируйте pytest-cov. Это позволит генерировать отчеты о покрытии и видеть "слепые зоны".

            Установка: pip install pytest-cov

            Запуск: pytest --cov=bot

        Польза: Вы сразу увидите, какие хендлеры, условные операторы (if/else) или функции вообще не тестируются.

    Тестирование "несчастных путей" (Unhappy Paths) в FSM:

        Проблема: Ваши тесты FSM в основном проверяют, что все работает, когда пользователь вводит корректные данные.

        Решение: Добавьте тесты, которые проверяют поведение системы на некорректный ввод.

            Что если в FSM создания мероприятия вместо даты ДД.ММ.ГГГГ ЧЧ:ММ пользователь введет "завтра"?

            Что если в FSM создания товара вместо цены в баллах пользователь введет "сто"?

            Что если пользователь нажмет кнопку /cancel в середине процесса?

        Польза: Это сделает бота более устойчивым к ошибкам пользователя и неожиданному поведению.

    Тестирование API-слоя (FastAPI в main.py):

        Проблема: Логика эндпоинта submit_survey протестирована, но сам HTTP-интерфейс — нет.

        Решение: Добавьте тесты для FastAPI с использованием httpx и AsyncClient.

            Протестируйте эндпоинт /api/submit_survey, отправляя на него реальные HTTP POST-запросы с разными телами (корректным, некорректным JSON, без auth_string).

            Проверьте, что возвращаются правильные HTTP-статусы (200, 400, 403, 404).

            Добавьте простой тест для эндпоинта /health.

        Польза: Вы будете уверены, что не только внутренняя логика, но и сам веб-сервис работает правильно.

    Тестирование импорта/экспорта данных:

        Проблема: В bot/utils/data_import.py и bot/handlers/admin/system.py находится критически важная, но не протестированная логика.

        Решение: Создайте отдельный файл tests/test_data_io.py.

            Для импорта: Подготовьте несколько маленьких .xlsx файлов (валидный, с отсутствующими колонками, с "грязными" данными) и тестируйте функцию import_data_from_file, проверяя, как она меняет состояние БД.

            Для экспорта: Наполните тестовую БД данными, вызовите функцию create_full_backup_xlsx и проверьте, что полученный .xlsx файл можно прочитать (например, с помощью pandas) и что он содержит ожидаемые листы и данные.

        Польза: Защитит от ошибок при работе с файлами, которые могут повредить всю базу данных.

    Тестирование конфигурации планировщика (scheduler):

        Проблема: Логика функций, которые вызывает планировщик, протестирована (test_scheduler_logic.py), но сама конфигурация (setup_scheduler) — нет.

        Решение: Это более сложная задача. Можно с помощью mocker "замокать" AsyncIOScheduler и проверить, что метод add_job вызывается правильное количество раз с правильными триггерами (cron, hour, minute).

        Польза: Уверенность в том, что фоновые задачи будут запускаться именно тогда, когда вы этого ожидаете.