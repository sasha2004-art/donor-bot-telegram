==================== СТРУКТУРА ПРОЕКТА ====================

.
├── 1_old.txt
├── Dockerfile
├── README.md
├── bot
│   ├── __init__.py
│   ├── config_reader.py
│   ├── db
│   │   ├── __init__.py
│   │   ├── admin_requests.py
│   │   ├── engine.py
│   │   ├── event_requests.py
│   │   ├── merch_requests.py
│   │   ├── models.py
│   │   └── user_requests.py
│   ├── filters
│   │   └── role.py
│   ├── handlers
│   │   ├── __init__.py
│   │   ├── admin
│   │   │   ├── __init__.py
│   │   │   ├── event_management.py
│   │   │   ├── mailing.py
│   │   │   ├── merch_management.py
│   │   │   ├── system.py
│   │   │   └── user_management.py
│   │   ├── admin.py
│   │   ├── common.py
│   │   ├── main_admin.py
│   │   ├── other.py
│   │   ├── student.py
│   │   └── volunteer.py
│   ├── keyboards
│   │   ├── __init__.py
│   │   ├── inline.py
│   │   └── reply.py
│   ├── middlewares
│   │   ├── __init__.py
│   │   ├── block.py
│   │   └── db.py
│   ├── states
│   │   ├── __init__.py
│   │   └── states.py
│   └── utils
│       ├── __init__.py
│       ├── qr_service.py
│       ├── scheduler.py
│       └── text_messages.py
├── collector.py
├── docker-compose.yml
├── main.py
└── requirements.txt

10 directories, 42 files


==================== СОДЕРЖИМОЕ ФАЙЛОВ ====================

--- НАЧАЛО ФАЙЛА: .env ---

BOT_TOKEN=7404235730:AAHqEYpQpI7c9XY2Qwj-KGhpLr_yl9-s4j0
SUPER_ADMIN_ID=1031233699

DB_HOST=db
DB_PORT=5432
DB_NAME=donor_bot_db
DB_USER=donor_user
DB_PASS=strong123321
QR_SECRET_KEY=a_very_secret_key_for_hashing_qr_codes_!@#$

--- КОНЕЦ ФАЙЛА: .env ---

--- НАЧАЛО ФАЙЛА: .gitignore ---

__pycache__/ 
*.py[cod] 
*$py.class 
venv/ 
.venv/ 
.env 
.idea/ 
.vscode/ 
*.pyc
db_volume/
create_project.bat

--- КОНЕЦ ФАЙЛА: .gitignore ---

--- НАЧАЛО ФАЙЛА: docker-compose.yml ---

# docker-compose.yml

version: '3.8'

services:
  db:
    image: postgres:15-alpine
    container_name: donor_db_container
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
    volumes:
      - db_volume:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: always

  bot:
    build: .
    container_name: donor_bot_container
    env_file: .env
    depends_on:
      - db
    restart: always
    volumes:
      - .:/app

volumes:
  db_volume:

--- КОНЕЦ ФАЙЛА: docker-compose.yml ---

--- НАЧАЛО ФАЙЛА: Dockerfile ---

FROM python:3.11-slim
RUN apt-get update && apt-get install -y libzbar0 && rm -rf /var/lib/apt/lists/*
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
CMD ["python", "main.py"]

--- КОНЕЦ ФАЙЛА: Dockerfile ---

--- НАЧАЛО ФАЙЛА: main.py ---

# main.py

import asyncio
import logging
from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage

from bot.middlewares.block import BlockUserMiddleware
from bot.middlewares.db import DbSessionMiddleware
from bot.config_reader import config
from bot.db.engine import create_db_and_tables, async_session_maker
from bot.db import admin_requests 
from bot.utils.scheduler import setup_scheduler

# --- ИЗМЕНЕНИЕ: ИМПОРТИРУЕМ НОВЫЕ РОУТЕРЫ ---
from bot.handlers import common, student, volunteer, other
from bot.handlers.admin import admin_router
# ---------------------------------------------

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
)
logger = logging.getLogger(__name__)


async def main():
    logger.info("Starting bot...")

    storage = MemoryStorage()
    bot = Bot(token=config.bot_token.get_secret_value(), parse_mode="HTML")
    dp = Dispatcher(storage=storage)

    dp.update.middleware(DbSessionMiddleware(session_pool=async_session_maker))
    dp.update.middleware(BlockUserMiddleware())

    # --- ИЗМЕНЕНИЕ: РЕГИСТРИРУЕМ РОУТЕРЫ ---
    dp.include_router(common.router)
    dp.include_router(student.router)
    dp.include_router(volunteer.router)
    dp.include_router(admin_router)  # <-- Регистрируем единый админский роутер
    # dp.include_router(main_admin.router) # <-- Больше не нужен
    dp.include_router(other.router) # Роутер для "неизвестных команд" должен быть последним
    # ----------------------------------------

    await create_db_and_tables()

    # Блок кода для создания главного администратора остается без изменений
    logger.info("Checking for initial admin setup...")
    async with async_session_maker() as session:
        users_exist = await admin_requests.check_if_users_exist(session)
        if not users_exist:
            super_admin_id = config.super_admin_id
            logger.warning(f"Users table is empty. Creating main admin with ID: {super_admin_id}")
            try:
                await admin_requests.create_main_admin(
                    session=session,
                    tg_id=super_admin_id,
                    tg_username="main_admin",
                    full_name="Главный Администратор"
                )
                await session.commit()
                logger.info(f"Main admin user created successfully for TG ID {super_admin_id}.")
            except Exception as e:
                logger.error(f"Failed to create main admin: {e}", exc_info=True)
        else:
            logger.info("Users table is not empty. Skipping admin creation.")

    scheduler = setup_scheduler(bot, async_session_maker)

    try:
        scheduler.start()
        await bot.delete_webhook(drop_pending_updates=True)
        await dp.start_polling(bot)
    finally:
        scheduler.shutdown()
        await bot.session.close()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logger.info("Bot stopped")

--- КОНЕЦ ФАЙЛА: main.py ---

--- НАЧАЛО ФАЙЛА: requirements.txt ---

aiogram==3.4.1
sqlalchemy[asyncio]==2.0.27
asyncpg==0.29.0
python-dotenv==1.0.1
qrcode[pil]==7.4.2
pyzbar==0.1.9
Pillow==10.2.0
apscheduler==3.10.4
alembic==1.13.1
pydantic-settings==2.2.1

--- КОНЕЦ ФАЙЛА: requirements.txt ---

--- НАЧАЛО ФАЙЛА: .pytest_cache/.gitignore ---

# Created by pytest automatically.
*


--- КОНЕЦ ФАЙЛА: .pytest_cache/.gitignore ---

--- НАЧАЛО ФАЙЛА: bot/config_reader.py ---

from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import SecretStr, StrictStr

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')
    bot_token: SecretStr
    super_admin_id: int
    db_host: StrictStr
    db_port: int
    db_name: StrictStr
    db_user: StrictStr
    db_pass: SecretStr
    qr_secret_key: SecretStr
    @property
    def database_url(self) -> str:
        return (f"postgresql+asyncpg://{self.db_user}:{self.db_pass.get_secret_value()}"
                f"@{self.db_host}:{self.db_port}/{self.db_name}")


config = Settings()

--- КОНЕЦ ФАЙЛА: bot/config_reader.py ---

--- НАЧАЛО ФАЙЛА: bot/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/db/admin_requests.py ---

import datetime
from sqlalchemy import select, update, or_, func, String, delete 
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload, selectinload
from .models import (
    User, Event, EventRegistration, Donation, MedicalWaiver, 
    MerchItem, MerchOrder, UserBlock
)
from . import event_requests
import math


async def check_if_users_exist(session: AsyncSession) -> bool:
    user_count = await session.scalar(select(func.count(User.id)))
    return user_count > 0


# --- User Management ---
async def find_user_for_admin(session: AsyncSession, query: str) -> User | None:
    stmt = select(User).where(
        or_(
            User.full_name.ilike(f"%{query}%"),
            User.telegram_username.ilike(f"%{query}%"),
            User.telegram_id.cast(String).ilike(f"%{query}%"),
            User.phone_number.ilike(f"%{query}%")
        )
    ).order_by(User.full_name)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_users_page(session: AsyncSession, page: int = 1, page_size: int = 10) -> tuple[list[User], int]:
    offset = (page - 1) * page_size
    total_count = (await session.execute(select(func.count(User.id)))).scalar_one()
    items_result = await session.execute(select(User).order_by(User.full_name).offset(offset).limit(page_size))
    items = items_result.scalars().all()
    total_pages = math.ceil(total_count / page_size) if total_count > 0 else 1
    return items, total_pages

async def get_all_users(session: AsyncSession) -> list[User]:
    stmt = select(User).order_by(User.full_name)
    result = await session.execute(stmt)
    return result.scalars().all()

async def change_user_role(session: AsyncSession, user_id: int, new_role: str):
    stmt = update(User).where(User.id == user_id).values(role=new_role)
    await session.execute(stmt)
    await session.commit()

async def add_points_to_user(session: AsyncSession, user_id: int, points: int, reason: str):
    user = await session.get(User, user_id)
    user.points += points
    # log: # Здесь можно добавить логирование этой операции в отдельную таблицу
    await session.commit()

async def block_user(session: AsyncSession, user_id: int, admin_id: int, reason: str):
    user = await session.get(User, user_id)
    user.is_blocked = True
    block_record = UserBlock(user_id=user_id, admin_id=admin_id, reason=reason, is_active=True)
    session.add(block_record)
    # log: # Можно добавить логирование блокировки
    await session.commit()

async def unblock_user(session: AsyncSession, user_id: int):
    user = await session.get(User, user_id)
    user.is_blocked = False
    stmt = update(UserBlock).where(UserBlock.user_id == user_id, UserBlock.is_active == True).values(is_active=False)
    await session.execute(stmt)
    # log: # Можно добавить логирование разблокировки
    await session.commit()

# --- Event Management ---
async def create_event(session: AsyncSession, data: dict) -> Event:
    event = Event(**data)
    session.add(event)
    await session.commit()
    return event

async def update_event_field(session: AsyncSession, event_id: int, field_name: str, new_value: any):
    if not hasattr(Event, field_name):
        return
    stmt = update(Event).where(Event.id == event_id).values({field_name: new_value})
    await session.execute(stmt)
    await session.commit()

# --- Merch Management ---
async def create_merch_item(session: AsyncSession, data: dict) -> MerchItem:
    item = MerchItem(**data)
    session.add(item)
    await session.commit()
    return item

# --- Order Processing ---
async def get_pending_orders(session: AsyncSession) -> list[MerchOrder]:
    stmt = select(MerchOrder).options(joinedload(MerchOrder.user), joinedload(MerchOrder.item)).where(MerchOrder.status == 'pending_pickup').order_by(MerchOrder.order_date)
    result = await session.execute(stmt)
    return result.scalars().all()

async def complete_order(session: AsyncSession, order_id: int, admin_id: int):
    order = await session.get(MerchOrder, order_id)
    if order:
        order.status = 'completed'
        order.completed_by_admin_id = admin_id
        order.completion_date = datetime.datetime.now()
        # log: # Можно добавить логирование подтверждения заказа
        await session.commit()

# --- Manual Waiver ---
async def create_manual_waiver(session: AsyncSession, user_id: int, end_date: datetime.date, reason: str, admin_id: int):
    waiver = MedicalWaiver(
        user_id=user_id,
        start_date=datetime.date.today(),
        end_date=end_date,
        reason=reason,
        created_by=str(admin_id)
    )
    session.add(waiver)
    # log: # Можно добавить логирование создания медотвода
    await session.commit()

# --- Export Functions ---
async def get_all_donations(session: AsyncSession) -> list:
    stmt = select(Donation).options(
        joinedload(Donation.user),
        joinedload(Donation.event)
    ).order_by(Donation.donation_date.desc())
    result = await session.execute(stmt)
    return result.scalars().all()

# --- Main Admin Setup ---
async def create_main_admin(session: AsyncSession, tg_id: int, tg_username: str, full_name: str):
    new_admin = User(
        phone_number=f"admin_{tg_id}",
        telegram_id=tg_id,
        telegram_username=tg_username,
        full_name=full_name,
        role='main_admin'
    )
    session.add(new_admin)
    # log: # Можно добавить логирование создания главного админа
    await session.commit()

async def update_main_admin_data(session: AsyncSession, tg_id: int, tg_username: str, full_name: str):
    stmt = (
        update(User)
        .where(User.telegram_id == tg_id)
        .values(
            role='main_admin',
            telegram_username=tg_username,
            full_name=full_name
        )
    )
    await session.execute(stmt)
    # log: # Можно добавить логирование обновления данных главного админа
    await session.commit()

async def get_event_registrations_count(session: AsyncSession, event_id: int) -> int:
    stmt = select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event_id)
    result = await session.execute(stmt)
    return result.scalar_one()

async def get_event_with_participants(session: AsyncSession, event_id: int):
    stmt = select(Event).options(selectinload(Event.registrations).joinedload(EventRegistration.user)).where(Event.id == event_id)
    result = await session.execute(stmt)
    event = result.scalar_one_or_none()
    if not event:
        return None, []
    return event, event.registrations

async def deactivate_event(session: AsyncSession, event_id: int):
    stmt = update(Event).where(Event.id == event_id).values(is_active=False)
    await session.execute(stmt)
    await session.commit()

async def get_all_merch_items(session: AsyncSession) -> list[MerchItem]:
    stmt = select(MerchItem).order_by(MerchItem.id)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_merch_item_by_id(session: AsyncSession, item_id: int) -> MerchItem | None:
    return await session.get(MerchItem, item_id)

async def update_merch_item_field(session: AsyncSession, item_id: int, field_name: str, new_value: any):
    if not hasattr(MerchItem, field_name):
        return
    stmt = update(MerchItem).where(MerchItem.id == item_id).values({field_name: new_value})
    await session.execute(stmt)
    await session.commit()

async def toggle_merch_item_availability(session: AsyncSession, item_id: int) -> bool:
    item = await session.get(MerchItem, item_id)
    if not item:
        return False
    item.is_available = not item.is_available
    await session.commit()
    return item.is_available

async def delete_merch_item_by_id(session: AsyncSession, item_id: int):
    item = await session.get(MerchItem, item_id)
    if item:
        await session.delete(item)
        await session.commit()

# --- Export Functions ---
async def get_all_data_for_export(session: AsyncSession) -> dict:
    data_to_export = {
        "users": (await session.execute(select(User))).scalars().all(),
        "events": (await session.execute(select(Event))).scalars().all(),
        "event_registrations": (await session.execute(select(EventRegistration))).scalars().all(),
        "donations": (await session.execute(select(Donation))).scalars().all(),
        "medical_waivers": (await session.execute(select(MedicalWaiver))).scalars().all(),
        "merch_items": (await session.execute(select(MerchItem))).scalars().all(),
        "merch_orders": (await session.execute(select(MerchOrder))).scalars().all(),
        "user_blocks": (await session.execute(select(UserBlock))).scalars().all(),
    }
    return data_to_export



async def toggle_event_registration_status(session: AsyncSession, event_id: int) -> bool:
    """Переключает статус регистрации на мероприятие (открыта/закрыта)."""
    event = await session.get(Event, event_id)
    if not event:
        return False
    event.registration_is_open = not event.registration_is_open
    await session.commit()
    return event.registration_is_open



async def get_user_registrations(session: AsyncSession, user_id: int) -> list[EventRegistration]:
    """Получает все активные регистрации пользователя на будущие мероприятия."""
    stmt = (
        select(EventRegistration)
        .join(EventRegistration.event)
        .where(
            EventRegistration.user_id == user_id,
            Event.event_date >= datetime.date.today(),
            EventRegistration.status == 'registered'
        )
        .options(joinedload(EventRegistration.event))
        .order_by(Event.event_date)
    )
    result = await session.execute(stmt)
    return result.scalars().all()


async def manually_register_user(session: AsyncSession, user: User, event: Event) -> tuple[bool, str]:
    """
    Регистрирует пользователя на мероприятие вручную от имени администратора.
    Проверяет все условия, кроме статуса открытой регистрации.
    """
    # 1. Проверка на блокировку
    if user.is_blocked:
        return False, "Пользователь заблокирован."

    # 2. Проверка на существующую регистрацию
    existing_reg = await event_requests.find_specific_registration(session, user.id, event.id)
    if existing_reg:
        return False, "Пользователь уже зарегистрирован на это мероприятие."

    # 3. Проверка на медотводы (частично используем логику из check_registration_eligibility)
    waiver_stmt = select(MedicalWaiver).where(MedicalWaiver.user_id == user.id, MedicalWaiver.end_date >= event.event_date)
    active_waiver = (await session.execute(waiver_stmt)).scalar_one_or_none()
    if active_waiver:
        return False, f"У пользователя действует отвод до {active_waiver.end_date.strftime('%d.%m.%Y')}."

    # Если все проверки пройдены, регистрируем
    await event_requests.add_event_registration(session, user.id, event.id)
    return True, f"Пользователь {user.full_name} успешно записан на {event.name}."


async def get_all_user_active_waivers(session: AsyncSession, user_id: int) -> list[MedicalWaiver]:
    """Получает ВСЕ активные медотводы пользователя (и системные, и личные)."""
    stmt = select(MedicalWaiver).where(
        MedicalWaiver.user_id == user_id,
        MedicalWaiver.end_date >= datetime.date.today()
    ).order_by(MedicalWaiver.end_date)
    result = await session.execute(stmt)
    return result.scalars().all()


async def force_delete_waiver(session: AsyncSession, waiver_id: int) -> bool:
    """Принудительно удаляет медотвод по его ID. Возвращает True в случае успеха."""
    stmt = delete(MedicalWaiver).where(MedicalWaiver.id == waiver_id)
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0

--- КОНЕЦ ФАЙЛА: bot/db/admin_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/engine.py ---

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from bot.config_reader import config
from bot.db.models import Base

engine = create_async_engine(
    url=config.database_url,
    echo=False 
)

async_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def create_db_and_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

--- КОНЕЦ ФАЙЛА: bot/db/engine.py ---

--- НАЧАЛО ФАЙЛА: bot/db/event_requests.py ---

# bot/db/event_requests.py

import datetime
from sqlalchemy import select, func, delete, or_
from sqlalchemy.ext.asyncio import AsyncSession
from .models import User, Event, EventRegistration, Donation, MedicalWaiver
from sqlalchemy.orm import joinedload

async def get_active_events(session: AsyncSession) -> list[Event]:
    # Эта функция остается без изменений. Она нужна для админов, 
    # чтобы они видели ВСЕ активные мероприятия для управления.
    stmt = select(Event).where(Event.is_active == True, Event.event_date >= datetime.date.today()).order_by(Event.event_date)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_active_events_for_user(session: AsyncSession, user_id: int) -> list[Event]:
    """
    Получает список активных мероприятий, доступных для конкретного пользователя.
    Включает мероприятия с открытой регистрацией ИЛИ те, на которые пользователь уже записан.
    """
    # Подзапрос, чтобы найти ID мероприятий, на которые пользователь уже зарегистрирован
    user_registrations_subquery = select(EventRegistration.event_id).where(EventRegistration.user_id == user_id)
    
    # Основной запрос
    stmt = (
        select(Event)
        .where(
            Event.is_active == True, 
            Event.event_date >= datetime.date.today(),
            # Условие: показать мероприятие, если (регистрация открыта) ИЛИ (ID мероприятия есть в подзапросе)
            or_(
                Event.registration_is_open == True,
                Event.id.in_(user_registrations_subquery)
            )
        )
        .order_by(Event.event_date)
    )
    result = await session.execute(stmt)
    return result.scalars().all()


async def get_upcoming_events(session: AsyncSession) -> list[Event]:
    """Возвращает список всех активных мероприятий, которые пройдут сегодня или в будущем."""
    stmt = select(Event).where(
        Event.is_active == True, 
        Event.event_date >= datetime.date.today()
    ).order_by(Event.event_date)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_event_by_id(session: AsyncSession, event_id: int) -> Event | None:
    # Мероприятие по ID
    return await session.get(Event, event_id)

async def check_registration_eligibility(session: AsyncSession, user: User, event: Event) -> tuple[bool, str]:
    # Проверка возможности регистрации
    if not event.registration_is_open:
        return False, "Регистрация на это мероприятие закрыта."
    
    existing_registration_stmt = select(EventRegistration).where(
        EventRegistration.user_id == user.id,
        EventRegistration.event_id == event.id
    )
    existing_registration = (await session.execute(existing_registration_stmt)).scalar_one_or_none()
    if existing_registration:
        return False, f"Вы уже зарегистрированы на это мероприятие ({event.name})."

    reg_count = await session.scalar(select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event.id))
    if reg_count >= event.participant_limit:
        return False, f"Достигнут лимит участников ({event.participant_limit})."

    waiver_stmt = select(MedicalWaiver).where(MedicalWaiver.user_id == user.id, MedicalWaiver.end_date >= event.event_date)
    active_waiver = (await session.execute(waiver_stmt)).scalar_one_or_none()
    if active_waiver:
        return False, f"У вас действует отвод до {active_waiver.end_date.strftime('%d.%m.%Y')}. Причина: {active_waiver.reason}."

    donation_type = event.donation_type
    last_donation_stmt = select(func.max(Donation.donation_date)).where(Donation.user_id == user.id, Donation.donation_type == donation_type)
    last_donation_date = (await session.execute(last_donation_stmt)).scalar_one_or_none()

    one_year_ago = event.event_date - datetime.timedelta(days=365)
    yearly_donations_stmt = select(func.count(Donation.id)).where(Donation.user_id == user.id, Donation.donation_type == donation_type, Donation.donation_date > one_year_ago)
    yearly_donations_count = (await session.execute(yearly_donations_stmt)).scalar_one()

    if donation_type == 'whole_blood':
        interval, limit = (90, 4) if user.gender == 'female' else (60, 5)
        if yearly_donations_count >= limit: return False, f"Достигнут годовой лимит ({limit}) донаций цельной крови."
        if last_donation_date and (event.event_date - last_donation_date).days < interval:
            next_date = last_donation_date + datetime.timedelta(days=interval)
            return False, f"Интервал после сдачи крови — {interval} дней. Следующая дата: {next_date.strftime('%d.%m.%Y')}."
    elif donation_type in ['plasma', 'platelets', 'erythrocytes']:
        interval, limit = 14, 12
        if yearly_donations_count >= limit: return False, f"Достигнут годовой лимит ({limit}) донаций компонентов."
        if last_donation_date and (event.event_date - last_donation_date).days < interval:
            next_date = last_donation_date + datetime.timedelta(days=interval)
            return False, f"Интервал после сдачи компонентов — {interval} дней. Следующая дата: {next_date.strftime('%d.%m.%Y')}."

    return True, "Все проверки пройдены."

async def add_event_registration(session: AsyncSession, user_id: int, event_id: int) -> EventRegistration:
    # Создать регистрацию и проверить, не нужно ли ее закрыть
    registration = EventRegistration(user_id=user_id, event_id=event_id)
    session.add(registration)
    
    # Получаем текущее количество регистраций и само мероприятие
    reg_count = await session.scalar(
        select(func.count(EventRegistration.id)).where(EventRegistration.event_id == event_id)
    )
    event = await session.get(Event, event_id)
    
    # Если количество регистраций достигло лимита, закрываем регистрацию
    if event and reg_count >= event.participant_limit:
        event.registration_is_open = False
        
    await session.commit()
    return registration

# --- ВОТ ЭТА ФУНКЦИЯ ОТСУТСТВОВАЛА ---
async def find_specific_registration(session: AsyncSession, user_id: int, event_id: int) -> EventRegistration | None:
    # Найти регистрацию пользователя на мероприятие
    stmt = select(EventRegistration).options(
        joinedload(EventRegistration.event)
    ).where(
        EventRegistration.user_id == user_id,
        EventRegistration.event_id == event_id,
        EventRegistration.status == 'registered'
    )
    result = await session.execute(stmt)
    return result.scalar_one_or_none()
# ------------------------------------

async def confirm_donation_transaction(session: AsyncSession, user: User, registration: EventRegistration) -> tuple[int, datetime.date]:
    # Подтвердить донацию
    event = await session.get(Event, registration.event_id)
    is_rare_blood = user.rh_factor == '-' or user.blood_type == 'AB(IV)'
    points_to_award = event.points_per_donation + (event.rare_blood_bonus_points if is_rare_blood else 0)

    donation = Donation(user_id=user.id, event_id=event.id, donation_date=event.event_date, donation_type=event.donation_type, points_awarded=points_to_award)
    days_waiver = (90 if user.gender == 'female' else 60) if event.donation_type == 'whole_blood' else 14
    end_date = event.event_date + datetime.timedelta(days=days_waiver)
    waiver = MedicalWaiver(user_id=user.id, start_date=event.event_date, end_date=end_date, reason=f"Сдача '{event.name}'", created_by='system')

    user.points += points_to_award
    registration.status = 'attended'

    session.add_all([donation, waiver])
    await session.commit()
    return points_to_award, end_date

async def cancel_registration(session: AsyncSession, user_id: int, event_id: int) -> bool:
    stmt = delete(EventRegistration).where(
        EventRegistration.user_id == user_id,
        EventRegistration.event_id == event_id
    )
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0

--- КОНЕЦ ФАЙЛА: bot/db/event_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/merch_requests.py ---

import math
from sqlalchemy import select, func
from sqlalchemy.orm import joinedload
from sqlalchemy.ext.asyncio import AsyncSession
from .models import User, MerchItem, MerchOrder

async def get_merch_page(session: AsyncSession, page: int = 1) -> tuple[MerchItem | None, int]:
    page_size = 1
    offset = (page - 1) * page_size
    total_count_stmt = select(func.count(MerchItem.id)).where(MerchItem.is_available == True)
    total_items = (await session.execute(total_count_stmt)).scalar_one()
    
    if total_items == 0:
        return None, 0
    item_stmt = select(MerchItem).where(MerchItem.is_available == True).order_by(MerchItem.id).offset(offset).limit(page_size)
    item_result = await session.execute(item_stmt)
    item = item_result.scalar_one_or_none()
    
    return item, total_items

async def get_merch_item_by_id(session: AsyncSession, item_id: int) -> MerchItem | None:
    return await session.get(MerchItem, item_id)

async def create_merch_order(session: AsyncSession, user: User, item: MerchItem) -> tuple[bool, str]:
    if user.points < item.price:
        return False, "Недостаточно баллов."

    user.points -= item.price
    order = MerchOrder(user_id=user.id, item_id=item.id)
    session.add(order)
    return True, f"Покупка совершена! Ваш баланс: {user.points} баллов."

async def get_user_orders(session: AsyncSession, user_id: int) -> list[MerchOrder]:
    stmt = select(MerchOrder).options(joinedload(MerchOrder.item)).where(MerchOrder.user_id == user_id).order_by(MerchOrder.order_date.desc())
    result = await session.execute(stmt)
    return result.scalars().all()

--- КОНЕЦ ФАЙЛА: bot/db/merch_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/models.py ---

import datetime
from typing import List
from sqlalchemy import (
    String, BigInteger, ForeignKey,
    Integer, Boolean, DateTime, Date, Text, func
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship

class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = 'users'
    id: Mapped[int] = mapped_column(primary_key=True)
    phone_number: Mapped[str] = mapped_column(String(20), unique=True, nullable=False, index=True)
    telegram_id: Mapped[int] = mapped_column(BigInteger, unique=True, nullable=False, index=True)
    telegram_username: Mapped[str] = mapped_column(String(255), nullable=True, index=True)
    full_name: Mapped[str] = mapped_column(String(255), index=True)
    university: Mapped[str] = mapped_column(String(100), default='МИФИ')
    faculty: Mapped[str] = mapped_column(String(100), nullable=True)
    study_group: Mapped[str] = mapped_column(String(50), nullable=True)
    blood_type: Mapped[str] = mapped_column(String(10), nullable=True)
    rh_factor: Mapped[str] = mapped_column(String(1), nullable=True)
    gender: Mapped[str] = mapped_column(String(10), nullable=True)
    points: Mapped[int] = mapped_column(Integer, default=0)
    role: Mapped[str] = mapped_column(String(50), default='student')
    is_blocked: Mapped[bool] = mapped_column(Boolean, default=False)
    created_at: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

    donations: Mapped[List["Donation"]] = relationship(back_populates="user")
    registrations: Mapped[List["EventRegistration"]] = relationship(back_populates="user", cascade="all, delete-orphan")
    waivers: Mapped[List["MedicalWaiver"]] = relationship(back_populates="user")
    orders: Mapped[List["MerchOrder"]] = relationship(foreign_keys="MerchOrder.user_id", back_populates="user", cascade="all, delete-orphan")
    blocks_given: Mapped[List["UserBlock"]] = relationship(foreign_keys="UserBlock.admin_id", back_populates="admin")
    blocks_received: Mapped[List["UserBlock"]] = relationship(foreign_keys="UserBlock.user_id", back_populates="blocked_user")


class Event(Base):
    __tablename__ = 'events'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255))
    event_date: Mapped[datetime.date] = mapped_column(Date)
    location: Mapped[str] = mapped_column(Text)
    donation_type: Mapped[str] = mapped_column(String(50))
    points_per_donation: Mapped[int] = mapped_column(Integer)
    rare_blood_bonus_points: Mapped[int] = mapped_column(Integer, default=0)
    participant_limit: Mapped[int] = mapped_column(Integer)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    registration_is_open: Mapped[bool] = mapped_column(Boolean, default=True, server_default='t')
    registrations: Mapped[List["EventRegistration"]] = relationship(back_populates="event")

class EventRegistration(Base):
    __tablename__ = 'event_registrations'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'), index=True)
    status: Mapped[str] = mapped_column(String(50), default='registered')
    registration_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

    user: Mapped["User"] = relationship(back_populates="registrations")
    event: Mapped["Event"] = relationship(back_populates="registrations")

class Donation(Base):
    __tablename__ = 'donations'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    event_id: Mapped[int] = mapped_column(ForeignKey('events.id'), nullable=True, index=True)
    donation_date: Mapped[datetime.date] = mapped_column(Date)
    donation_type: Mapped[str] = mapped_column(String(50))
    points_awarded: Mapped[int] = mapped_column(Integer)

    user: Mapped["User"] = relationship(back_populates="donations")

class MedicalWaiver(Base):
    __tablename__ = 'medical_waivers'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    start_date: Mapped[datetime.date] = mapped_column(Date)
    end_date: Mapped[datetime.date] = mapped_column(Date)
    reason: Mapped[str] = mapped_column(Text)
    created_by: Mapped[str] = mapped_column(String(50))

    user: Mapped["User"] = relationship(back_populates="waivers")

class MerchItem(Base):
    __tablename__ = 'merch_items'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255))
    description: Mapped[str] = mapped_column(Text)
    price: Mapped[int] = mapped_column(Integer)
    photo_file_id: Mapped[str] = mapped_column(String(255))
    is_available: Mapped[bool] = mapped_column(Boolean, default=True)

    orders: Mapped[List["MerchOrder"]] = relationship(back_populates="item")

class MerchOrder(Base):
    __tablename__ = 'merch_orders'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'), index=True)
    item_id: Mapped[int] = mapped_column(ForeignKey('merch_items.id'))
    order_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    status: Mapped[str] = mapped_column(String(50), default='pending_pickup')
    completed_by_admin_id: Mapped[int] = mapped_column(ForeignKey('users.id'), nullable=True)
    completion_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), nullable=True)

    user: Mapped["User"] = relationship(foreign_keys=[user_id], back_populates="orders")
    item: Mapped["MerchItem"] = relationship(back_populates="orders")
    completed_by_admin: Mapped["User"] = relationship(foreign_keys=[completed_by_admin_id])


class UserBlock(Base):
    __tablename__ = 'user_blocks'
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    admin_id: Mapped[int] = mapped_column(ForeignKey('users.id'))
    block_date: Mapped[datetime.datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    reason: Mapped[str] = mapped_column(Text)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    
    blocked_user: Mapped["User"] = relationship(foreign_keys=[user_id], back_populates="blocks_received")
    admin: Mapped["User"] = relationship(foreign_keys=[admin_id], back_populates="blocks_given")

--- КОНЕЦ ФАЙЛА: bot/db/models.py ---

--- НАЧАЛО ФАЙЛА: bot/db/user_requests.py ---

import datetime
from sqlalchemy import select, func, update, delete 
from sqlalchemy.ext.asyncio import AsyncSession
from .models import User, Donation, MedicalWaiver
from sqlalchemy import and_, or_, not_
from sqlalchemy.orm import aliased
from .models import User, Donation, MedicalWaiver, Event
import logging
logger = logging.getLogger(__name__)


async def update_user_credentials(session: AsyncSession, user_id: int, new_tg_id: int, new_username: str | None):
    # Обновить Telegram ID и username
    stmt = update(User).where(User.id == user_id).values(
        telegram_id=new_tg_id,
        telegram_username=new_username
    )
    await session.execute(stmt)
    await session.commit()


async def get_user_by_phone(session: AsyncSession, phone: str) -> User | None:
    # Найти пользователя по телефону
    stmt = select(User).where(User.phone_number == phone)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def get_user_by_tg_id(session: AsyncSession, tg_id: int) -> User | None:
    # Найти пользователя по Telegram ID
    stmt = select(User).where(User.telegram_id == tg_id)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

async def add_user(session: AsyncSession, data: dict) -> User:
    # Добавить пользователя
    user = User(**data)
    session.add(user)
    await session.commit()
    return user

async def update_user_tg_id(session: AsyncSession, user_id: int, new_tg_id: int):
    # Обновить Telegram ID
    stmt = update(User).where(User.id == user_id).values(telegram_id=new_tg_id)
    await session.execute(stmt)
    await session.commit()
    
async def update_user_profile(session: AsyncSession, user_id: int, data: dict):
    # Обновить профиль пользователя
    stmt = update(User).where(User.id == user_id).values(**data)
    await session.execute(stmt)
    await session.commit()

async def get_user_profile_info(session: AsyncSession, user_id: int) -> dict | None:
    # Получить инфо профиля пользователя
    user = await session.get(User, user_id)
    if not user:
        return None

    stmt_last_donation = select(Donation.donation_date, Donation.donation_type).where(Donation.user_id == user.id).order_by(Donation.donation_date.desc()).limit(1)
    last_donation = (await session.execute(stmt_last_donation)).first()

    today = datetime.date.today()
    stmt_waiver = select(MedicalWaiver.end_date).where(MedicalWaiver.user_id == user.id, MedicalWaiver.end_date >= today).order_by(MedicalWaiver.end_date.desc()).limit(1)
    active_waiver_end_date = (await session.execute(stmt_waiver)).scalar_one_or_none()
    
    next_possible_donation = today
    if active_waiver_end_date:
        next_possible_donation = active_waiver_end_date + datetime.timedelta(days=1)
    elif last_donation:
        last_date, last_type = last_donation
        if last_type == 'whole_blood':
            interval = 90 if user.gender == 'female' else 60
            possible_date = last_date + datetime.timedelta(days=interval)
        else:
            interval = 14
            possible_date = last_date + datetime.timedelta(days=interval)
        next_possible_donation = max(next_possible_donation, possible_date)

    total_donations = await session.scalar(select(func.count(Donation.id)).where(Donation.user_id == user.id))

    return {
        "user": user,
        "total_donations": total_donations,
        "next_possible_donation": next_possible_donation
    }

async def get_user_donation_history(session: AsyncSession, user_id: int) -> list[Donation]:
    # История донаций пользователя
    stmt = select(Donation).where(Donation.user_id == user_id).order_by(Donation.donation_date.desc())
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_user_active_waivers(session: AsyncSession, user_id: int) -> list[MedicalWaiver]:
    # Активные медотводы пользователя
    stmt = select(MedicalWaiver).where(
        MedicalWaiver.user_id == user_id,
        MedicalWaiver.end_date >= datetime.date.today()
    ).order_by(MedicalWaiver.end_date)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_user_by_id(session: AsyncSession, user_id: int) -> User | None:
    # Найти пользователя по ID
    return await session.get(User, user_id)

async def get_all_users(session: AsyncSession) -> list[User]:
    # Все пользователи
    stmt = select(User).order_by(User.full_name)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_users_for_event_notification(session: AsyncSession, event: Event) -> list[User]:
    # Пользователи для уведомления о мероприятии
    # logger.info(f"--- Starting user filtering for event {event.id} ({event.name}) on {event.event_date} ---")
    
    active_waiver_subquery = (
        select(MedicalWaiver.user_id)
        .where(MedicalWaiver.end_date >= event.event_date)
        .distinct()
    ).subquery()
    
    query = select(User).where(
        not_(User.id.in_(select(active_waiver_subquery)))
    )
    
    initial_users = (await session.execute(query)).scalars().all()
    # logger.info(f"Initial check (no active waivers): Found {len(initial_users)} users.")
    if not initial_users:
        # logger.info("--- Filtering finished: No users after waiver check. ---")
        return []

    final_users_to_notify = []
    one_year_ago = event.event_date - datetime.timedelta(days=365)
    
    for user in initial_users:
        donations_stmt = select(Donation).where(
            Donation.user_id == user.id,
            Donation.donation_date > one_year_ago
        ).order_by(Donation.donation_date.desc())
        
        user_donations = (await session.execute(donations_stmt)).scalars().all()
        
        donations_of_type = [d for d in user_donations if d.donation_type == event.donation_type]
        
        is_ok = True
        reason = ""
        
        if event.donation_type == 'whole_blood':
            interval, limit = (90, 4) if user.gender == 'female' else (60, 5)
            if len(donations_of_type) >= limit:
                is_ok = False
                reason = f"Yearly limit reached ({len(donations_of_type)}/{limit})"
            if is_ok and donations_of_type:
                last_donation_date = donations_of_type[0].donation_date
                if (event.event_date - last_donation_date).days < interval:
                    is_ok = False
                    reason = f"Interval not passed ({(event.event_date - last_donation_date).days}/{interval} days)"
        
        elif event.donation_type in ['plasma', 'platelets', 'erythrocytes']:
            interval, limit = 14, 12
            if len(donations_of_type) >= limit:
                is_ok = False
                reason = f"Yearly limit reached ({len(donations_of_type)}/{limit})"
            if is_ok and donations_of_type:
                last_donation_date = donations_of_type[0].donation_date
                if (event.event_date - last_donation_date).days < interval:
                    is_ok = False
                    reason = f"Interval not passed ({(event.event_date - last_donation_date).days}/{interval} days)"

        if is_ok:
            final_users_to_notify.append(user)
            # logger.info(f"User {user.id} ({user.full_name}) PASSED filtering.")
        # else:
            # logger.info(f"User {user.id} ({user.full_name}) FAILED filtering. Reason: {reason}")
            
    # logger.info(f"--- Filtering finished: {len(final_users_to_notify)} users selected for notification. ---")
    return final_users_to_notify

async def get_users_by_criteria(session: AsyncSession, criteria: str) -> list[User]:
    # Пользователи по критерию
    if criteria == "all":
        stmt = select(User)
    elif criteria == "volunteers":
        stmt = select(User).where(User.role.in_(['volunteer', 'admin', 'main_admin']))
    elif criteria == "admins":
        stmt = select(User).where(User.role.in_(['admin', 'main_admin']))
    elif criteria == "can_donate":
        stmt = select(User).where(User.role == 'student')
    else:
        return []
        
    result = await session.execute(stmt)
    return result.scalars().all()


async def add_user_waiver(session: AsyncSession, user_id: int, end_date: datetime.date, reason: str):
    """Создает медотвод от имени пользователя."""
    waiver = MedicalWaiver(
        user_id=user_id,
        start_date=datetime.date.today(),
        end_date=end_date,
        reason=reason,
        created_by='user'  # Указываем, что создан пользователем
    )
    session.add(waiver)
    await session.commit()

async def delete_user_waiver(session: AsyncSession, waiver_id: int, user_id: int) -> bool:
    """
    Удаляет медотвод, если он был создан этим же пользователем.
    Возвращает True в случае успеха.
    """
    stmt = (
        delete(MedicalWaiver)
        .where(
            MedicalWaiver.id == waiver_id,
            MedicalWaiver.user_id == user_id,
            MedicalWaiver.created_by == 'user' # Главное условие!
        )
    )
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0
# --------------------------------------------------------

--- КОНЕЦ ФАЙЛА: bot/db/user_requests.py ---

--- НАЧАЛО ФАЙЛА: bot/db/__init__.py ---

from . import user_requests
from . import event_requests
from . import merch_requests
from . import admin_requests

__all__ = [
    "user_requests",
    "event_requests",
    "merch_requests",
    "admin_requests",
]

--- КОНЕЦ ФАЙЛА: bot/db/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/filters/role.py ---

from typing import Union
from aiogram.filters import BaseFilter
from aiogram.types import Message, CallbackQuery
from bot.db import user_requests
from sqlalchemy.ext.asyncio import AsyncSession

ROLE_HIERARCHY = {
    'student': 0,
    'volunteer': 1,
    'admin': 2,
    'main_admin': 3
}

class RoleFilter(BaseFilter):
    def __init__(self, required_role: str):
        self.required_level = ROLE_HIERARCHY.get(required_role, 0)

    async def __call__(self, event: Union[Message, CallbackQuery], session: AsyncSession) -> bool:
        user = await user_requests.get_user_by_tg_id(session, event.from_user.id)
        if not user:
            return False
        
        if user.is_blocked:
            return False
            
        user_level = ROLE_HIERARCHY.get(user.role, 0)
        return user_level >= self.required_level

--- КОНЕЦ ФАЙЛА: bot/filters/role.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin.py ---

import io
import csv
import logging
import zipfile
import datetime
import asyncio

from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.markdown import hbold, hlink, hcode
from aiogram.exceptions import TelegramBadRequest

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload

from bot.db.engine import async_session_maker
from bot.db import admin_requests, user_requests, event_requests
from bot.filters.role import RoleFilter
from bot.states.states import (
    EventCreation,
    MerchCreation,
    PointsChange,
    ManualWaiver,
    EventEditing,
    MerchEditing,
    Mailing,
    UserSearch,
    BlockUser,
    AdminManagement,
)
from bot.keyboards import inline
from bot.db.models import MerchOrder
from bot.utils.text_messages import Text
from bot.db.models import Event

# Настройка роутера и логгера
router = Router()
logger = logging.getLogger(__name__)

# --- ⚙️ ГЛАВНОЕ МЕНЮ АДМИНИСТРАТОРА ---
@router.callback_query(F.data == "admin_panel", RoleFilter('admin'))
async def show_admin_panel(callback: types.CallbackQuery, session: AsyncSession):
    """Отображает главную панель администратора с динамическими кнопками."""
    
    # Получаем роль пользователя, который нажал на кнопку
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer: return

    await callback.message.edit_text(
        text="⚙️ *Панель администратора*",
        # Передаем роль в функцию создания клавиатуры
        reply_markup=inline.get_admin_panel_keyboard(viewer.role),
        parse_mode="Markdown"
    )
    await callback.answer()

# =============================================================================
# --- 👥 УПРАВЛЕНИЕ ПОЛЬЗОВАТЕЛЯМИ (НОВАЯ ВЕРСИЯ) ---
# =============================================================================

@router.callback_query(F.data == "admin_manage_users", RoleFilter('admin'))
async def manage_users_main_menu(callback: types.CallbackQuery):
    """Показывает главное меню управления пользователями."""
    await callback.message.edit_text(
        "👥 *Управление пользователями*",
        reply_markup=inline.get_user_management_main_keyboard(),
        parse_mode="Markdown"
    )
    await callback.answer()

# --- Список пользователей с пагинацией ---
@router.callback_query(F.data.startswith("admin_users_list_page_"), RoleFilter('admin'))
async def show_users_list(callback: types.CallbackQuery, session: AsyncSession):
    page = int(callback.data.split('_')[-1])
    page_size = 10

    users, total_pages = await admin_requests.get_users_page(session, page, page_size)

    if not users:
        await callback.message.edit_text("В базе данных пока нет пользователей.", reply_markup=inline.get_user_management_main_keyboard())
        await callback.answer()
        return

    text = f"📜 *Список пользователей (Страница {page}/{total_pages})*\n\n"
    builder = InlineKeyboardBuilder()
    for user in users:
        # Добавляем кнопку для каждого пользователя
        builder.row(types.InlineKeyboardButton(text=f"👤 {user.full_name}", callback_data=f"admin_show_user_{user.id}"))
    
    # Добавляем кнопки пагинации
    pagination_keyboard = inline.get_users_list_pagination_keyboard(page, total_pages)
    for row in pagination_keyboard.inline_keyboard:
        builder.row(*row)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode="Markdown")
    await callback.answer()

# --- Поиск пользователя ---
@router.callback_query(F.data == "admin_search_user", RoleFilter('admin'))
async def search_user_start(callback: types.CallbackQuery, state: FSMContext):
    """Запускает FSM для поиска пользователя."""
    await state.clear()
    await state.set_state(UserSearch.awaiting_query)
    await callback.message.edit_text("🔍 Введите запрос для поиска (ФИО, username, ID, телефон):")
    await callback.answer()

@router.message(UserSearch.awaiting_query)
async def process_user_search(message: types.Message, state: FSMContext, session: AsyncSession):
    """Ищет пользователей по запросу и выводит результат."""
    await state.clear()
    query = message.text
    users_found = await admin_requests.find_user_for_admin(session, query)

    if not users_found:
        await message.answer("🤷‍♂️ По вашему запросу никого не найдено.", reply_markup=inline.get_user_management_main_keyboard())
        return

    text = f"🔍 *Результаты поиска по запросу «{query}»:*\n\n"
    builder = InlineKeyboardBuilder()
    for user in users_found:
        builder.row(types.InlineKeyboardButton(text=f"👤 {user.full_name}", callback_data=f"admin_show_user_{user.id}"))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_users"))

    await message.answer(text, reply_markup=builder.as_markup())


# --- Карточка пользователя и управление им ---
@router.callback_query(F.data.startswith("admin_show_user_"), RoleFilter('admin'))
async def show_single_user_card(callback: types.CallbackQuery, session: AsyncSession):
    """
    Показывает карточку одного пользователя с динамической клавиатурой.
    """
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer: return

    target_user_id = int(callback.data.split('_')[-1])
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return
        
    block_status = "ЗАБЛОКИРОВАН" if target_user.is_blocked else "Активен"
    
    text_lines = [
        hbold(f"👤 Профиль пользователя: {target_user.full_name}"),
        "",
        f"  *ФИО:* {target_user.full_name}",
        f"  *ID:* {hcode(target_user.telegram_id)}",
        f"  *Username:* @{target_user.telegram_username or 'не указан'}",
        f"  *Телефон:* {hcode(target_user.phone_number)}",
        f"  *Роль:* {hcode(target_user.role)}",
        f"  *Баллы:* {hbold(str(target_user.points))}",
        f"  *Статус:* {hbold(block_status)}" # <-- Новая строка
    ]
    text = "\n".join(text_lines)
            
    await callback.message.edit_text(
        text, 
        # ИЗМЕНЕНИЕ ЗДЕСЬ: передаем is_blocked
        reply_markup=inline.get_user_management_keyboard(
            target_user_id=target_user.id, 
            target_user_role=target_user.role, 
            viewer_role=viewer.role,
            is_blocked=target_user.is_blocked
        ), 
        parse_mode="HTML"
    )
    await callback.answer()
    
@router.callback_query(F.data.startswith("admin_manage_user_regs_"), RoleFilter('admin'))
async def manage_user_registrations_menu(callback: types.CallbackQuery, session: AsyncSession):
    """Показывает меню управления регистрациями для конкретного пользователя."""
    user_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return

    await callback.message.edit_text(
        f"🎟️ Управление регистрациями для: *{user.full_name}*\n\nВыберите действие:",
        reply_markup=inline.get_manual_registration_management_keyboard(user_id),
        parse_mode="Markdown"
    )
    await callback.answer()


@router.callback_query(F.data.startswith("admin_reg_start_"), RoleFilter('admin'))
async def show_events_for_manual_registration(callback: types.CallbackQuery, session: AsyncSession):
    """Показывает список мероприятий для ручной записи."""
    user_id = int(callback.data.split('_')[-1])
    events = await event_requests.get_upcoming_events(session)
    if not events:
        await callback.answer("Нет предстоящих мероприятий для записи.", show_alert=True)
        return

    await callback.message.edit_text(
        "Выберите мероприятие, на которое нужно записать пользователя:",
        reply_markup=inline.get_events_for_manual_registration_keyboard(user_id, events)
    )
    await callback.answer()


@router.callback_query(F.data.startswith("adminReg_"), RoleFilter('admin'))
async def confirm_manual_registration(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """Обрабатывает ручную регистрацию."""
    # Теперь мы знаем, что у нас всегда 3 части
    prefix, user_id_str, event_id_str = callback.data.split('_')
    user_id, event_id = int(user_id_str), int(event_id_str)
    
    user = await user_requests.get_user_by_id(session, user_id)
    event = await event_requests.get_event_by_id(session, event_id)

    if not user or not event:
        await callback.answer("Ошибка: пользователь или мероприятие не найдены.", show_alert=True)
        return

    success, message = await admin_requests.manually_register_user(session, user, event)
    
    await callback.answer(message, show_alert=True)
    
    if success:
        # Уведомляем пользователя
        try:
            await bot.send_message(
                user.telegram_id,
                f"⚙️ Администратор записал вас на мероприятие «*{event.name}*» на {event.event_date.strftime('%d.%m.%Y')}.",
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about manual registration: {e}")
            await callback.message.answer(f"⚠️ Не удалось уведомить пользователя {user.full_name}.")
            
    # Возвращаемся в меню управления регистрациями
    await manage_user_registrations_menu(callback, session)


@router.callback_query(F.data.startswith("admin_cancel_start_"), RoleFilter('admin'))
async def show_registrations_for_cancellation(callback: types.CallbackQuery, session: AsyncSession):
    """Показывает регистрации пользователя для отмены."""
    user_id = int(callback.data.split('_')[-1])
    registrations = await admin_requests.get_user_registrations(session, user_id)
    
    if not registrations:
        await callback.answer("У этого пользователя нет активных регистраций на будущие мероприятия.", show_alert=True)
        return

    await callback.message.edit_text(
        "Выберите регистрацию, которую нужно отменить:",
        reply_markup=inline.get_registrations_for_cancellation_keyboard(user_id, registrations)
    )
    await callback.answer()


@router.callback_query(F.data.startswith("adminCancel_"), RoleFilter('admin'))
async def confirm_manual_cancellation(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """Обрабатывает отмену регистрации."""
    # Теперь мы знаем, что у нас всегда 3 части
    prefix, user_id_str, event_id_str = callback.data.split('_')
    user_id, event_id = int(user_id_str), int(event_id_str)

    user = await user_requests.get_user_by_id(session, user_id)
    event = await event_requests.get_event_by_id(session, event_id)

    if not user or not event:
        await callback.answer("Ошибка: пользователь или мероприятие не найдены.", show_alert=True)
        return
        
    success = await event_requests.cancel_registration(session, user_id, event_id)
    
    if success:
        message = f"Регистрация пользователя {user.full_name} на {event.name} отменена."
        await callback.answer(message, show_alert=True)
        try:
            await bot.send_message(
                user.telegram_id,
                f"⚙️ Администратор отменил вашу запись на мероприятие «*{event.name}*».",
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about manual cancellation: {e}")
            await callback.message.answer(f"⚠️ Не удалось уведомить пользователя {user.full_name}.")
    else:
        await callback.answer("Не удалось отменить регистрацию (возможно, уже отменена).", show_alert=True)
        
    # Возвращаемся в меню управления регистрациями
    await manage_user_registrations_menu(callback, session)

# --- +/- Баллы ---
@router.callback_query(F.data.startswith("admin_points_"), RoleFilter('admin'))
async def change_points_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    user_id = int(callback.data.split('_')[-1])
    await state.update_data(user_id=user_id)
    await state.set_state(PointsChange.awaiting_points_amount)
    await callback.message.edit_text("Введите сумму баллов для начисления (например, 50) или списания (-50):")
    await callback.answer()

@router.message(PointsChange.awaiting_points_amount)
async def change_points_amount(message: types.Message, state: FSMContext):
    try:
        points = int(message.text)
        await state.update_data(points=points)
        await state.set_state(PointsChange.awaiting_reason)
        await message.answer("Введите причину начисления/списания:")
    except ValueError:
        await message.answer("❌ Введите целое число.")

@router.message(PointsChange.awaiting_reason)
async def change_points_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason, user_id, points_change = message.text, data['user_id'], data['points']
    
    user = await user_requests.get_user_by_id(session, user_id)
    current_points = user.points
    await admin_requests.add_points_to_user(session, user_id, points_change, reason)
    await state.clear()
    
    new_balance = current_points + points_change
    await message.answer(f"✅ Баланс пользователя {user.full_name} изменен. Новый баланс: {new_balance}", reply_markup=inline.get_back_to_admin_panel_keyboard())
    
    try:
        await bot.send_message(user.telegram_id, f"⚙️ Администратор изменил ваш баланс на {points_change} баллов.\n*Причина:* {reason}\n*Ваш новый баланс:* {new_balance}", parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Failed to notify user {user_id} about points change: {e}")

# --- Установка медотвода ---
@router.callback_query(F.data.startswith("admin_waiver_"), RoleFilter('admin'))
async def set_waiver_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    user_id = int(callback.data.split('_')[-1])
    await state.update_data(user_id=user_id)
    await state.set_state(ManualWaiver.awaiting_end_date)
    await callback.message.edit_text("Введите дату окончания медотвода в формате ДД.ММ.ГГГГ:")
    await callback.answer()

@router.message(ManualWaiver.awaiting_end_date)
async def set_waiver_date(message: types.Message, state: FSMContext):
    try:
        end_date = datetime.datetime.strptime(message.text, "%d.%m.%Y").date()
        await state.update_data(end_date=end_date)
        await state.set_state(ManualWaiver.awaiting_reason)
        await message.answer("Введите причину медотвода:")
    except ValueError:
        await message.answer("❌ Неверный формат даты. Введите ДД.ММ.ГГГГ.")

@router.message(ManualWaiver.awaiting_reason)
async def set_waiver_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason, user_id, end_date = message.text, data['user_id'], data['end_date']
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    admin_internal_id = admin_user.id
    user = await user_requests.get_user_by_id(session, user_id)

    await admin_requests.create_manual_waiver(session, user_id, end_date, reason, admin_internal_id)
    await state.clear()

    await message.answer(f"✅ Медотвод для {user.full_name} установлен до {end_date.strftime('%d.%m.%Y')}.", reply_markup=inline.get_back_to_admin_panel_keyboard())
    
    try:
        await bot.send_message(user.telegram_id, f"⚕️ Администратор установил вам медотвод до {end_date.strftime('%d.%m.%Y')}.\n*Причина:* {reason}", parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Failed to notify user {user_id} about manual waiver: {e}")


@router.callback_query(F.data.startswith("admin_promote_volunteer_"), RoleFilter('admin'))
async def promote_to_volunteer(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """Назначает пользователю роль 'volunteer'."""
    user_id = int(callback.data.split('_')[-1])
    
    # Меняем роль в БД
    await admin_requests.change_user_role(session, user_id, 'volunteer')
    
    user = await user_requests.get_user_by_id(session, user_id)
    
    await callback.answer(f"✅ Пользователь {user.full_name} назначен волонтером.", show_alert=True)
    
    # Уведомляем пользователя о новой роли
    try:
        await bot.send_message(user.telegram_id, "⭐ Поздравляем! Администратор назначил вас волонтером. Вам доступно меню волонтера.")
    except Exception as e:
        logger.error(f"Failed to notify user {user.id} about promotion: {e}")

    # Обновляем карточку пользователя, чтобы показать новую роль и новые кнопки
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("admin_demote_volunteer_"), RoleFilter('admin'))
async def demote_from_volunteer(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """Снимает с пользователя роль 'volunteer', возвращая 'student'."""
    user_id = int(callback.data.split('_')[-1])

    # Меняем роль в БД
    await admin_requests.change_user_role(session, user_id, 'student')

    user = await user_requests.get_user_by_id(session, user_id)

    await callback.answer(f"✅ Пользователь {user.full_name} снят с должности волонтера.", show_alert=True)
    
    # Уведомляем пользователя
    try:
        await bot.send_message(user.telegram_id, "⚙️ Ваша роль изменена на 'студент'. Меню волонтера больше недоступно.")
    except Exception as e:
        logger.error(f"Failed to notify user {user.id} about demotion: {e}")

    # Обновляем карточку пользователя
    await show_single_user_card(callback, session)


# =============================================================================
# --- 🗓️ УПРАВЛЕНИЕ МЕРОПРИЯТИЯМИ ---
# =============================================================================

@router.callback_query(F.data == "admin_manage_events", RoleFilter('admin'))
async def manage_events_panel(callback: types.CallbackQuery):
    await callback.message.edit_text("🗓️ *Управление мероприятиями*", reply_markup=inline.get_events_management_keyboard(), parse_mode="Markdown")
    await callback.answer()

# --- Создание мероприятия ---
@router.callback_query(F.data == "admin_create_event", RoleFilter('admin'))
async def start_event_creation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(EventCreation.awaiting_name)
    await callback.message.edit_text("Шаг 1/7: Введите название мероприятия:")
    await callback.answer()

@router.message(EventCreation.awaiting_name)
async def process_event_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(EventCreation.awaiting_date)
    await message.answer("Шаг 2/7: Введите дату мероприятия (ДД.ММ.ГГГГ):")

@router.message(EventCreation.awaiting_date)
async def process_event_date(message: types.Message, state: FSMContext):
    try:
        event_date = datetime.datetime.strptime(message.text, "%d.%m.%Y").date()
        await state.update_data(event_date=event_date)
        await state.set_state(EventCreation.awaiting_location)
        await message.answer("Шаг 3/7: Введите место проведения:")
    except ValueError:
        await message.answer("❌ Неверный формат. Введите дату в формате ДД.ММ.ГГГГ.")

@router.message(EventCreation.awaiting_location)
async def process_event_location(message: types.Message, state: FSMContext):
    await state.update_data(location=message.text)
    await state.set_state(EventCreation.awaiting_donation_type)
    await message.answer("Шаг 4/7: Выберите тип донации:", reply_markup=inline.get_donation_type_keyboard())

@router.callback_query(EventCreation.awaiting_donation_type, F.data.startswith("settype_"))
async def process_event_donation_type(callback: types.CallbackQuery, state: FSMContext):
    donation_type = callback.data.split('_', 1)[1]
    await state.update_data(donation_type=donation_type)
    await state.set_state(EventCreation.awaiting_points)
    await callback.message.edit_text(f"Выбран тип: {donation_type}\n\nШаг 5/7: Введите количество баллов за донацию:")
    await callback.answer()

@router.message(EventCreation.awaiting_points)
async def process_event_points(message: types.Message, state: FSMContext):
    try:
        points = int(message.text)
        await state.update_data(points_per_donation=points)
        await state.set_state(EventCreation.awaiting_bonus_points)
        await message.answer("Шаг 6/7: Введите бонусные баллы за редкую кровь (можно 0):")
    except ValueError:
        await message.answer("❌ Введите целое число.")

@router.message(EventCreation.awaiting_bonus_points)
async def process_event_bonus_points(message: types.Message, state: FSMContext):
    try:
        bonus = int(message.text)
        await state.update_data(rare_blood_bonus_points=bonus)
        await state.set_state(EventCreation.awaiting_limit)
        await message.answer("Шаг 7/7: Введите лимит участников:")
    except ValueError:
        await message.answer("❌ Введите целое число.")
        
@router.message(EventCreation.awaiting_limit)
async def process_event_limit(message: types.Message, state: FSMContext):
    try:
        limit = int(message.text)
        await state.update_data(participant_limit=limit)
        
        # Переходим в состояние подтверждения
        await state.set_state(EventCreation.awaiting_confirmation)
        
        # Показываем все собранные данные для проверки
        event_data = await state.get_data()
        text = "✅ Все данные собраны. Пожалуйста, проверьте:\n\n"
        text += f"▪️ Название: {event_data['name']}\n"
        text += f"▪️ Дата: {event_data['event_date'].strftime('%d.%m.%Y')}\n"
        text += f"▪️ Место: {event_data['location']}\n"
        text += f"▪️ Тип: {event_data['donation_type']}\n"
        text += f"▪️ Баллы: {event_data['points_per_donation']} (+{event_data['rare_blood_bonus_points']})\n"
        text += f"▪️ Лимит: {event_data['participant_limit']}\n\n"
        text += "Создать мероприятие и запустить рассылку?"
        
        await message.answer(text, reply_markup=inline.get_event_creation_confirmation_keyboard())
        
    except ValueError:
        await message.answer("❌ Лимит должен быть числом.")
        
@router.callback_query(EventCreation.awaiting_confirmation, F.data == "confirm_create_event")
async def confirm_event_creation_and_notify(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    await callback.message.edit_text("Принято. Создаю мероприятие и готовлюсь к рассылке...")
    
    event_data = await state.get_data()
    await state.clear()
    
    new_event = await admin_requests.create_event(session, event_data)
    
    await callback.message.answer("✅ Мероприятие успешно создано!", reply_markup=inline.get_back_to_admin_panel_keyboard())
    
    await callback.message.answer("⏳ Начинаю рассылку. Это может занять некоторое время...")
    logger.info("Calling send_new_event_notifications DIRECTLY from confirmation handler.")
    
    await send_new_event_notifications(new_event, bot) # Используем прямой вызов для надежности
    
    logger.info("Direct call to send_new_event_notifications finished.")
    await callback.message.answer("✅ Рассылка уведомлений завершена.")
    await callback.answer()

# --- Просмотр и редактирование мероприятий ---
@router.callback_query(F.data == "admin_view_events", RoleFilter('admin'))
async def view_active_events(callback: types.CallbackQuery, session: AsyncSession):
    events = await event_requests.get_active_events(session)
    if not events:
        await callback.message.edit_text("Активных мероприятий нет.", reply_markup=inline.get_events_management_keyboard())
        await callback.answer()
        return

    builder = InlineKeyboardBuilder()
    for event in events:
        prefix = "✅" if event.registration_is_open else "🔒"
        builder.row(types.InlineKeyboardButton(
            text=f"{prefix} {event.event_date.strftime('%d.%m')} - {event.name}", 
            callback_data=f"admin_show_event_{event.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_events"))
    
    await callback.message.edit_text("Выберите мероприятие для управления:\n(✅ - регистрация открыта, 🔒 - закрыта)", reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("admin_show_event_"), RoleFilter('admin'))
async def show_single_event_card(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event:
        await callback.answer("Мероприятие не найдено.", show_alert=True)
        return

    reg_count = await admin_requests.get_event_registrations_count(session, event_id)
    reg_status_text = 'Открыта' if event.registration_is_open else 'Закрыта'
    text_lines = [
        f"🗓️ {hbold('Мероприятие: ' + event.name)}", "",
        f"▪️ {hbold('Дата:')} {event.event_date.strftime('%d.%m.%Y')}",
        f"▪️ {hbold('Место:')} {event.location}",
        f"▪️ {hbold('Тип донации:')} {event.donation_type}",
        f"▪️ {hbold('Баллы:')} {event.points_per_donation} (+{event.rare_blood_bonus_points} за редкую кровь)",
        f"▪️ {hbold('Записано/Лимит:')} {reg_count}/{event.participant_limit}",
        f"▪️ {hbold('Статус:')} {'Активно' if event.is_active else 'Закрыто'}"
        f"▪️ {hbold('Регистрация:')} {reg_status_text}"
    ]
    text = "\n".join(text_lines)

    await callback.message.edit_text(
        text, 
        reply_markup=inline.get_single_event_management_keyboard(event.id, event.registration_is_open), 
        parse_mode="HTML"
    )
    await callback.answer()
    
    
@router.callback_query(F.data.startswith("admin_toggle_reg_"), RoleFilter('admin'))
async def toggle_event_registration(callback: types.CallbackQuery, session: AsyncSession):
    """Обработчик для кнопки закрытия/открытия регистрации."""
    event_id = int(callback.data.split('_')[-1])
    
    new_status = await admin_requests.toggle_event_registration_status(session, event_id)
    status_text = "открыта" if new_status else "закрыта"
    await callback.answer(f"Регистрация на мероприятие теперь {status_text}.", show_alert=True)
    
    await show_single_event_card(callback, session)
    
# --- FSM для редактирования мероприятия ---
@router.callback_query(F.data.startswith("admin_edit_event_"), RoleFilter('admin'))
async def start_event_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event:
        await callback.answer("Мероприятие не найдено.", show_alert=True)
        return
        
    await state.update_data(event_id=event_id)
    await state.set_state(EventEditing.choosing_field)
    
    fields = {"name": "Название", "event_date": "Дата", "location": "Место", "points_per_donation": "Баллы", "participant_limit": "Лимит"}
    builder = InlineKeyboardBuilder()
    for key, name in fields.items():
        builder.row(types.InlineKeyboardButton(text=f"Изменить: {name}", callback_data=f"edit_field_{key}"))
    builder.row(types.InlineKeyboardButton(text="✅ Завершить", callback_data=f"admin_show_event_{event_id}"))
    
    await callback.message.edit_text(f"Вы редактируете: *{event.name}*\n\nКакое поле хотите изменить?", reply_markup=builder.as_markup(), parse_mode="Markdown")
    await callback.answer()

@router.callback_query(EventEditing.choosing_field, F.data.startswith("edit_field_"))
async def choose_field_to_edit(callback: types.CallbackQuery, state: FSMContext):
    field_to_edit = callback.data.split('_', 2)[-1]
    await state.update_data(field_to_edit=field_to_edit)
    await state.set_state(EventEditing.awaiting_new_value)
    
    prompts = {"name": "Введите новое название:", "event_date": "Введите новую дату (ДД.ММ.ГГГГ):", "location": "Введите новое место:", "points_per_donation": "Введите новое кол-во баллов:", "participant_limit": "Введите новый лимит:"}
    await callback.message.edit_text(prompts.get(field_to_edit, "Введите новое значение:"))
    await callback.answer()

@router.message(EventEditing.awaiting_new_value)
async def process_new_value_for_event(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    field, event_id, new_value_str = data.get("field_to_edit"), data.get("event_id"), message.text
    
    try:
        if field == "event_date": update_value = datetime.datetime.strptime(new_value_str, "%d.%m.%Y").date()
        elif field in ["points_per_donation", "participant_limit"]: update_value = int(new_value_str)
        else: update_value = new_value_str
    except ValueError:
        await message.answer("❌ Неверный формат данных. Попробуйте снова.")
        return
        
    await admin_requests.update_event_field(session, event_id, field, update_value)
    
    await state.set_state(EventEditing.choosing_field)
    
    event = await event_requests.get_event_by_id(session, event_id)
    fields_map = {"name": "Название", "event_date": "Дата", "location": "Место", "points_per_donation": "Баллы", "participant_limit": "Лимит"}

    builder = InlineKeyboardBuilder()
    for key, name in fields_map.items():
        builder.row(types.InlineKeyboardButton(text=f"Изменить: {name}", callback_data=f"edit_field_{key}"))
    builder.row(types.InlineKeyboardButton(text="✅ Завершить", callback_data=f"admin_show_event_{event_id}"))

    await message.answer(f"✅ Поле *{fields_map.get(field)}* обновлено!\n\nКакое еще поле хотите изменить?", reply_markup=builder.as_markup(), parse_mode="Markdown")

# --- Отмена мероприятия и список участников ---
@router.callback_query(F.data.startswith("admin_event_participants_"), RoleFilter('admin'))
async def get_event_participants(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event, participants = await admin_requests.get_event_with_participants(session, event_id)
    if not event:
        await callback.answer("Мероприятие не найдено", show_alert=True)
        return

    if not participants:
        await callback.answer(f"На '{event.name}' пока никто не записался.", show_alert=True)
        return

    output = io.StringIO()
    writer = csv.writer(output, delimiter=';')
    headers = ['ID', 'ФИО', 'Телефон', 'Факультет', 'Группа', 'Статус']
    writer.writerow(headers)
    for reg in participants:
        writer.writerow([reg.user.id, reg.user.full_name, reg.user.phone_number, reg.user.faculty, reg.user.study_group, reg.status])
    
    output.seek(0)
    file = types.BufferedInputFile(output.getvalue().encode('utf-8-sig'), filename=f"participants_{event.id}.csv")
    await callback.message.answer_document(file, caption=f"Участники мероприятия '{event.name}'")
    await callback.answer()

@router.callback_query(F.data.startswith("admin_cancel_event_"), RoleFilter('admin'))
async def ask_for_cancellation_confirmation(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event:
        await callback.answer("Мероприятие не найдено", show_alert=True)
        return
    reg_count = await admin_requests.get_event_registrations_count(session, event_id)
    await callback.message.edit_text(f"🚨 *Подтверждение отмены*\n\nВы уверены, что хотите отменить «*{event.name}*»?\n\nУведомление будет отправлено *{reg_count}* участникам.", reply_markup=inline.get_event_cancellation_confirmation_keyboard(event_id), parse_mode="Markdown")
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_cancel_"), RoleFilter('admin'))
async def confirm_and_cancel_event(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    await callback.message.edit_text("⏳ Начинаю процесс отмены...")
    event_id = int(callback.data.split('_')[-1])
    event, participants = await admin_requests.get_event_with_participants(session, event_id)
    if not event: return

    success_count, fail_count = 0, 0
    for reg in participants:
        try:
            text = (f"❗️ *Внимание, мероприятие отменено!*\n\nК сожалению, донорское мероприятие «*{event.name}*», запланированное на {event.event_date.strftime('%d.%m.%Y')}, было отменено.")
            await bot.send_message(chat_id=reg.user.telegram_id, text=text, parse_mode="Markdown")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.error(f"Failed to send cancellation to user {reg.user_id} for event {event.id}. Error: {e}")
        await asyncio.sleep(0.1)

    await admin_requests.deactivate_event(session, event_id)
    await callback.message.edit_text(f"✅ *Мероприятие «{event.name}» отменено.*\n\n*Результаты:*\n- Успешно отправлено: {success_count}\n- Ошибок: {fail_count}", reply_markup=inline.get_back_to_events_menu_keyboard())
    await callback.answer()

# =============================================================================
# --- 🛍️ УПРАВЛЕНИЕ МАГАЗИНОМ ---
# =============================================================================
@router.callback_query(F.data == "admin_manage_merch", RoleFilter('admin'))
async def manage_merch_panel(callback: types.CallbackQuery):
    await callback.message.edit_text("🛍️ *Управление магазином*", reply_markup=inline.get_merch_management_keyboard(), parse_mode="Markdown")
    await callback.answer()

# --- Создание товара ---
@router.callback_query(F.data == "admin_create_merch", RoleFilter('admin'))
async def start_merch_creation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear() # <-- ВОТ ЭТА СТРОКА
    await state.set_state(MerchCreation.awaiting_photo)
    await callback.message.edit_text("Отправьте фотографию для нового товара.")
    await callback.answer()

@router.message(MerchCreation.awaiting_photo, F.photo)
async def process_merch_photo(message: types.Message, state: FSMContext):
    photo_file_id = message.photo[-1].file_id
    
    # ОТЛАДОЧНЫЙ ЛОГ
    logger.info(f"Received photo for merch. File ID: {photo_file_id}")
    
    await state.update_data(photo_file_id=photo_file_id)
    await state.set_state(MerchCreation.awaiting_name)
    await message.answer("Отлично! Фото получено. Теперь введите название товара:")

@router.message(MerchCreation.awaiting_name)
async def process_merch_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(MerchCreation.awaiting_description)
    await message.answer("Название сохранено. Введите описание товара:")

@router.message(MerchCreation.awaiting_description)
async def process_merch_description(message: types.Message, state: FSMContext):
    await state.update_data(description=message.text)
    await state.set_state(MerchCreation.awaiting_price)
    await message.answer("Описание сохранено. Введите цену в баллах:")
    
@router.message(MerchCreation.awaiting_price)
async def process_merch_price(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        price = int(message.text)
        await state.update_data(price=price)
        item_data = await state.get_data()
        
        # ОТЛАДОЧНЫЙ ЛОГ
        logger.info(f"Attempting to create merch item with data: {item_data}")
        
        # Проверяем, есть ли photo_file_id
        if 'photo_file_id' not in item_data or not item_data['photo_file_id']:
            logger.error("photo_file_id is missing from FSM data!")
            await message.answer("❌ Произошла критическая ошибка: ID фотографии не был сохранен. Пожалуйста, начните заново.")
            await state.clear()
            return

        await admin_requests.create_merch_item(session, item_data)
        await state.clear()
        
        await message.answer("✅ Товар успешно добавлен в магазин!", reply_markup=inline.get_back_to_admin_panel_keyboard())
    except ValueError:
        await message.answer("❌ Цена должна быть целым числом. Попробуйте снова.")
# --- Просмотр и редактирование товаров ---
@router.callback_query(F.data == "admin_view_merch", RoleFilter('admin'))
async def view_merch_items(callback: types.CallbackQuery, session: AsyncSession):
    items = await admin_requests.get_all_merch_items(session)
    if not items:
        await callback.message.edit_text("В магазине пока нет товаров.", reply_markup=inline.get_merch_management_keyboard())
        return

    builder = InlineKeyboardBuilder()
    for item in items:
        status = "✅" if item.is_available else "❌"
        builder.row(types.InlineKeyboardButton(text=f"{status} {item.name} ({item.price}Б)", callback_data=f"admin_show_merch_{item.id}"))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_merch"))

    text = "Выберите товар для управления:"
    keyboard = builder.as_markup()
    try:
        await callback.message.edit_text(text, reply_markup=keyboard)
    except TelegramBadRequest:
        await callback.message.delete()
        await callback.message.answer(text, reply_markup=keyboard)
    await callback.answer()

@router.callback_query(F.data.startswith("admin_show_merch_"), RoleFilter('admin'))
async def show_single_merch_card(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer("Товар не найден", show_alert=True)

    caption = (f"🛍️ *Товар: {item.name}*\n\n"
               f"▪️ *Описание:* {item.description}\n"
               f"▪️ *Цена:* {item.price} баллов\n"
               f"▪️ *Статус:* {'✅ Доступен' if item.is_available else '❌ Недоступен'}")
    await callback.message.edit_media(media=types.InputMediaPhoto(media=item.photo_file_id, caption=caption, parse_mode="Markdown"),
        reply_markup=inline.get_single_merch_management_keyboard(item.id, item.is_available))
    await callback.answer()

@router.callback_query(F.data.startswith("admin_edit_merch_"), RoleFilter('admin'))
async def start_merch_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return

    await state.update_data(item_id=item_id)
    await state.set_state(MerchEditing.choosing_field)
    
    fields = {"name": "Название", "description": "Описание", "price": "Цена"}
    builder = InlineKeyboardBuilder()
    for key, name in fields.items():
        builder.row(types.InlineKeyboardButton(text=f"Изменить: {name}", callback_data=f"edit_merch_field_{key}"))
    builder.row(types.InlineKeyboardButton(text="✅ Завершить", callback_data=f"admin_show_merch_{item_id}"))
    
    await callback.message.edit_caption(caption=f"Вы редактируете: *{item.name}*\n\nКакое поле хотите изменить?", reply_markup=builder.as_markup(), parse_mode="Markdown")

@router.callback_query(MerchEditing.choosing_field, F.data.startswith("edit_merch_field_"))
async def choose_merch_field_to_edit(callback: types.CallbackQuery, state: FSMContext):
    field_to_edit = callback.data.split('_', 3)[-1]
    await state.update_data(field_to_edit=field_to_edit)
    await state.set_state(MerchEditing.awaiting_new_value)
    
    prompts = {"name": "Введите новое название:", "description": "Введите новое описание:", "price": "Введите новую цену в баллах:"}
    await callback.message.delete()
    await callback.message.answer(prompts.get(field_to_edit, "Введите новое значение:"))
    await callback.answer()

@router.message(MerchEditing.awaiting_new_value)
async def process_new_value_for_merch(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    field, item_id, new_value_str = data.get("field_to_edit"), data.get("item_id"), message.text
    try:
        update_value = int(new_value_str) if field == "price" else new_value_str
    except ValueError:
        await message.answer("❌ Цена должна быть числом.")
        return

    await admin_requests.update_merch_item_field(session, item_id, field, update_value)
    await message.answer("✅ Поле успешно обновлено!")
    await state.clear()
    
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    caption = (f"🛍️ *Товар: {item.name}*\n\n"
               f"▪️ *Описание:* {item.description}\n"
               f"▪️ *Цена:* {item.price} баллов\n"
               f"▪️ *Статус:* {'✅ Доступен' if item.is_available else '❌ Недоступен'}")
    await message.answer_photo(photo=item.photo_file_id, caption=caption,
        reply_markup=inline.get_single_merch_management_keyboard(item.id, item.is_available), parse_mode="Markdown")

@router.callback_query(F.data.startswith("admin_toggle_merch_"), RoleFilter('admin'))
async def toggle_merch_availability(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    new_status = await admin_requests.toggle_merch_item_availability(session, item_id)
    await callback.answer(f"Статус товара изменен. Теперь он {'доступен' if new_status else 'недоступен'}.", show_alert=True)
    await show_single_merch_card(callback, session)

@router.callback_query(F.data.startswith("admin_delete_merch_"), RoleFilter('admin'))
async def ask_for_merch_deletion_confirmation(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer("Товар не найден.", show_alert=True)
    
    try: await callback.message.delete()
    except TelegramBadRequest: pass
    
    await callback.message.answer(f"🗑️ *Подтверждение удаления*\n\nВы уверены, что хотите **безвозвратно** удалить «*{item.name}*»?",
        reply_markup=inline.get_merch_deletion_confirmation_keyboard(item_id), parse_mode="Markdown")
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_delete_merch_"), RoleFilter('admin'))
async def confirm_and_delete_merch(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer("Товар уже удален.", show_alert=True)
    
    item_name = item.name
    await admin_requests.delete_merch_item_by_id(session, item_id)
    await callback.message.edit_text(f"✅ Товар «*{item_name}*» был удален.", reply_markup=inline.get_back_to_merch_menu_keyboard(), parse_mode="Markdown")
    await callback.answer()


# =============================================================================
# --- 📦 ОБРАБОТКА ЗАКАЗОВ ---
# =============================================================================
@router.callback_query(F.data == "admin_process_orders", RoleFilter('admin'))
async def process_orders(callback: types.CallbackQuery, session: AsyncSession):
    orders = await admin_requests.get_pending_orders(session)
    if not orders:
        await callback.answer("Новых заказов нет.", show_alert=True)
        return
    
    text_parts = [hbold("📦 Новые заказы на выдачу:"), ""]
    
    builder = InlineKeyboardBuilder()
    for order in orders:
        # --- УЛУЧШЕННАЯ ЛОГИКА ФОРМИРОВАНИЯ КОНТАКТА ---
        
        # 1. Создаем кликабельную ссылку по ID
        user_link = hlink(order.user.full_name, f"tg://user?id={order.user.telegram_id}")
        
        # 2. Проверяем, есть ли у пользователя username
        if order.user.telegram_username:
            contact_info = f"{user_link} (@{order.user.telegram_username})"
        else:
            contact_info = user_link


        order_info = [
            f"🔹 {hbold(f'Заказ №{order.id}')} от {order.order_date.strftime('%d.%m %H:%M')}",
            f"   Товар: «{order.item.name}»",
            f"   Заказал: {contact_info}" 
            f"   Номер телефона: {order.user.phone_number}"
        ]
        text_parts.extend(order_info)
        text_parts.append("") # Пустая строка для отступа
        
        builder.row(types.InlineKeyboardButton(
            text=f"✅ Выдать заказ №{order.id}",
            callback_data=f"complete_order_{order.id}"
        ))
    
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    
    final_text = "\n".join(text_parts)
    
    await callback.message.edit_text(
        text=final_text, 
        reply_markup=builder.as_markup(), 
        parse_mode="HTML",
        # Добавляем этот параметр, чтобы Telegram не пытался делать превью для tg:// ссылок
        disable_web_page_preview=True 
    )
    await callback.answer()
    
@router.callback_query(F.data.startswith("complete_order_"), RoleFilter('admin'))
async def complete_order(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    order_id = int(callback.data.split('_')[-1])
    
    # --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
    # 1. Получаем объект администратора, который нажал кнопку
    admin_user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not admin_user:
        await callback.answer("Ошибка: не удалось идентифицировать администратора.", show_alert=True)
        return
    # 2. Используем его внутренний ID, а не Telegram ID
    admin_internal_id = admin_user.id
    
    order = await session.get(MerchOrder, order_id, options=[joinedload(MerchOrder.item), joinedload(MerchOrder.user)])
    if not order or order.status != 'pending_pickup':
        await callback.answer("Заказ не найден или уже обработан.", show_alert=True)
        return

    # 3. Передаем правильный ID в функцию
    await admin_requests.complete_order(session, order_id, admin_internal_id)
    
    await callback.answer(f"✅ Заказ №{order_id} помечен как выданный.", show_alert=True)
    
    try:
        await bot.send_message(
            chat_id=order.user.telegram_id,
            text=f"🎉 Ваш заказ «{order.item.name}» был выдан. Приятного пользования!"
        )
    except Exception as e:
        logger.error(f"Failed to notify user {order.user.id} about order completion: {e}")
    
    # Обновляем список заказов для админа
    await process_orders(callback, session)
    
async def send_new_event_notifications(event: Event, bot: Bot):
    """
    Асинхронная задача для рассылки уведомлений о новом мероприятии.
    Создает собственную сессию для работы с БД.
    """
    # Создаем новую сессию специально для этой фоновой задачи
    async with async_session_maker() as session:
        try:
            users_to_notify = await user_requests.get_users_for_event_notification(session, event)
            
            logger.info(f"Starting notification mailing for event '{event.name}'. Found {len(users_to_notify)} eligible users.")
            
            success_count = 0
            fail_count = 0
            
            for user in users_to_notify:
                text = Text.NEW_EVENT_NOTIFICATION.format(
                    event_name=event.name,
                    event_date=event.event_date.strftime('%d.%m.%Y'),
                    event_location=event.location
                )
                try:
                    await bot.send_message(user.telegram_id, text, parse_mode="Markdown")
                    success_count += 1
                    logger.info(f"Successfully sent notification to user {user.id}") # <-- ВАЖНЫЙ ЛОГ
                except Exception as e:
                    fail_count += 1
                    logger.error(f"Failed to send new event notification to user {user.id}. Error: {e}")
                await asyncio.sleep(0.1) # Пауза для избежания лимитов Telegram
            
            logger.info(f"Mailing finished. Sent: {success_count}, Failed: {fail_count}.")
            
        except Exception as e:
            logger.error(f"Critical error during new event mailing for event {event.id}: {e}", exc_info=True)


# ИЗМЕНЯЕМ ЭТОТ ХЭНДЛЕР
@router.message(EventCreation.awaiting_limit)
async def process_event_limit(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    try:
        limit = int(message.text)
        await state.update_data(participant_limit=limit)
        event_data = await state.get_data()
        
        new_event = await admin_requests.create_event(session, event_data)
        await state.clear()
        
        await message.answer("✅ Мероприятие успешно создано!", reply_markup=inline.get_back_to_admin_panel_keyboard())
        
        # ИЗМЕНЕНИЕ ЗДЕСЬ: ПРЯМОЙ ВЫЗОВ ВМЕСТО ФОНОВОЙ ЗАДАЧИ
        await message.answer("⏳ Начинаю рассылку уведомлений. Пожалуйста, подождите...")
        logger.info("Calling send_new_event_notifications DIRECTLY for debugging.")
        
        await send_new_event_notifications(new_event, bot)
        
        logger.info("Direct call to send_new_event_notifications finished.")
        await message.answer("✅ Рассылка уведомлений завершена.")

    except ValueError:
        await message.answer("❌ Лимит участников должен быть числом. Попробуйте снова.")
        
    
async def do_mailing(audience: str, message_text: str, photo_id: str | None, video_id: str | None, bot: Bot):
    """
    Асинхронная задача для выполнения рассылки с текстом и/или медиа.
    """
    logger.info(f"Starting mailing for audience: {audience}")
    async with async_session_maker() as session:
        try:
            users = await user_requests.get_users_by_criteria(session, audience)
            if not users:
                logger.warning("No users found for this mailing criteria.")
                return

            logger.info(f"Found {len(users)} users for mailing.")
            success_count, fail_count = 0, 0

            for user in users:
                try:
                    if photo_id:
                        await bot.send_photo(user.telegram_id, photo_id, caption=message_text, parse_mode="HTML")
                    elif video_id:
                        await bot.send_video(user.telegram_id, video_id, caption=message_text, parse_mode="HTML")
                    else:
                        await bot.send_message(user.telegram_id, message_text, parse_mode="HTML")
                    
                    success_count += 1
                except Exception as e:
                    fail_count += 1
                    logger.error(f"Failed to send message to user {user.id}. Error: {e}")
                await asyncio.sleep(0.1)

            logger.info(f"Mailing finished. Sent: {success_count}, Failed: {fail_count}.")

        except Exception as e:
            logger.error(f"Critical error during mailing: {e}", exc_info=True)


# =============================================================================
# --- 📣 РАССЫЛКИ (FSM) - НОВАЯ ВЕРСИЯ ---
# =============================================================================

@router.callback_query(F.data == "admin_mailing", RoleFilter('admin'))
async def start_mailing(callback: types.CallbackQuery, state: FSMContext):
    """Шаг 1: Запрашивает текст для рассылки."""
    await state.clear()
    await state.set_state(Mailing.awaiting_message_text)
    await callback.message.edit_text(
        "Вы начали создание рассылки.\n\n"
        "Шаг 1/3: Введите текст сообщения. Он будет подписью, если вы добавите фото/видео. "
        "Можно использовать HTML-теги: <b>жирный</b>, <i>курсив</i>, <code>код</code>, <a href='...'>ссылка</a>.\n\n"
        "Чтобы отменить, нажмите /cancel."
    )
    await callback.answer()

@router.message(Mailing.awaiting_message_text)
async def get_mailing_text(message: types.Message, state: FSMContext):
    """Шаг 2: Получает текст и запрашивает медиа."""
    # Сохраняем и текст, и разметку, если она есть
    await state.update_data(
        message_text=message.html_text, # html_text сохранит и текст, и форматирование
        photo_id=None, # Обнуляем медиа на случай, если это повторное создание
        video_id=None
    ) 
    await state.set_state(Mailing.awaiting_media)
    
    await message.answer(
        "Текст получен.\n\n"
        "Шаг 2/3: Теперь отправьте фото или видео, которое нужно прикрепить к рассылке. "
        "Если хотите отправить только текст, нажмите 'Пропустить'.",
        reply_markup=inline.get_skip_media_keyboard()
    )

# --- Обработка медиа ---
@router.message(Mailing.awaiting_media, F.photo)
async def get_mailing_photo(message: types.Message, state: FSMContext):
    """Ловит фото, сохраняет его ID и переходит к выбору аудитории."""
    photo_file_id = message.photo[-1].file_id
    await state.update_data(photo_id=photo_file_id)
    await state.set_state(Mailing.awaiting_audience_choice)
    await message.answer(
        "Фото получено.\n\n"
        "Шаг 3/3: Выберите аудиторию для рассылки:",
        reply_markup=inline.get_mailing_audience_keyboard()
    )

@router.message(Mailing.awaiting_media, F.video)
async def get_mailing_video(message: types.Message, state: FSMContext):
    """Ловит видео, сохраняет его ID и переходит к выбору аудитории."""
    video_file_id = message.video.file_id
    await state.update_data(video_id=video_file_id)
    await state.set_state(Mailing.awaiting_audience_choice)
    await message.answer(
        "Видео получено.\n\n"
        "Шаг 3/3: Выберите аудиторию для рассылки:",
        reply_markup=inline.get_mailing_audience_keyboard()
    )

@router.callback_query(Mailing.awaiting_media, F.data == "skip_media")
async def skip_media_step(callback: types.CallbackQuery, state: FSMContext):
    """Пропускает шаг добавления медиа."""
    await state.set_state(Mailing.awaiting_audience_choice)
    await callback.message.edit_text(
        "Шаг 3/3: Выберите аудиторию для рассылки:",
        reply_markup=inline.get_mailing_audience_keyboard()
    )
    await callback.answer()

# --- Выбор аудитории и подтверждение ---
@router.callback_query(Mailing.awaiting_audience_choice, F.data.startswith("mail_audience_"))
async def get_mailing_audience(callback: types.CallbackQuery, state: FSMContext):
    """Получает аудиторию и показывает превью для подтверждения."""
    audience = callback.data.split('_', 2)[-1]
    await state.update_data(audience=audience)
    
    data = await state.get_data()
    message_text = data.get("message_text")
    photo_id = data.get("photo_id")
    video_id = data.get("video_id")
    
    audience_map = { "all": "Всем пользователям", "can_donate": "Донорам, которые могут сдавать", "volunteers": "Волонтерам", "admins": "Администраторам" }
    
    preview_text = (f"🔍 *Проверьте рассылку перед запуском*\n\n"
                    f"👤 *Аудитория:* {audience_map.get(audience, 'Неизвестно')}\n")
    
    if photo_id: preview_text += "🖼️ *Прикреплено фото*\n"
    if video_id: preview_text += "📹 *Прикреплено видео*\n"
    
    preview_text += (f"\n✉️ *Текст/подпись:*\n"
                     f"------------------------------------\n"
                     f"{message_text}\n"
                     f"------------------------------------")
            
    await state.set_state(Mailing.awaiting_confirmation)
    
    # Удаляем предыдущее сообщение и отправляем новое, чтобы избежать ошибок с edit_text/edit_caption
    await callback.message.delete()
    await callback.message.answer(preview_text, reply_markup=inline.get_mailing_confirmation_keyboard(), parse_mode="HTML")
    await callback.answer()

@router.callback_query(Mailing.awaiting_confirmation, F.data == "edit_mailing_text")
async def edit_mailing_text(callback: types.CallbackQuery, state: FSMContext):
    """Позволяет вернуться к редактированию текста."""
    await state.set_state(Mailing.awaiting_message_text)
    await callback.message.edit_text("Введите новый текст сообщения для рассылки:")
    await callback.answer()

@router.callback_query(Mailing.awaiting_confirmation, F.data == "confirm_mailing")
async def confirm_and_start_mailing(callback: types.CallbackQuery, state: FSMContext, bot: Bot):
    """Запускает рассылку в фоновом режиме."""
    data = await state.get_data()
    
    await state.clear()
    
    await callback.message.edit_text(
        f"✅ Рассылка запущена в фоновом режиме. Вы можете продолжать пользоваться ботом.",
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )
    
    # Запускаем саму рассылку как фоновую задачу
    asyncio.create_task(do_mailing(
        audience=data.get("audience"),
        message_text=data.get("message_text"),
        photo_id=data.get("photo_id"),
        video_id=data.get("video_id"),
        bot=bot
    ))
    await callback.answer()
    
# =============================================================================
# --- 👑 ФУНКЦИИ ГЛАВНОГО АДМИНА В ОБЩЕМ МЕНЮ ---
# =============================================================================

@router.callback_query(F.data.startswith("ma_promote_admin_"), RoleFilter('main_admin'))
async def promote_to_admin(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """Назначает пользователю роль 'admin'."""
    target_user_id = int(callback.data.split('_')[-1])
    target_user = await user_requests.get_user_by_id(session, target_user_id)

    if not target_user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return
    
    await admin_requests.change_user_role(session, target_user_id, 'admin')
    await callback.answer(f"✅ {target_user.full_name} назначен администратором.", show_alert=True)

    try:
        await bot.send_message(target_user.telegram_id, "Поздравляем! Вас назначили администратором бота.")
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about admin promotion: {e}")
    
    await show_single_user_card(callback, session) # Обновляем карточку

@router.callback_query(F.data.startswith("ma_demote_admin_"), RoleFilter('main_admin'))
async def demote_from_admin(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """Снимает с пользователя роль 'admin'."""
    target_user_id = int(callback.data.split('_')[-1])
    target_user = await user_requests.get_user_by_id(session, target_user_id)

    if not target_user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return

    await admin_requests.change_user_role(session, target_user_id, 'student')
    await callback.answer(f"✅ {target_user.full_name} разжалован до студента.", show_alert=True)

    try:
        await bot.send_message(target_user.telegram_id, "Ваша роль изменена на 'студент'.")
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about admin demotion: {e}")

    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("ma_block_user_"), RoleFilter('main_admin'))
async def block_user_from_card(callback: types.CallbackQuery, state: FSMContext):
    """Запускает FSM блокировки из карточки пользователя."""
    target_user_id = int(callback.data.split('_')[-1])
    await state.clear()
    await state.update_data(user_id=target_user_id)
    await state.set_state(BlockUser.awaiting_reason)
    await callback.message.edit_text("Введите причину блокировки:")
    await callback.answer()

# Нужен хэндлер для состояния BlockUser.awaiting_reason, если его еще нет в этом файле
@router.message(BlockUser.awaiting_reason)
async def process_block_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason = message.text
    target_user_id = data['user_id']
    
    # --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
    
    # 1. Находим объект администратора, который выполняет действие
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    if not admin_user:
        await message.answer("Критическая ошибка: не удалось идентифицировать вас как администратора.")
        await state.clear()
        return

    # 2. Используем его внутренний ID (admin_user.id)
    admin_id = admin_user.id
    
    # --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await message.answer("Ошибка: целевой пользователь не найден.")
        await state.clear()
        return

    # Передаем правильный admin_id в функцию
    await admin_requests.block_user(session, target_user_id, admin_id, reason)
    await state.clear()

    await message.answer(f"✅ Пользователь {target_user.full_name} заблокирован. Причина: {reason}", reply_markup=inline.get_back_to_admin_panel_keyboard())
    
    try:
        await bot.send_message(target_user.telegram_id, f"Ваш аккаунт был заблокирован.\nПричина: {reason}")
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about block: {e}")
        
        
@router.callback_query(F.data.startswith("ma_unblock_user_"), RoleFilter('main_admin'))
async def unblock_user_from_card(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """Разблокирует пользователя и обновляет карточку."""
    target_user_id = int(callback.data.split('_')[-1])
    
    # Выполняем разблокировку в БД
    await admin_requests.unblock_user(session, target_user_id)
    
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return
        
    await callback.answer(f"✅ Пользователь {target_user.full_name} успешно разблокирован.", show_alert=True)
    
    # Уведомляем пользователя
    try:
        await bot.send_message(target_user.telegram_id, "🎉 Ваш аккаунт был разблокирован. Теперь вы снова можете пользоваться ботом.")
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about unblock: {e}")
        
    # Обновляем карточку, чтобы показать новый статус и поменять кнопку
    await show_single_user_card(callback, session)
    
    
    # =============================================================================
# --- 👮‍♂️ УПРАВЛЕНИЕ АДМИНИСТРАТОРАМИ ---
# =============================================================================

@router.callback_query(F.data == "ma_manage_admins", RoleFilter('main_admin'))
async def manage_admins_panel(callback: types.CallbackQuery):
    """Показывает меню управления ролями администраторов."""
    await callback.message.edit_text(
        text="👮‍♂️ *Управление администраторами*",
        reply_markup=inline.get_admins_management_keyboard(),
        parse_mode="Markdown"
    )
    await callback.answer()

# --- Назначение администратора (FSM) ---
@router.callback_query(F.data == "add_admin", RoleFilter('main_admin'))
async def add_admin_start(callback: types.CallbackQuery, state: FSMContext):
    """Запускает процесс назначения нового администратора."""
    await state.clear()
    await state.set_state(AdminManagement.awaiting_user_to_promote)
    await callback.message.edit_text("Введите ID, ФИО или номер телефона пользователя, которого хотите сделать администратором:")
    await callback.answer()
    
@router.message(AdminManagement.awaiting_user_to_promote)
async def promote_user_to_admin(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    """Ищет пользователя и повышает его до роли 'admin'."""
    user_to_promote = await admin_requests.find_user_for_admin(session, message.text)
    await state.clear()
    
    if not user_to_promote:
        await message.answer("❌ Пользователь не найден.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return
        
    if user_to_promote.role in ['admin', 'main_admin']:
        await message.answer(f"Этот пользователь уже является {user_to_promote.role}.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return
        
    await admin_requests.change_user_role(session, user_to_promote.id, 'admin')
    await message.answer(f"✅ Пользователь *{user_to_promote.full_name}* успешно назначен администратором.", parse_mode="Markdown", reply_markup=inline.get_back_to_ma_panel_keyboard())

    try:
        await bot.send_message(user_to_promote.telegram_id, "🎉 Поздравляем! Главный администратор назначил вас администратором бота.")
    except Exception as e:
        logger.error(f"Failed to notify user {user_to_promote.id} about promotion: {e}")

# --- Разжалование администратора (FSM) ---
@router.callback_query(F.data == "remove_admin", RoleFilter('main_admin'))
async def remove_admin_start(callback: types.CallbackQuery, state: FSMContext):
    """Запускает процесс разжалования администратора."""
    await state.clear()
    await state.set_state(AdminManagement.awaiting_user_to_demote)
    await callback.message.edit_text("Введите ID, ФИО или номер телефона администратора, которого хотите разжаловать:")
    await callback.answer()
    
@router.message(AdminManagement.awaiting_user_to_demote)
async def demote_user_from_admin(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    """Ищет администратора и понижает его до роли 'student'."""
    user_to_demote = await admin_requests.find_user_for_admin(session, message.text)
    await state.clear()
    
    if not user_to_demote:
        await message.answer("❌ Пользователь не найден.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return
        
    if user_to_demote.role != 'admin':
        await message.answer("Этот пользователь не является администратором.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return

    if user_to_demote.telegram_id == message.from_user.id:
        await message.answer("Вы не можете разжаловать самого себя.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return
        
    await admin_requests.change_user_role(session, user_to_demote.id, 'student')
    await message.answer(f"✅ Администратор *{user_to_demote.full_name}* успешно разжалован.", parse_mode="Markdown", reply_markup=inline.get_back_to_ma_panel_keyboard())

    try:
        await bot.send_message(user_to_demote.telegram_id, "⚙️ Ваша роль была изменена на 'студент'.")
    except Exception as e:
        logger.error(f"Failed to notify user {user_to_demote.id} about demotion: {e}")


# =============================================================================
# --- 🚫 УПРАВЛЕНИЕ БЛОКИРОВКАМИ ---
# =============================================================================

@router.callback_query(F.data == "ma_manage_blocks", RoleFilter('main_admin'))
async def manage_blocks_panel(callback: types.CallbackQuery):
    """Показывает меню управления блокировками."""
    await callback.message.edit_text(
        text="🚫 *Управление блокировками*",
        reply_markup=inline.get_blocks_management_keyboard(),
        parse_mode="Markdown"
    )
    await callback.answer()

# --- Блокировка пользователя (FSM) ---
@router.callback_query(F.data == "block_user_start", RoleFilter('main_admin'))
async def block_user_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(BlockUser.awaiting_user_id)
    await callback.message.edit_text("Введите ID, ФИО или номер телефона пользователя для блокировки:")
    await callback.answer()

@router.message(BlockUser.awaiting_user_id)
async def block_user_get_id(message: types.Message, state: FSMContext, session: AsyncSession):
    user = await admin_requests.find_user_for_admin(session, message.text)
    if not user:
        await state.clear()
        await message.answer("❌ Пользователь не найден.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return
    
    if user.role == 'main_admin':
        await state.clear()
        await message.answer("Вы не можете заблокировать главного администратора.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return

    if user.is_blocked:
        await state.clear()
        await message.answer("Этот пользователь уже заблокирован.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return

    await state.update_data(user_id=user.id, user_name=user.full_name, user_tg_id=user.telegram_id)
    await state.set_state(BlockUser.awaiting_reason)
    await message.answer(f"Пользователь *{user.full_name}* найден. Введите причину блокировки:")
    
@router.message(BlockUser.awaiting_reason)
async def block_user_get_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason, user_id_to_block, user_name, user_tg_id = message.text, data['user_id'], data['user_name'], data['user_tg_id']
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    
    await admin_requests.block_user(session, user_id_to_block, admin_user.id, reason)
    await state.clear()

    await message.answer(f"✅ Пользователь *{user_name}* успешно заблокирован. Причина: {reason}", parse_mode="Markdown", reply_markup=inline.get_back_to_ma_panel_keyboard())
    
    try:
        await bot.send_message(chat_id=user_tg_id, text=f"❌ Ваш аккаунт был заблокирован.\n*Причина:* {reason}", parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Failed to notify user {user_id_to_block} about block: {e}")

# --- Разблокировка пользователя (FSM) ---
@router.callback_query(F.data == "unblock_user_start", RoleFilter('main_admin'))
async def unblock_user_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(BlockUser.awaiting_user_id_unblock)
    await callback.message.edit_text("Введите ID, ФИО или номер телефона пользователя для разблокировки:")
    await callback.answer()

@router.message(BlockUser.awaiting_user_id_unblock)
async def unblock_user_get_id(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    user = await admin_requests.find_user_for_admin(session, message.text)
    await state.clear()

    if not user:
        await message.answer("❌ Пользователь не найден.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return
    
    if not user.is_blocked:
        await message.answer("Этот пользователь не заблокирован.", reply_markup=inline.get_back_to_ma_panel_keyboard())
        return
        
    await admin_requests.unblock_user(session, user.id)
    await message.answer(f"✅ Пользователь *{user.full_name}* успешно разблокирован.", parse_mode="Markdown", reply_markup=inline.get_back_to_ma_panel_keyboard())

    try:
        await bot.send_message(user.telegram_id, "🎉 Ваш аккаунт был разблокирован.")
    except Exception as e:
        logger.error(f"Failed to notify user {user.id} about unblock: {e}")


async def create_full_backup_zip(session: AsyncSession) -> io.BytesIO:
    """
    Собирает данные из всех таблиц, создает CSV-файлы и упаковывает их в ZIP-архив в памяти.
    """
    all_data = await admin_requests.get_all_data_for_export(session)
    
    # Создаем ZIP-архив в памяти
    zip_buffer = io.BytesIO()
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for table_name, records in all_data.items():
            if not records:
                continue # Пропускаем пустые таблицы

            # Создаем CSV-файл в памяти (в виде строки)
            csv_buffer = io.StringIO()
            
            # Получаем заголовки из первой записи
            headers = [c.name for c in records[0].__table__.columns]
            writer = csv.DictWriter(csv_buffer, fieldnames=headers, delimiter=';')
            writer.writeheader()
            
            # Записываем данные
            for record in records:
                writer.writerow({h: getattr(record, h) for h in headers})
            
            # Добавляем CSV-строку в ZIP-архив как файл
            zip_file.writestr(f"{table_name}.csv", csv_buffer.getvalue())

    zip_buffer.seek(0)
    return zip_buffer

# =============================================================================
# --- 💾 ЭКСПОРТ ДАННЫХ (НОВАЯ ВЕРСИЯ) ---
# =============================================================================

@router.callback_query(F.data == "ma_export_data", RoleFilter('main_admin'))
async def export_data_start(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """
    Запускает процесс создания и отправки полного бэкапа.
    """
    # Отправляем предварительное сообщение
    msg = await callback.message.edit_text("⏳ Начинаю сбор данных и создание архива... Это может занять некоторое время.")
    await callback.answer()

    try:
        # Создаем ZIP-архив
        zip_archive_bytes = await create_full_backup_zip(session)
        
        # Генерируем имя файла с текущей датой
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")
        filename = f"donor_bot_backup_{timestamp}.zip"
        
        # Отправляем архив как документ
        await bot.send_document(
            chat_id=callback.from_user.id,
            document=types.BufferedInputFile(zip_archive_bytes.read(), filename=filename),
            caption="✅ Полный бэкап базы данных готов."
        )
        
        # Удаляем сообщение "Начинаю сбор..."
        await msg.delete()

    except Exception as e:
        logger.error(f"Failed to create data backup: {e}", exc_info=True)
        await msg.edit_text("❌ Произошла ошибка при создании бэкапа. Подробности в логах.")
        
        
        
@router.callback_query(F.data.startswith("admin_manage_waivers_"), RoleFilter('admin'))
async def admin_manage_user_waivers_menu(callback: types.CallbackQuery, session: AsyncSession):
    """Показывает админу меню управления медотводами пользователя."""
    user_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return

    waivers = await admin_requests.get_all_user_active_waivers(session, user_id)
    
    text_header = f"⚕️ Управление медотводами пользователя *{user.full_name}*.\n\n"
    
    if not waivers:
        text = text_header + "Активных медотводов нет. Вы можете установить новый."
    else:
        text = text_header + "Нажмите на медотвод, чтобы удалить, или установите новый:"

    await callback.message.edit_text(
        text,
        reply_markup=inline.get_admin_waiver_management_keyboard(user_id, waivers),
        parse_mode="Markdown"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_del_waiver_"), RoleFilter('admin'))
async def admin_delete_waiver(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """Обрабатывает удаление медотвода администратором."""
    try:
        _, _, _, waiver_id_str, user_id_str = callback.data.split('_')
        waiver_id, user_id = int(waiver_id_str), int(user_id_str)
    except ValueError:
        await callback.answer("Ошибка в данных callback. Попробуйте снова.", show_alert=True)
        return

    success = await admin_requests.force_delete_waiver(session, waiver_id)
    
    if success:
        await callback.answer("✅ Медотвод успешно удален.", show_alert=True)
        
        # Попытаемся уведомить пользователя
        try:
            user = await user_requests.get_user_by_id(session, user_id)
            if user:
                await bot.send_message(
                    user.telegram_id,
                    "⚙️ Администратор отменил один из ваших медицинских отводов. Теперь вы можете снова участвовать в донациях (если нет других отводов)."
                )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about admin waiver deletion: {e}")

    else:
        await callback.answer("❌ Не удалось удалить медотвот (возможно, он уже удален).", show_alert=True)
    
    # Обновляем меню, чтобы показать актуальный список медотводов
    await admin_manage_user_waivers_menu(callback, session)

--- КОНЕЦ ФАЙЛА: bot/handlers/admin.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/common.py ---

from aiogram import Router, F, types, Bot
from aiogram.filters import CommandStart, Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import any_state
from aiogram.types import ReplyKeyboardRemove
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.exceptions import TelegramBadRequest
from aiogram.utils.keyboard import InlineKeyboardBuilder
from bot.db import user_requests
from bot.states.states import Registration
from bot.keyboards import reply, inline
from bot.utils.text_messages import Text
from bot.filters.role import RoleFilter

ROLE_MENU_MAP = {
    'volunteer': inline.get_volunteer_main_menu,
    'admin': inline.get_admin_main_menu,
    'main_admin': inline.get_main_admin_main_menu
}

router = Router()

async def show_main_menu(message: types.Message, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    # print(f"show_main_menu: user={user}")  # log
    if user:
        if user.is_blocked:
            await message.answer("❌ К сожалению, вы были заблокированы.")
            return
        menu_func = ROLE_MENU_MAP.get(user.role, inline.get_student_main_menu)
        await message.answer(f"✅ С возвращением, {user.full_name}!\n\nЧем могу помочь?", reply_markup=menu_func())
    else:
        await message.answer(Text.WELCOME, reply_markup=reply.get_contact_keyboard())

@router.message(CommandStart())
async def cmd_start(message: types.Message, session: AsyncSession):
    # print("cmd_start called")  # log
    await show_main_menu(message, session)

@router.callback_query(F.data == "back_to_student_menu")
async def back_to_main_menu_callback(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    # print(f"back_to_main_menu_callback: user={user}")  # log
    if not user:
        await callback.message.edit_text(Text.WELCOME)
        await callback.answer()
        return
    menu_func = ROLE_MENU_MAP.get(user.role, inline.get_student_main_menu)
    text = "✅ Главное меню. Чем могу помочь?"
    keyboard = menu_func()
    try:
        await callback.message.edit_text(text, reply_markup=keyboard)
    except TelegramBadRequest:
        await callback.message.delete()
        await callback.message.answer(text, reply_markup=keyboard)
    await callback.answer()

@router.callback_query(F.data == "switch_to_donor_view")
async def switch_to_donor_view_handler(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    # print(f"switch_to_donor_view_handler: user={user}")  # log
    if not user:
        await callback.answer("Ошибка: профиль не найден.", show_alert=True)
        return
    keyboard = inline.get_student_main_menu(viewer_role=user.role)
    text = "✅ Вы переключились в режим донора. Здесь доступны все студенческие функции."
    await callback.message.edit_text(text, reply_markup=keyboard)
    await callback.answer()

@router.callback_query(F.data == "back_to_main_menu")
async def back_to_main_menu_handler(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    # print(f"back_to_main_menu_handler: user={user}")  # log
    if not user:
        await callback.answer("Ошибка: не удалось найти ваш профиль.", show_alert=True)
        return
    if user.role == 'student':
        keyboard = inline.get_student_main_menu(viewer_role=user.role)
    else:
        menu_func = ROLE_MENU_MAP.get(user.role)
        keyboard = menu_func()
    text = f"✅ Главное меню. Ваша роль: *{user.role}*."
    try:
        await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="Markdown")
    except TelegramBadRequest:
        await callback.message.delete()
        await callback.message.answer(text, reply_markup=keyboard, parse_mode="Markdown")
    await callback.answer()

@router.message(F.contact)
async def handle_contact(message: types.Message, session: AsyncSession, state: FSMContext):
    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    # print(f"handle_contact: user={user}")  # log
    if user:
        await message.answer(f"Вы уже зарегистрированы, {user.full_name}!", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(message, session)
        return
    contact = message.contact
    phone_number = contact.phone_number
    if not phone_number.startswith('+'):
        phone_number = '+' + phone_number
    user_by_phone = await user_requests.get_user_by_phone(session, phone_number)
    # print(f"handle_contact: user_by_phone={user_by_phone}")  # log
    if user_by_phone:
        if user_by_phone.is_blocked:
            await message.answer("❌ Ваш аккаунт заблокирован.", reply_markup=ReplyKeyboardRemove())
            return
        await user_requests.update_user_tg_id(session, user_by_phone.id, message.from_user.id)
        menu_func = ROLE_MENU_MAP.get(user_by_phone.role, inline.get_student_main_menu)
        await message.answer(Text.AUTH_SUCCESS.format(name=user_by_phone.full_name), reply_markup=ReplyKeyboardRemove())
        await message.answer("Главное меню:", reply_markup=menu_func())
    else:
        await state.update_data(
            phone_number=phone_number,
            telegram_id=message.from_user.id,
            telegram_username=message.from_user.username
        )
        await message.answer(Text.START_REGISTRATION, reply_markup=ReplyKeyboardRemove())
        await message.answer(Text.GET_FULL_NAME)
        await state.set_state(Registration.awaiting_full_name)

@router.message(Registration.awaiting_full_name)
async def process_full_name(message: types.Message, state: FSMContext):
    await state.update_data(full_name=message.text)
    await message.answer(Text.GET_FACULTY, reply_markup=inline.get_faculties_keyboard())
    await state.set_state(Registration.awaiting_faculty)

@router.callback_query(Registration.awaiting_faculty, F.data.startswith('faculty_'))
async def process_faculty(callback: types.CallbackQuery, state: FSMContext):
    faculty = callback.data.split('_', 1)[1]
    await state.update_data(faculty=faculty)
    await callback.message.edit_text(f"Выбран факультет: {faculty}")
    await callback.message.answer(Text.GET_GROUP)
    await state.set_state(Registration.awaiting_study_group)
    await callback.answer()

@router.message(Registration.awaiting_study_group)
async def process_study_group(message: types.Message, state: FSMContext):
    await state.update_data(study_group=message.text)
    await message.answer(Text.GET_BLOOD_TYPE, reply_markup=inline.get_blood_type_keyboard())
    await state.set_state(Registration.awaiting_blood_type)

@router.callback_query(Registration.awaiting_blood_type, F.data.startswith('bloodtype_'))
async def process_blood_type(callback: types.CallbackQuery, state: FSMContext):
    blood_type = callback.data.split('_', 1)[1]
    await state.update_data(blood_type=blood_type)
    await callback.message.edit_text(f"Группа крови: {blood_type}")
    await callback.message.answer(Text.GET_RH_FACTOR, reply_markup=inline.get_rh_factor_keyboard())
    await state.set_state(Registration.awaiting_rh_factor)

@router.callback_query(Registration.awaiting_rh_factor, F.data.startswith('rhfactor_'))
async def process_rh_factor(callback: types.CallbackQuery, state: FSMContext):
    rh_factor = callback.data.split('_', 1)[1]
    await state.update_data(rh_factor=rh_factor)
    await callback.message.edit_text(f"Резус-фактор: {rh_factor}")
    await callback.message.answer(Text.GET_GENDER, reply_markup=reply.get_gender_keyboard())
    await state.set_state(Registration.awaiting_gender)

@router.message(Registration.awaiting_gender, F.text.in_(['Мужской', 'Женский']))
async def process_gender(message: types.Message, state: FSMContext, session: AsyncSession):
    gender_map = {'Мужской': 'male', 'Женский': 'female'}
    await state.update_data(gender=gender_map[message.text])
    user_data = await state.get_data()
    # print(f"process_gender: user_data={user_data}")  # log
    await user_requests.add_user(session, user_data)
    await state.clear()
    await message.answer(Text.REGISTRATION_COMPLETE, reply_markup=ReplyKeyboardRemove())
    await message.answer("Ваше главное меню:", reply_markup=inline.get_student_main_menu())

@router.message(Registration.awaiting_gender)
async def process_gender_invalid(message: types.Message):
    await message.answer("Пожалуйста, используйте кнопки для выбора пола.", reply_markup=reply.get_gender_keyboard())

@router.message(Command("cancel"), StateFilter(any_state))
@router.callback_query(F.data == "cancel_fsm", StateFilter(any_state))
async def cancel_fsm_handler(event: types.Message | types.CallbackQuery, state: FSMContext, session: AsyncSession):
    current_state = await state.get_state()
    # print(f"cancel_fsm_handler: current_state={current_state}")  # log
    if current_state is None:
        if isinstance(event, types.CallbackQuery): await event.answer()
        return
    await state.clear()
    text = "Действие отменено."
    if isinstance(event, types.Message):
        await event.answer(text, reply_markup=types.ReplyKeyboardRemove())
        await show_main_menu(event, session)
    elif isinstance(event, types.CallbackQuery):
        await event.message.delete()
        await event.message.answer(text)
        await show_main_menu(event.message, session)
        await event.answer()

class TestFSM(StatesGroup):
    getting_name = State()
    getting_age = State()

@router.message(Command("testfsm"))
async def start_test_fsm(message: types.Message, state: FSMContext):
    await state.set_state(TestFSM.getting_name)
    await message.answer("Тест FSM запущен. Введите ваше имя:")

@router.message(TestFSM.getting_name)
async def process_test_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(TestFSM.getting_age)
    await message.answer(f"Отлично, {message.text}! Теперь введите ваш возраст:")

@router.message(TestFSM.getting_age)
async def process_test_age(message: types.Message, state: FSMContext):
    data = await state.get_data()
    name = data.get("name")
    age = message.text
    await message.answer(f"Тест завершен.\nИмя: {name}\nВозраст: {age}")
    await state.clear()

@router.message(Command("secret_admin_123"), RoleFilter('admin'))
async def secret_admin_panel(message: types.Message, session: AsyncSession):
    fake_callback = types.CallbackQuery(
        id=str(message.message_id),
        from_user=message.from_user,
        chat_instance="instance",
        message=message,
        data="admin_panel"
    )
    
    from .admin import show_admin_panel
    await show_admin_panel(fake_callback, session)
    await message.delete()


@router.callback_query(F.data == "back_to_student_menu")
async def back_to_student_menu_handler(callback: types.CallbackQuery, session: AsyncSession):
    keyboard = inline.get_student_main_menu()
    text = "✅ Вы переключились в режим донора. Здесь вы можете записаться на донацию, посмотреть профиль и т.д."
    await callback.message.edit_text(text, reply_markup=keyboard)
    await callback.answer()

@router.callback_query(F.data == "switch_to_volunteer_view", RoleFilter('admin'))
async def switch_to_volunteer_view_handler(callback: types.CallbackQuery):
    builder = InlineKeyboardBuilder()
    builder.row(types.InlineKeyboardButton(text="📷 Подтвердить донацию (QR)", callback_data="confirm_donation_qr"))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад в меню донора", callback_data="switch_to_donor_view"))
    await callback.message.edit_text(
        "⭐ *Вы переключились в режим волонтера*",
        reply_markup=builder.as_markup(),
        parse_mode="Markdown"
    )
    await callback.answer()



--- КОНЕЦ ФАЙЛА: bot/handlers/common.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/main_admin.py ---

import io
import csv
import logging
import zipfile 
import datetime
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests, user_requests
from bot.states.states import AdminManagement, BlockUser
from bot.keyboards import inline
from bot.filters.role import RoleFilter
from .admin import show_admin_panel as show_admin_panel_logic

# logging.basicConfig(level=logging.INFO)  # Логи закомментированы

router = Router()

@router.callback_query(F.data == "main_admin_panel", RoleFilter('main_admin'))
async def show_unified_admin_panel(callback: types.CallbackQuery, session: AsyncSession):
    # Главная админ-панель с доп. кнопками для главного админа
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer: 
        await callback.answer("Ошибка: не удалось найти ваш профиль.", show_alert=True)
        return

    await callback.message.edit_text(
        text="⚙️ *Панель администратора*",
        reply_markup=inline.get_admin_panel_keyboard(viewer.role),
        parse_mode="Markdown"
    )
    await callback.answer()

# Ниже закомментированы альтернативные хендлеры панели
# @router.callback_query(F.data == "main_admin_panel", RoleFilter('main_admin'))
# async def show_main_admin_panel(callback: types.CallbackQuery):
#     await callback.message.edit_text(
#         text="👑 *Панель Главного Администратора*",
#         reply_markup=inline.get_main_admin_panel_keyboard(),
#         parse_mode="Markdown"
#     )
#     await callback.answer()

# @router.callback_query(F.data == "admin_panel", RoleFilter('main_admin'))
# async def show_admin_panel_for_main_admin(callback: types.CallbackQuery):
#     await show_admin_panel_logic(callback)


--- КОНЕЦ ФАЙЛА: bot/handlers/main_admin.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/other.py ---

from aiogram import Router, types
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db import user_requests
from bot.keyboards import reply
from bot.utils.text_messages import Text

router = Router()

@router.message()
async def handle_unknown_message(message: types.Message, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    if not user:
        await message.answer(Text.WELCOME, reply_markup=reply.get_contact_keyboard())
    else:
        await message.answer("Я не понимаю эту команду. Пожалуйста, используйте кнопки меню для навигации.")

--- КОНЕЦ ФАЙЛА: bot/handlers/other.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/student.py ---

import datetime
import math
import logging
from aiogram import Router, F, types
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db import user_requests, event_requests, merch_requests
from bot.keyboards import inline
from bot.utils.qr_service import generate_qr
from bot.utils.text_messages import Text
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.exceptions import TelegramBadRequest
from bot.db.models import MerchItem
from bot.states.states import UserWaiver

router = Router()
logger = logging.getLogger(__name__)

# --- 👤 МОЙ ПРОФИЛЬ ---

@router.callback_query(F.data == "my_profile")
async def show_profile_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        text="👤 *Мой профиль*\n\nВыберите, что вас интересует:",
        reply_markup=inline.get_profile_menu_keyboard(),
        parse_mode="Markdown"
    )
    await callback.answer()

@router.callback_query(F.data == "profile_data")
async def show_profile_data(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    profile_data = await user_requests.get_user_profile_info(session, user.id)
    if not profile_data:
        await callback.answer("Не удалось загрузить профиль.", show_alert=True)
        return
    user_obj = profile_data['user']
    next_date_str = profile_data['next_possible_donation'].strftime('%d.%m.%Y')
    text = (f"📊 *Ваши данные*\n\n"
            f"👤 *ФИО:* {user_obj.full_name}\n"
            f"🎓 *Университет:* {user_obj.university}\n"
            f"🏛️ *Факультет:* {user_obj.faculty}, *Группа:* {user_obj.study_group}\n"
            f"🩸 *Группа крови:* {user_obj.blood_type or 'Не указана'} Rh{user_obj.rh_factor or '?'}\n"
            f"⭐ *Баллы:* {user_obj.points}\n"
            f"💉 *Всего донаций:* {profile_data['total_donations']}\n"
            f"🗓️ *Следующая донация возможна с:* {next_date_str}")
    await callback.message.edit_text(text, reply_markup=inline.get_back_to_profile_menu_keyboard(), parse_mode="Markdown")
    await callback.answer()

@router.callback_query(F.data == "profile_history")
async def show_donation_history(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    donations = await user_requests.get_user_donation_history(session, user.id)
    if not donations:
        await callback.message.edit_text("У вас еще нет записей о донациях.", reply_markup=inline.get_back_to_profile_menu_keyboard())
        return
    history_text = "🩸 *Ваша история донаций:*\n\n"
    for donation in donations:
        history_text += f"▪️ {donation.donation_date.strftime('%d.%m.%Y')}: {donation.donation_type}, *+{donation.points_awarded} баллов*\n"
    await callback.message.edit_text(history_text, reply_markup=inline.get_back_to_profile_menu_keyboard(), parse_mode="Markdown")
    await callback.answer()

# --- 📅 ЗАПИСЬ НА ДОНАЦИЮ ---

@router.callback_query(F.data == "register_donation")
async def list_active_events(callback: types.CallbackQuery, session: AsyncSession):
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not user:
        await callback.answer("Ошибка: не удалось найти ваш профиль.", show_alert=True)
        return
        
    events = await event_requests.get_active_events_for_user(session, user.id)
    
    if not events:
        await callback.answer("Активных мероприятий для записи сейчас нет.", show_alert=True)
        return
        
    builder = InlineKeyboardBuilder()
    for event in events:
        builder.row(types.InlineKeyboardButton(
            text=f"{event.event_date.strftime('%d.%m.%Y')} - {event.name}",
            callback_data=f"reg_event_{event.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="back_to_student_menu"))
    
    await callback.message.edit_text("Выберите мероприятие для записи:", reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("reg_event_"))
async def process_event_registration(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    event = await event_requests.get_event_by_id(session, event_id)
    if not user or not event:
        await callback.answer("Ошибка: не удалось найти пользователя или мероприятие.", show_alert=True)
        return
    existing_registration = await event_requests.find_specific_registration(session, user.id, event.id)
    if existing_registration:
        await callback.message.edit_text(
            text=f"Вы уже записаны на мероприятие «*{event.name}*».\n\n"
                 f"Здесь вы можете получить QR-код или отменить свою запись.",
            reply_markup=inline.get_successful_registration_keyboard(event.id),
            parse_mode="Markdown"
        )
        await callback.answer()
        return
    is_eligible, reason = await event_requests.check_registration_eligibility(session, user, event)
    if is_eligible:
        await event_requests.add_event_registration(session, user.id, event_id)
        await callback.message.edit_text(
            f"✅ Вы успешно записаны на: *{event.name}*\n\n"
            f"Ваш QR-код для подтверждения донации доступен по кнопке ниже.",
            reply_markup=inline.get_successful_registration_keyboard(event.id),
            parse_mode="Markdown"
        )
    else:
        await callback.answer(f"❌ Запись невозможна.\nПричина: {reason}", show_alert=True)
    await callback.answer()

@router.callback_query(F.data.startswith("cancel_reg_"))
async def cancel_my_registration(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    telegram_id = callback.from_user.id
    user = await user_requests.get_user_by_tg_id(session, telegram_id)
    if not user:
        await callback.answer("Ошибка: не удалось найти ваш профиль.", show_alert=True)
        return
    success = await event_requests.cancel_registration(session, user.id, event_id)
    if success:
        await callback.message.edit_text(
            "✅ Ваша регистрация на мероприятие была отменена.",
            reply_markup=inline.get_back_to_main_menu_keyboard()
        )
    else:
        await callback.message.edit_text(
            "Не удалось отменить регистрацию. Возможно, она уже была отменена.",
            reply_markup=inline.get_back_to_main_menu_keyboard()
        )
    await callback.answer()

# --- 🎁 МАГАЗИН МЕРЧА ---

@router.callback_query(F.data == "merch_store")
@router.callback_query(F.data.startswith("merch_page_"))
async def show_merch_store(callback: types.CallbackQuery, session: AsyncSession):
    page = 1
    if callback.data.startswith("merch_page_"):
        page = int(callback.data.split('_')[-1])
    item, total_items = await merch_requests.get_merch_page(session, page=page)
    if not item:
        await callback.answer("В магазине пока нет товаров.", show_alert=True)
        return
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    caption = (f"🛍️ *{item.name}*\n\n"
               f"{item.description}\n\n"
               f"Цена: *{item.price}* баллов\n"
               f"Ваш баланс: *{user.points}* баллов")
    keyboard = inline.get_merch_store_keyboard(item, page, total_items)
    try:
        await callback.message.edit_media(
            media=types.InputMediaPhoto(media=item.photo_file_id, caption=caption, parse_mode="Markdown"),
            reply_markup=keyboard
        )
    except TelegramBadRequest as e:
        await callback.message.delete()
        await callback.message.answer_photo(
            photo=item.photo_file_id,
            caption=caption,
            reply_markup=keyboard,
            parse_mode="Markdown"
        )
    await callback.answer()

@router.callback_query(F.data.startswith("buy_merch_"))
async def confirm_purchase(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await merch_requests.get_merch_item_by_id(session, item_id)
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not item:
        await callback.answer("Товар не найден.", show_alert=True)
        return
    if user.points < item.price:
        await callback.answer(f"Недостаточно баллов. Нужно {item.price}, у вас {user.points}.", show_alert=True)
        return
    text = (f"Вы уверены, что хотите купить *'{item.name}'* за *{item.price}* баллов?\n\n"
            f"Ваш баланс после покупки: *{user.points - item.price}* баллов.")
    await callback.message.edit_caption(
        caption=text,
        reply_markup=inline.get_purchase_confirmation_keyboard(item_id),
        parse_mode="Markdown"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("confirm_buy_"))
async def process_purchase(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await merch_requests.get_merch_item_by_id(session, item_id)
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    success, message = await merch_requests.create_merch_order(session, user, item)
    if success:
        await session.commit() 
        await callback.message.edit_caption(
            caption=f"🎉 Поздравляем с покупкой!\n{message}\n\nМы сообщим, когда можно будет забрать заказ.",
            reply_markup=inline.get_back_to_merch_keyboard()
        )
    else:
        await session.rollback() 
        await callback.answer(f"⚠️ Ошибка: {message}", show_alert=True)
    await callback.answer()

@router.callback_query(F.data == "my_orders")
async def show_my_orders(callback: types.CallbackQuery, session: AsyncSession):
    user_id = callback.from_user.id
    user = await user_requests.get_user_by_tg_id(session, user_id)
    orders = await merch_requests.get_user_orders(session, user.id)
    if not orders:
        text = "У вас пока нет заказов."
    else:
        text = "🛍️ *Ваши заказы:*\n\n"
        status_map = {'pending_pickup': 'Ожидает выдачи', 'completed': 'Выдан'}
        for order in orders:
            text += (f"▪️ *{order.item.name}* (от {order.order_date.strftime('%d.%m.%Y')})\n"
                     f"   Статус: *{status_map.get(order.status, 'Неизвестен')}*\n")
    try:
        await callback.message.edit_text(
            text,
            reply_markup=inline.get_back_to_merch_keyboard(),
            parse_mode="Markdown"
        )
    except TelegramBadRequest:
        await callback.answer("Не удалось обновить. Попробуйте войти в магазин заново.", show_alert=True)
    await callback.answer()


# --- ⚕️ МОИ МЕДОТВОДЫ (ИСПРАВЛЕННАЯ ВЕРСИЯ) ---

async def send_waivers_menu(message_to_answer: types.Message, user_tg_id: int, session: AsyncSession):
    """Вспомогательная функция: формирует и отправляет меню медотводов как новое сообщение."""
    user = await user_requests.get_user_by_tg_id(session, user_tg_id)
    
    if not user:
        await message_to_answer.answer("Произошла ошибка: не удалось найти ваш профиль. Попробуйте перезапустить бота командой /start.")
        return


    all_waivers = await user_requests.get_user_active_waivers(session, user.id)
    
    user_created_waivers = [w for w in all_waivers if w.created_by == 'user']
    system_waivers = [w for w in all_waivers if w.created_by != 'user']

    text_parts = ["⚕️ *Управление медицинскими отводами*\n"]

    if not all_waivers:
        text_parts.append("\n✅ У вас нет активных отводов. Вы можете спасать жизни! 💪")
    else:
        if system_waivers:
            text_parts.append("\n*Назначенные системой/администратором (нельзя отменить):*")
            for waiver in system_waivers:
                text_parts.append(f"▪️ До *{waiver.end_date.strftime('%d.%m.%Y')}* по причине: «{waiver.reason}»")
        
        if user_created_waivers:
            text_parts.append("\n*Установленные вами (можно отменить):*")
            for waiver in user_created_waivers:
                text_parts.append(f"▪️ До *{waiver.end_date.strftime('%d.%m.%Y')}* по причине: «{waiver.reason}»")

    text = "\n".join(text_parts)
    keyboard = inline.get_my_waivers_keyboard(user_waivers_exist=bool(user_created_waivers))

    await message_to_answer.answer(text, reply_markup=keyboard, parse_mode="Markdown")


@router.callback_query(F.data == "my_waivers")
async def show_my_waivers(callback: types.CallbackQuery, session: AsyncSession):
    """Главный хэндлер меню медотводов. Удаляет старое сообщение и отправляет новое."""
    try:
        await callback.message.delete()
    except TelegramBadRequest:
        logger.warning("Could not delete message in show_my_waivers, it might have been deleted already.")
    
    await send_waivers_menu(callback.message, callback.from_user.id, session)
    await callback.answer()


@router.callback_query(F.data == "set_user_waiver")
async def set_user_waiver_start(callback: types.CallbackQuery, state: FSMContext):
    """Начинает процесс установки медотвода пользователем."""
    await state.set_state(UserWaiver.awaiting_end_date)
    await callback.message.edit_text(
        "Вы можете установить временный отвод от донорства (например, из-за ОРВИ или плохого самочувствия).\n\n"
        "Введите дату, до которой будет действовать отвод, в формате *ДД.ММ.ГГГГ*:",
        parse_mode="Markdown"
    )
    await callback.answer()

@router.message(UserWaiver.awaiting_end_date)
async def process_user_waiver_date(message: types.Message, state: FSMContext):
    try:
        end_date = datetime.datetime.strptime(message.text, "%d.%m.%Y").date()
        if end_date <= datetime.date.today():
            await message.answer("❌ Дата окончания должна быть в будущем. Попробуйте снова.")
            return
            
        await state.update_data(end_date=end_date)
        await state.set_state(UserWaiver.awaiting_reason)
        await message.answer("Отлично. Теперь кратко укажите причину (например, 'Простуда', 'Плохое самочувствие'):")
    except ValueError:
        await message.answer("❌ Неверный формат даты. Введите *ДД.ММ.ГГГГ*.", parse_mode="Markdown")

@router.message(UserWaiver.awaiting_reason)
async def process_user_waiver_reason(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    end_date = data['end_date']
    reason = message.text

    user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    await user_requests.add_user_waiver(session, user.id, end_date, reason)
    
    await state.clear()
    
    await message.answer(f"✅ Ваш личный медотвод успешно установлен до {end_date.strftime('%d.%m.%Y')}.")
    
    await send_waivers_menu(message, message.from_user.id, session)

@router.callback_query(F.data == "cancel_user_waiver")
async def cancel_user_waiver_start(callback: types.CallbackQuery, session: AsyncSession):
    """Показывает список медотводов, которые пользователь может отменить."""
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    all_waivers = await user_requests.get_user_active_waivers(session, user.id)
    user_created_waivers = [w for w in all_waivers if w.created_by == 'user']
    
    if not user_created_waivers:
        await callback.answer("У вас нет отводов, которые можно отменить.", show_alert=True)
        return

    await callback.message.edit_text(
        "Выберите, какой из ваших отводов отменить:",
        reply_markup=inline.get_waiver_cancellation_keyboard(user_created_waivers)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("delete_waiver_"))
async def process_waiver_deletion(callback: types.CallbackQuery, session: AsyncSession):
    waiver_id = int(callback.data.split('_')[-1])
    
    user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not user:
        await callback.answer("Ошибка: не удалось найти ваш профиль.", show_alert=True)
        return

    user_internal_id = user.id
    success = await user_requests.delete_user_waiver(session, waiver_id, user_internal_id)
    
    if success:
        await callback.answer("✅ Ваш медотвод успешно отменен.", show_alert=True)
    else:
        await callback.answer("❌ Не удалось отменить отвод.", show_alert=True)
    
    try:
        await callback.message.delete()
    except TelegramBadRequest:
        logger.warning("Could not delete message in process_waiver_deletion.")

    await send_waivers_menu(callback.message, callback.from_user.id, session)


# --- ℹ️ ПОЛЕЗНАЯ ИНФОРМАЦИЯ ---

@router.callback_query(F.data == "info")
async def show_info_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        text="ℹ️ *Полезная информация*\n\nВыберите интересующий вас раздел:",
        reply_markup=inline.get_info_menu_keyboard(),
        parse_mode="Markdown"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("info_"))
async def show_info_text(callback: types.CallbackQuery):
    section = callback.data.split('_', 1)[1]
    text_map = {
        "prepare": Text.INFO_PREPARE,
        "contraindications": Text.INFO_CONTRAINDICATIONS,
        "after": Text.INFO_AFTER,
        "contacts": Text.INFO_CONTACTS
    }
    text_to_show = text_map.get(section, "Раздел не найден.")
    await callback.message.edit_text(text_to_show, reply_markup=inline.get_back_to_info_menu_keyboard(), parse_mode="HTML", disable_web_page_preview=True)
    await callback.answer()

# --- 🔲 МОЙ QR-КОД ---

@router.callback_query(F.data == "my_qr_code")
async def send_qr_code(callback: types.CallbackQuery):
    await callback.answer("Генерирую ваш QR-код...")
    # QR-код должен содержать что-то уникальное и простое для волонтера, если это общий QR.
    # Для простоты можно оставить только ID, но лучше использовать словарь для будущей расширяемости.
    qr_data = {"user_id": callback.from_user.id} 
    qr_image_bytes = await generate_qr(qr_data)
    await callback.message.answer_photo(
        photo=types.BufferedInputFile(qr_image_bytes, filename="my_qr.png"),
        caption="Этот QR-код можно использовать для быстрой идентификации. Для подтверждения донации на мероприятии используйте QR-код из меню мероприятия."
    )

@router.callback_query(F.data.startswith("get_event_qr_"))
async def send_event_qr_code(callback: types.CallbackQuery):
    event_id = int(callback.data.split('_')[-1])
    user_id = callback.from_user.id
    qr_data = {
        "user_id": user_id,
        "event_id": event_id
    }
    await callback.answer("Генерирую ваш QR-код...")
    qr_image_bytes = await generate_qr(qr_data)
    await callback.message.answer_photo(
        photo=types.BufferedInputFile(qr_image_bytes, filename="event_qr.png"),
        caption="Покажите этот QR-код волонтёру после донации для начисления баллов."
    )

--- КОНЕЦ ФАЙЛА: bot/handlers/student.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/volunteer.py ---

import datetime
import logging
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.utils.keyboard import InlineKeyboardBuilder

from bot.db import user_requests, event_requests
from bot.filters.role import RoleFilter
from bot.states.states import VolunteerActions
from bot.utils.qr_service import read_qr
from bot.keyboards import inline

router = Router()
logger = logging.getLogger(__name__)

@router.callback_query(F.data == "volunteer_panel", RoleFilter('volunteer'))
async def show_volunteer_panel(callback: types.CallbackQuery):
    builder = InlineKeyboardBuilder()
    builder.row(types.InlineKeyboardButton(text="📷 Подтвердить донацию (QR)", callback_data="confirm_donation_qr"))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад в меню донора", callback_data="back_to_student_menu"))
    await callback.message.edit_text(
        "⭐ *Меню волонтёра*", 
        reply_markup=builder.as_markup(), 
        parse_mode="Markdown"
    )
    await callback.answer()

@router.callback_query(F.data == "confirm_donation_qr", RoleFilter('volunteer'))
async def start_qr_confirmation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(VolunteerActions.awaiting_qr_photo)
    await callback.message.edit_text("Отправьте мне фотографию с QR-кодом донора.")
    await callback.answer()

@router.message(VolunteerActions.awaiting_qr_photo, F.photo)
async def process_qr_photo(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    photo_bytes = (await bot.download(message.photo[-1].file_id)).read()
    qr_data = await read_qr(photo_bytes)

    if not qr_data or "user_id" not in qr_data or "event_id" not in qr_data:
        await message.answer("❌ QR-код не распознан или имеет неверный формат. Попробуйте снова.")
        await state.clear()
        return

    try:
        donor_tg_id = int(qr_data["user_id"])
        event_id_from_qr = int(qr_data["event_id"])
    except (ValueError, TypeError):
        await message.answer("❌ QR-код содержит некорректные данные.")
        await state.clear()
        return

    donor = await user_requests.get_user_by_tg_id(session, donor_tg_id)
    event = await event_requests.get_event_by_id(session, event_id_from_qr)
    
    if not donor or not event:
        await message.answer("❌ Ошибка: Пользователь или мероприятие из QR-кода не найдены в базе.")
        await state.clear()
        return

    registration = await event_requests.find_specific_registration(session, donor.id, event.id)
    if not registration:
        await message.answer(f"❌ Ошибка: Донор *{donor.full_name}* не зарегистрирован на это мероприятие.", parse_mode="Markdown")
        await state.clear()
        return

    if event.event_date != datetime.date.today():
        await message.answer(f"❌ Ошибка: Этот QR-код для мероприятия, которое проходит не сегодня.", parse_mode="Markdown")
        await state.clear()
        return

    await state.update_data(
        donor_id=donor.id,
        event_id=event.id,
        donor_tg_id=donor.telegram_id,
        donor_name=donor.full_name,
        event_name=event.name
    )
    await state.set_state(VolunteerActions.awaiting_confirmation)

    await message.answer(
        f"🔍 *Подтверждение донации*\n\n"
        f"Вы собираетесь подтвердить донацию для:\n"
        f"👤 *Донор:* {donor.full_name}\n"
        f"🗓️ *Мероприятие:* {event.name}\n\n"
        f"Все верно?",
        reply_markup=inline.get_donation_confirmation_keyboard(donor.id, event.id),
        parse_mode="Markdown"
    )

@router.callback_query(VolunteerActions.awaiting_confirmation, F.data.startswith("confirm_donation_"))
async def process_donation_confirmation(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    donor_id_from_state = data.get("donor_id")
    event_id_from_state = data.get("event_id")
    
    parts = callback.data.split('_')
    donor_id_from_cb = parts[2]
    event_id_from_cb = parts[3]
    
    if not (donor_id_from_state == int(donor_id_from_cb) and event_id_from_state == int(event_id_from_cb)):
        await callback.message.edit_text("❌ Произошла ошибка. Пожалуйста, отсканируйте QR-код заново.")
        await state.clear()
        return

    await state.clear()
    await callback.message.edit_text("⏳ Подтверждаю донацию...")
    
    donor = await user_requests.get_user_by_id(session, donor_id_from_state)
    registration = await event_requests.find_specific_registration(session, donor_id_from_state, event_id_from_state)

    if not donor or not registration:
        await callback.message.edit_text("❌ Ошибка: не удалось найти донора или его регистрацию. Возможно, она была отменена.")
        return

    try:
        points_awarded, waiver_end_date = await event_requests.confirm_donation_transaction(session, donor, registration)
        await callback.message.edit_text(
            f"✅ Донация для *{donor.full_name}* на мероприятии «*{registration.event.name}*» подтверждена.\n\n"
            f"Начислено *{points_awarded}* баллов.", 
            parse_mode="Markdown"
        )
        success_text = (
            f"✅ Донация для *{donor.full_name}* подтверждена.\n"
            f"Начислено *{points_awarded}* баллов.\n\n"
            f"Готовы сканировать следующий QR-код."
        )
        await callback.message.edit_text(
            success_text,
            reply_markup=inline.get_volunteer_panel_keyboard(),
            parse_mode="Markdown"
        )
    except Exception as e:
        # logger.error(f"Critical error during donation confirmation for user {donor.id}: {e}", exc_info=True)
        await callback.message.edit_text(f"Произошла критическая ошибка при подтверждении донации: {e}")

    await callback.answer()

@router.message(VolunteerActions.awaiting_qr_photo)
async def process_qr_invalid_input(message: types.Message):
    await message.answer("Пожалуйста, отправьте именно фотографию с QR-кодом.")
    
@router.callback_query(F.data == "volunteer_panel", RoleFilter('volunteer'))
async def show_volunteer_panel(callback: types.CallbackQuery):
    await callback.message.edit_text(
        "⭐ *Меню волонтёра*", 
        reply_markup=inline.get_volunteer_panel_keyboard(),
        parse_mode="Markdown"
    )
    await callback.answer()


--- КОНЕЦ ФАЙЛА: bot/handlers/volunteer.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/handlers/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/event_management.py ---

import logging
import datetime
import asyncio
import io
import csv
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.markdown import hbold
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests, event_requests, user_requests
from bot.db.engine import async_session_maker
from bot.filters.role import RoleFilter
from bot.states.states import EventCreation, EventEditing
from bot.keyboards import inline
from bot.db.models import Event
from bot.utils.text_messages import Text

router = Router(name="admin_event_management")
logger = logging.getLogger(__name__)


# =============================================================================
# --- 🗓️ УПРАВЛЕНИЕ МЕРОПРИЯТИЯМИ ---
# =============================================================================

@router.callback_query(F.data == "admin_manage_events", RoleFilter('admin'))
async def manage_events_panel(callback: types.CallbackQuery):
    await callback.message.edit_text("🗓️ *Управление мероприятиями*", reply_markup=inline.get_events_management_keyboard(), parse_mode="Markdown")
    await callback.answer()

# --- Создание мероприятия ---
@router.callback_query(F.data == "admin_create_event", RoleFilter('admin'))
async def start_event_creation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(EventCreation.awaiting_name)
    await callback.message.edit_text("Шаг 1/7: Введите название мероприятия:")
    await callback.answer()

@router.message(EventCreation.awaiting_name)
async def process_event_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(EventCreation.awaiting_date)
    await message.answer("Шаг 2/7: Введите дату мероприятия (ДД.ММ.ГГГГ):")

@router.message(EventCreation.awaiting_date)
async def process_event_date(message: types.Message, state: FSMContext):
    try:
        event_date = datetime.datetime.strptime(message.text, "%d.%m.%Y").date()
        await state.update_data(event_date=event_date)
        await state.set_state(EventCreation.awaiting_location)
        await message.answer("Шаг 3/7: Введите место проведения:")
    except ValueError:
        await message.answer("❌ Неверный формат. Введите дату в формате ДД.ММ.ГГГГ.")

@router.message(EventCreation.awaiting_location)
async def process_event_location(message: types.Message, state: FSMContext):
    await state.update_data(location=message.text)
    await state.set_state(EventCreation.awaiting_donation_type)
    await message.answer("Шаг 4/7: Выберите тип донации:", reply_markup=inline.get_donation_type_keyboard())

@router.callback_query(EventCreation.awaiting_donation_type, F.data.startswith("settype_"))
async def process_event_donation_type(callback: types.CallbackQuery, state: FSMContext):
    donation_type = callback.data.split('_', 1)[1]
    await state.update_data(donation_type=donation_type)
    await state.set_state(EventCreation.awaiting_points)
    await callback.message.edit_text(f"Выбран тип: {donation_type}\n\nШаг 5/7: Введите количество баллов за донацию:")
    await callback.answer()

@router.message(EventCreation.awaiting_points)
async def process_event_points(message: types.Message, state: FSMContext):
    try:
        points = int(message.text)
        await state.update_data(points_per_donation=points)
        await state.set_state(EventCreation.awaiting_bonus_points)
        await message.answer("Шаг 6/7: Введите бонусные баллы за редкую кровь (можно 0):")
    except ValueError:
        await message.answer("❌ Введите целое число.")

@router.message(EventCreation.awaiting_bonus_points)
async def process_event_bonus_points(message: types.Message, state: FSMContext):
    try:
        bonus = int(message.text)
        await state.update_data(rare_blood_bonus_points=bonus)
        await state.set_state(EventCreation.awaiting_limit)
        await message.answer("Шаг 7/7: Введите лимит участников:")
    except ValueError:
        await message.answer("❌ Введите целое число.")

@router.message(EventCreation.awaiting_limit)
async def process_event_limit(message: types.Message, state: FSMContext):
    try:
        limit = int(message.text)
        await state.update_data(participant_limit=limit)
        await state.set_state(EventCreation.awaiting_confirmation)
        
        event_data = await state.get_data()
        text = "✅ Все данные собраны. Пожалуйста, проверьте:\n\n"
        text += f"▪️ Название: {event_data['name']}\n"
        text += f"▪️ Дата: {event_data['event_date'].strftime('%d.%m.%Y')}\n"
        text += f"▪️ Место: {event_data['location']}\n"
        text += f"▪️ Тип: {event_data['donation_type']}\n"
        text += f"▪️ Баллы: {event_data['points_per_donation']} (+{event_data['rare_blood_bonus_points']})\n"
        text += f"▪️ Лимит: {event_data['participant_limit']}\n\n"
        text += "Создать мероприятие и запустить рассылку?"
        
        await message.answer(text, reply_markup=inline.get_event_creation_confirmation_keyboard())
    except ValueError:
        await message.answer("❌ Лимит должен быть числом.")

@router.callback_query(EventCreation.awaiting_confirmation, F.data == "confirm_create_event")
async def confirm_event_creation_and_notify(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    await callback.message.edit_text("Принято. Создаю мероприятие...")
    
    event_data = await state.get_data()
    await state.clear()
    
    new_event = await admin_requests.create_event(session, event_data)
    await session.commit()
    
    await callback.message.answer("✅ Мероприятие успешно создано!", reply_markup=inline.get_back_to_admin_panel_keyboard())
    
    msg = await callback.message.answer("⏳ Начинаю рассылку. Это может занять некоторое время...")
    
    asyncio.create_task(send_new_event_notifications(new_event, bot, msg))
    
    await callback.answer()

async def send_new_event_notifications(event: Event, bot: Bot, status_message: types.Message):
    """Асинхронная задача для рассылки уведомлений о новом мероприятии."""
    async with async_session_maker() as session:
        try:
            users_to_notify = await user_requests.get_users_for_event_notification(session, event)
            logger.info(f"Starting mailing for event '{event.name}'. Found {len(users_to_notify)} users.")
            
            success_count, fail_count = 0, 0
            for user in users_to_notify:
                text = Text.NEW_EVENT_NOTIFICATION.format(
                    event_name=event.name,
                    event_date=event.event_date.strftime('%d.%m.%Y'),
                    event_location=event.location
                )
                try:
                    await bot.send_message(user.telegram_id, text, parse_mode="Markdown")
                    success_count += 1
                except Exception as e:
                    fail_count += 1
                    logger.error(f"Failed to send new event notification to user {user.id}. Error: {e}")
                await asyncio.sleep(0.1)
            
            await status_message.edit_text(f"✅ Рассылка завершена.\n\nОтправлено: {success_count}\nОшибок: {fail_count}")
        except Exception as e:
            logger.error(f"Critical error during new event mailing for event {event.id}: {e}", exc_info=True)
            await status_message.edit_text("❌ Произошла ошибка во время рассылки.")


# --- Просмотр и редактирование мероприятий ---
@router.callback_query(F.data == "admin_view_events", RoleFilter('admin'))
async def view_active_events(callback: types.CallbackQuery, session: AsyncSession):
    events = await event_requests.get_active_events(session)
    if not events:
        await callback.message.edit_text("Активных мероприятий нет.", reply_markup=inline.get_events_management_keyboard())
        await callback.answer()
        return

    builder = InlineKeyboardBuilder()
    for event in events:
        prefix = "✅" if event.registration_is_open else "🔒"
        builder.row(types.InlineKeyboardButton(
            text=f"{prefix} {event.event_date.strftime('%d.%m')} - {event.name}", 
            callback_data=f"admin_show_event_{event.id}"
        ))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_events"))
    
    await callback.message.edit_text("Выберите мероприятие для управления:\n(✅ - регистрация открыта, 🔒 - закрыта)", reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("admin_show_event_"), RoleFilter('admin'))
async def show_single_event_card(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event:
        await callback.answer("Мероприятие не найдено.", show_alert=True)
        return

    reg_count = await admin_requests.get_event_registrations_count(session, event_id)
    reg_status_text = 'Открыта' if event.registration_is_open else 'Закрыта'
    
    text_lines = [
        f"🗓️ {hbold('Мероприятие: ' + event.name)}", "",
        f"▪️ {hbold('Дата:')} {event.event_date.strftime('%d.%m.%Y')}",
        f"▪️ {hbold('Место:')} {event.location}",
        f"▪️ {hbold('Тип донации:')} {event.donation_type}",
        f"▪️ {hbold('Баллы:')} {event.points_per_donation} (+{event.rare_blood_bonus_points} за редкую кровь)",
        f"▪️ {hbold('Записано/Лимит:')} {reg_count}/{event.participant_limit}",
        f"▪️ {hbold('Статус:')} {'Активно' if event.is_active else 'Архивировано'}",
        f"▪️ {hbold('Регистрация:')} {reg_status_text}"
    ]
    text = "\n".join(text_lines)

    await callback.message.edit_text(
        text, 
        reply_markup=inline.get_single_event_management_keyboard(event.id, event.registration_is_open), 
        parse_mode="HTML"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_toggle_reg_"), RoleFilter('admin'))
async def toggle_event_registration(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    new_status = await admin_requests.toggle_event_registration_status(session, event_id)
    await session.commit()
    await callback.answer(f"Регистрация на мероприятие теперь {'открыта' if new_status else 'закрыта'}.", show_alert=True)
    await show_single_event_card(callback, session)

# --- Редактирование (FSM) ---
@router.callback_query(F.data.startswith("admin_edit_event_"), RoleFilter('admin'))
async def start_event_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event:
        await callback.answer("Мероприятие не найдено.", show_alert=True)
        return
        
    await state.update_data(event_id=event_id)
    await state.set_state(EventEditing.choosing_field)
    
    fields = {"name": "Название", "event_date": "Дата", "location": "Место", "points_per_donation": "Баллы", "participant_limit": "Лимит"}
    builder = InlineKeyboardBuilder()
    for key, name in fields.items():
        builder.row(types.InlineKeyboardButton(text=f"Изменить: {name}", callback_data=f"edit_field_{key}"))
    builder.row(types.InlineKeyboardButton(text="✅ Завершить", callback_data=f"admin_show_event_{event_id}"))
    
    await callback.message.edit_text(f"Вы редактируете: *{event.name}*\n\nКакое поле хотите изменить?", reply_markup=builder.as_markup(), parse_mode="Markdown")
    await callback.answer()

@router.callback_query(EventEditing.choosing_field, F.data.startswith("edit_field_"))
async def choose_field_to_edit(callback: types.CallbackQuery, state: FSMContext):
    field_to_edit = callback.data.split('_', 2)[-1]
    await state.update_data(field_to_edit=field_to_edit)
    await state.set_state(EventEditing.awaiting_new_value)
    prompts = {"name": "Введите новое название:", "event_date": "Введите новую дату (ДД.ММ.ГГГГ):", "location": "Введите новое место:", "points_per_donation": "Введите новое кол-во баллов:", "participant_limit": "Введите новый лимит:"}
    await callback.message.edit_text(prompts.get(field_to_edit, "Введите новое значение:"))
    await callback.answer()

@router.message(EventEditing.awaiting_new_value)
async def process_new_value_for_event(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    field, event_id, new_value_str = data.get("field_to_edit"), data.get("event_id"), message.text
    
    try:
        if field == "event_date": update_value = datetime.datetime.strptime(new_value_str, "%d.%m.%Y").date()
        elif field in ["points_per_donation", "participant_limit"]: update_value = int(new_value_str)
        else: update_value = new_value_str
    except ValueError:
        await message.answer("❌ Неверный формат данных. Попробуйте снова.")
        return
        
    await admin_requests.update_event_field(session, event_id, field, update_value)
    await session.commit()
    await state.clear()
    await message.answer("✅ Поле успешно обновлено!", reply_markup=inline.get_back_to_admin_panel_keyboard())

# --- Участники и отмена ---
@router.callback_query(F.data.startswith("admin_event_participants_"), RoleFilter('admin'))
async def get_event_participants(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event, participants_regs = await admin_requests.get_event_with_participants(session, event_id)
    if not event: return await callback.answer("Мероприятие не найдено", show_alert=True)
    if not participants_regs: return await callback.answer(f"На '{event.name}' пока никто не записался.", show_alert=True)

    output = io.StringIO()
    writer = csv.writer(output, delimiter=';')
    writer.writerow(['ID', 'ФИО', 'Телефон', 'Факультет', 'Группа', 'Статус'])
    for reg in participants_regs:
        writer.writerow([reg.user.id, reg.user.full_name, reg.user.phone_number, reg.user.faculty, reg.user.study_group, reg.status])
    
    output.seek(0)
    file = types.BufferedInputFile(output.getvalue().encode('utf-8-sig'), filename=f"participants_{event.id}.csv")
    await callback.message.answer_document(file, caption=f"Участники мероприятия '{event.name}'")
    await callback.answer()

@router.callback_query(F.data.startswith("admin_cancel_event_"), RoleFilter('admin'))
async def ask_for_cancellation_confirmation(callback: types.CallbackQuery, session: AsyncSession):
    event_id = int(callback.data.split('_')[-1])
    event = await event_requests.get_event_by_id(session, event_id)
    if not event: return await callback.answer("Мероприятие не найдено", show_alert=True)
    reg_count = await admin_requests.get_event_registrations_count(session, event_id)
    await callback.message.edit_text(f"🚨 *Подтверждение отмены*\n\nВы уверены, что хотите отменить «*{event.name}*»?\n\nУведомление будет отправлено *{reg_count}* участникам.", reply_markup=inline.get_event_cancellation_confirmation_keyboard(event_id), parse_mode="Markdown")
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_cancel_"), RoleFilter('admin'))
async def confirm_and_cancel_event(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    await callback.message.edit_text("⏳ Начинаю процесс отмены...")
    event_id = int(callback.data.split('_')[-1])
    event, participants_regs = await admin_requests.get_event_with_participants(session, event_id)
    if not event: return

    success_count, fail_count = 0, 0
    for reg in participants_regs:
        try:
            text = (f"❗️ *Внимание, мероприятие отменено!*\n\nК сожалению, «*{event.name}*», запланированное на {event.event_date.strftime('%d.%m.%Y')}, было отменено.")
            await bot.send_message(chat_id=reg.user.telegram_id, text=text, parse_mode="Markdown")
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.error(f"Failed to send cancellation to user {reg.user_id} for event {event.id}. Error: {e}")
        await asyncio.sleep(0.1)

    await admin_requests.deactivate_event(session, event_id)
    await session.commit()
    await callback.message.edit_text(f"✅ *Мероприятие «{event.name}» отменено.*\n\n*Результаты:*\n- Успешно отправлено: {success_count}\n- Ошибок: {fail_count}", reply_markup=inline.get_back_to_events_menu_keyboard())
    await callback.answer()


--- КОНЕЦ ФАЙЛА: bot/handlers/admin/event_management.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/mailing.py ---

import logging
import asyncio
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db.engine import async_session_maker
from bot.db import user_requests
from bot.filters.role import RoleFilter
from bot.states.states import Mailing
from bot.keyboards import inline

router = Router(name="admin_mailing")
logger = logging.getLogger(__name__)


# =============================================================================
# --- 📣 РАССЫЛКИ (FSM) ---
# =============================================================================

@router.callback_query(F.data == "admin_mailing", RoleFilter('admin'))
async def start_mailing(callback: types.CallbackQuery, state: FSMContext):
    """Шаг 1: Запрашивает текст для рассылки."""
    await state.clear()
    await state.set_state(Mailing.awaiting_message_text)
    await callback.message.edit_text(
        "Вы начали создание рассылки.\n\n"
        "<b>Шаг 1/3:</b> Введите текст сообщения. Он будет подписью, если вы добавите фото/видео. "
        "Можно использовать HTML-теги: <b>жирный</b>, <i>курсив</i>, <code>код</code>, <a href='...'>ссылка</a>.\n\n"
        "Чтобы отменить, нажмите /cancel.",
        parse_mode="HTML"
    )
    await callback.answer()

@router.message(Mailing.awaiting_message_text)
async def get_mailing_text(message: types.Message, state: FSMContext):
    """Шаг 2: Получает текст и запрашивает медиа."""
    await state.update_data(
        message_text=message.html_text,
        photo_id=None,
        video_id=None
    )
    await state.set_state(Mailing.awaiting_media)
    
    await message.answer(
        "Текст получен.\n\n"
        "<b>Шаг 2/3:</b> Теперь отправьте фото или видео, которое нужно прикрепить к рассылке. "
        "Если хотите отправить только текст, нажмите 'Пропустить'.",
        reply_markup=inline.get_skip_media_keyboard(),
        parse_mode="HTML"
    )

# --- Обработка медиа ---
@router.message(Mailing.awaiting_media, F.photo)
async def get_mailing_photo(message: types.Message, state: FSMContext):
    """Ловит фото, сохраняет его ID и переходит к выбору аудитории."""
    photo_file_id = message.photo[-1].file_id
    await state.update_data(photo_id=photo_file_id)
    await state.set_state(Mailing.awaiting_audience_choice)
    await message.answer(
        "Фото получено.\n\n"
        "<b>Шаг 3/3:</b> Выберите аудиторию для рассылки:",
        reply_markup=inline.get_mailing_audience_keyboard(),
        parse_mode="HTML"
    )

@router.message(Mailing.awaiting_media, F.video)
async def get_mailing_video(message: types.Message, state: FSMContext):
    """Ловит видео, сохраняет его ID и переходит к выбору аудитории."""
    video_file_id = message.video.file_id
    await state.update_data(video_id=video_file_id)
    await state.set_state(Mailing.awaiting_audience_choice)
    await message.answer(
        "Видео получено.\n\n"
        "<b>Шаг 3/3:</b> Выберите аудиторию для рассылки:",
        reply_markup=inline.get_mailing_audience_keyboard(),
        parse_mode="HTML"
    )

@router.callback_query(Mailing.awaiting_media, F.data == "skip_media")
async def skip_media_step(callback: types.CallbackQuery, state: FSMContext):
    """Пропускает шаг добавления медиа."""
    await state.set_state(Mailing.awaiting_audience_choice)
    await callback.message.edit_text(
        "<b>Шаг 3/3:</b> Выберите аудиторию для рассылки:",
        reply_markup=inline.get_mailing_audience_keyboard(),
        parse_mode="HTML"
    )
    await callback.answer()

# --- Выбор аудитории и подтверждение ---
@router.callback_query(Mailing.awaiting_audience_choice, F.data.startswith("mail_audience_"))
async def get_mailing_audience(callback: types.CallbackQuery, state: FSMContext):
    """Получает аудиторию и показывает превью для подтверждения."""
    audience = callback.data.split('_', 2)[-1]
    await state.update_data(audience=audience)
    
    data = await state.get_data()
    message_text = data.get("message_text")
    photo_id = data.get("photo_id")
    video_id = data.get("video_id")
    
    audience_map = { "all": "Всем пользователям", "can_donate": "Донорам, которые могут сдавать", "volunteers": "Волонтерам", "admins": "Администраторам" }
    
    preview_text = (f"<b>🔍 Проверьте рассылку перед запуском</b>\n\n"
                    f"<b>👤 Аудитория:</b> {audience_map.get(audience, 'Неизвестно')}\n")
    
    if photo_id: preview_text += "🖼️ <b>Прикреплено фото</b>\n"
    if video_id: preview_text += "📹 <b>Прикреплено видео</b>\n"
    
    preview_text += (f"\n<b>✉️ Текст/подпись:</b>\n"
                     f"------------------------------------\n"
                     f"{message_text}\n"
                     f"------------------------------------")
            
    await state.set_state(Mailing.awaiting_confirmation)
    
    await callback.message.delete()
    await callback.message.answer(preview_text, reply_markup=inline.get_mailing_confirmation_keyboard(), parse_mode="HTML")
    await callback.answer()

@router.callback_query(Mailing.awaiting_confirmation, F.data == "edit_mailing_text")
async def edit_mailing_text(callback: types.CallbackQuery, state: FSMContext):
    """Позволяет вернуться к редактированию текста."""
    await state.set_state(Mailing.awaiting_message_text)
    await callback.message.edit_text("Введите новый текст сообщения для рассылки:")
    await callback.answer()

@router.callback_query(Mailing.awaiting_confirmation, F.data == "confirm_mailing")
async def confirm_and_start_mailing(callback: types.CallbackQuery, state: FSMContext, bot: Bot):
    """Запускает рассылку в фоновом режиме."""
    data = await state.get_data()
    await state.clear()
    
    await callback.message.edit_text(
        f"✅ Рассылка запущена в фоновом режиме. Вы можете продолжать пользоваться ботом.",
        reply_markup=inline.get_back_to_admin_panel_keyboard()
    )
    
    # Запускаем саму рассылку как фоновую задачу
    asyncio.create_task(do_mailing(
        audience=data.get("audience"),
        message_text=data.get("message_text"),
        photo_id=data.get("photo_id"),
        video_id=data.get("video_id"),
        bot=bot
    ))
    await callback.answer()

async def do_mailing(audience: str, message_text: str, photo_id: str | None, video_id: str | None, bot: Bot):
    """Асинхронная задача для выполнения рассылки с текстом и/или медиа."""
    logger.info(f"Starting mailing for audience: {audience}")
    async with async_session_maker() as session:
        try:
            users = await user_requests.get_users_by_criteria(session, audience)
            if not users:
                logger.warning("No users found for this mailing criteria.")
                return

            logger.info(f"Found {len(users)} users for mailing.")
            success_count, fail_count = 0, 0

            for user in users:
                try:
                    if photo_id:
                        await bot.send_photo(user.telegram_id, photo_id, caption=message_text, parse_mode="HTML")
                    elif video_id:
                        await bot.send_video(user.telegram_id, video_id, caption=message_text, parse_mode="HTML")
                    else:
                        await bot.send_message(user.telegram_id, message_text, parse_mode="HTML")
                    success_count += 1
                except Exception as e:
                    fail_count += 1
                    logger.error(f"Failed to send message to user {user.id} ({user.telegram_id}). Error: {e}")
                await asyncio.sleep(0.1)

            logger.info(f"Mailing finished. Sent: {success_count}, Failed: {fail_count}.")

        except Exception as e:
            logger.error(f"Critical error during mailing: {e}", exc_info=True)

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/mailing.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/merch_management.py ---

import logging
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.exceptions import TelegramBadRequest
from aiogram.utils.markdown import hbold, hlink
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload

from bot.db import admin_requests, user_requests
from bot.filters.role import RoleFilter
from bot.states.states import MerchCreation, MerchEditing
from bot.keyboards import inline
from bot.db.models import MerchOrder

router = Router(name="admin_merch_management")
logger = logging.getLogger(__name__)


# =============================================================================
# --- 🛍️ УПРАВЛЕНИЕ МАГАЗИНОМ ---
# =============================================================================
@router.callback_query(F.data == "admin_manage_merch", RoleFilter('admin'))
async def manage_merch_panel(callback: types.CallbackQuery):
    await callback.message.edit_text("🛍️ *Управление магазином*", reply_markup=inline.get_merch_management_keyboard(), parse_mode="Markdown")
    await callback.answer()

# --- Создание товара ---
@router.callback_query(F.data == "admin_create_merch", RoleFilter('admin'))
async def start_merch_creation(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(MerchCreation.awaiting_photo)
    await callback.message.edit_text("Отправьте фотографию для нового товара.")
    await callback.answer()

@router.message(MerchCreation.awaiting_photo, F.photo)
async def process_merch_photo(message: types.Message, state: FSMContext):
    photo_file_id = message.photo[-1].file_id
    await state.update_data(photo_file_id=photo_file_id)
    await state.set_state(MerchCreation.awaiting_name)
    await message.answer("Фото получено. Введите название товара:")

@router.message(MerchCreation.awaiting_name)
async def process_merch_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(MerchCreation.awaiting_description)
    await message.answer("Название сохранено. Введите описание товара:")

@router.message(MerchCreation.awaiting_description)
async def process_merch_description(message: types.Message, state: FSMContext):
    await state.update_data(description=message.text)
    await state.set_state(MerchCreation.awaiting_price)
    await message.answer("Описание сохранено. Введите цену в баллах:")
    
@router.message(MerchCreation.awaiting_price)
async def process_merch_price(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        price = int(message.text)
        await state.update_data(price=price)
        item_data = await state.get_data()
        
        if 'photo_file_id' not in item_data or not item_data['photo_file_id']:
            logger.error("photo_file_id is missing from FSM data during merch creation!")
            await message.answer("❌ Произошла ошибка: ID фото не был сохранен. Начните заново.")
            await state.clear()
            return

        await admin_requests.create_merch_item(session, item_data)
        await session.commit()
        await state.clear()
        
        await message.answer("✅ Товар успешно добавлен!", reply_markup=inline.get_back_to_admin_panel_keyboard())
    except ValueError:
        await message.answer("❌ Цена должна быть целым числом.")

# --- Просмотр и редактирование товаров ---
@router.callback_query(F.data == "admin_view_merch", RoleFilter('admin'))
async def view_merch_items(callback: types.CallbackQuery, session: AsyncSession):
    items = await admin_requests.get_all_merch_items(session)
    if not items:
        await callback.message.edit_text("В магазине пока нет товаров.", reply_markup=inline.get_merch_management_keyboard())
        return

    builder = InlineKeyboardBuilder()
    for item in items:
        status = "✅" if item.is_available else "❌"
        builder.row(types.InlineKeyboardButton(text=f"{status} {item.name} ({item.price}Б)", callback_data=f"admin_show_merch_{item.id}"))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_merch"))

    try:
        await callback.message.edit_text("Выберите товар для управления:", reply_markup=builder.as_markup())
    except TelegramBadRequest:
        await callback.message.delete()
        await callback.message.answer("Выберите товар для управления:", reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("admin_show_merch_"), RoleFilter('admin'))
async def show_single_merch_card(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer("Товар не найден", show_alert=True)

    caption = (f"🛍️ *Товар: {item.name}*\n\n"
               f"▪️ *Описание:* {item.description}\n"
               f"▪️ *Цена:* {item.price} баллов\n"
               f"▪️ *Статус:* {'✅ Доступен' if item.is_available else '❌ Недоступен'}")
    await callback.message.edit_media(media=types.InputMediaPhoto(media=item.photo_file_id, caption=caption, parse_mode="Markdown"),
        reply_markup=inline.get_single_merch_management_keyboard(item.id, item.is_available))
    await callback.answer()

@router.callback_query(F.data.startswith("admin_edit_merch_"), RoleFilter('admin'))
async def start_merch_editing(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    await state.clear()
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return

    await state.update_data(item_id=item_id)
    await state.set_state(MerchEditing.choosing_field)
    
    fields = {"name": "Название", "description": "Описание", "price": "Цена"}
    builder = InlineKeyboardBuilder()
    for key, name in fields.items():
        builder.row(types.InlineKeyboardButton(text=f"Изменить: {name}", callback_data=f"edit_merch_field_{key}"))
    builder.row(types.InlineKeyboardButton(text="✅ Завершить", callback_data=f"admin_show_merch_{item_id}"))
    
    await callback.message.edit_caption(caption=f"Вы редактируете: *{item.name}*\n\nКакое поле хотите изменить?", reply_markup=builder.as_markup(), parse_mode="Markdown")

@router.callback_query(MerchEditing.choosing_field, F.data.startswith("edit_merch_field_"))
async def choose_merch_field_to_edit(callback: types.CallbackQuery, state: FSMContext):
    field_to_edit = callback.data.split('_', 3)[-1]
    await state.update_data(field_to_edit=field_to_edit)
    await state.set_state(MerchEditing.awaiting_new_value)
    
    prompts = {"name": "Введите новое название:", "description": "Введите новое описание:", "price": "Введите новую цену в баллах:"}
    await callback.message.delete()
    await callback.message.answer(prompts.get(field_to_edit, "Введите новое значение:"))
    await callback.answer()

@router.message(MerchEditing.awaiting_new_value)
async def process_new_value_for_merch(message: types.Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    field, item_id, new_value_str = data.get("field_to_edit"), data.get("item_id"), message.text
    try:
        update_value = int(new_value_str) if field == "price" else new_value_str
    except ValueError:
        return await message.answer("❌ Цена должна быть числом.")

    await admin_requests.update_merch_item_field(session, item_id, field, update_value)
    await session.commit()
    await message.answer("✅ Поле успешно обновлено!")
    await state.clear()
    
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    caption = (f"🛍️ *Товар: {item.name}*\n\n"
               f"▪️ *Описание:* {item.description}\n"
               f"▪️ *Цена:* {item.price} баллов\n"
               f"▪️ *Статус:* {'✅ Доступен' if item.is_available else '❌ Недоступен'}")
    await message.answer_photo(photo=item.photo_file_id, caption=caption,
        reply_markup=inline.get_single_merch_management_keyboard(item.id, item.is_available), parse_mode="Markdown")

@router.callback_query(F.data.startswith("admin_toggle_merch_"), RoleFilter('admin'))
async def toggle_merch_availability(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    new_status = await admin_requests.toggle_merch_item_availability(session, item_id)
    await session.commit()
    await callback.answer(f"Статус изменен на: {'доступен' if new_status else 'недоступен'}.", show_alert=True)
    await show_single_merch_card(callback, session)

@router.callback_query(F.data.startswith("admin_delete_merch_"), RoleFilter('admin'))
async def ask_for_merch_deletion_confirmation(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer("Товар не найден.", show_alert=True)
    
    try: await callback.message.delete()
    except TelegramBadRequest: pass
    
    await callback.message.answer(f"🗑️ *Подтверждение удаления*\n\nВы уверены, что хотите **безвозвратно** удалить «*{item.name}*»?",
        reply_markup=inline.get_merch_deletion_confirmation_keyboard(item_id), parse_mode="Markdown")
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_delete_merch_"), RoleFilter('admin'))
async def confirm_and_delete_merch(callback: types.CallbackQuery, session: AsyncSession):
    item_id = int(callback.data.split('_')[-1])
    item = await admin_requests.get_merch_item_by_id(session, item_id)
    if not item: return await callback.answer("Товар уже удален.", show_alert=True)
    
    item_name = item.name
    await admin_requests.delete_merch_item_by_id(session, item_id)
    await session.commit()
    await callback.message.edit_text(f"✅ Товар «*{item_name}*» был удален.", reply_markup=inline.get_back_to_merch_menu_keyboard(), parse_mode="Markdown")
    await callback.answer()

# =============================================================================
# --- 📦 ОБРАБОТКА ЗАКАЗОВ ---
# =============================================================================
@router.callback_query(F.data == "admin_process_orders", RoleFilter('admin'))
async def process_orders_list(callback: types.CallbackQuery, session: AsyncSession):
    orders = await admin_requests.get_pending_orders(session)
    if not orders:
        await callback.answer("Новых заказов нет.", show_alert=True)
        return
    
    text_parts = [hbold("📦 Новые заказы на выдачу:"), ""]
    builder = InlineKeyboardBuilder()
    for order in orders:
        user_link = hlink(order.user.full_name, f"tg://user?id={order.user.telegram_id}")
        contact_info = f"{user_link} (@{order.user.telegram_username})" if order.user.telegram_username else user_link

        order_info = [
            f"🔹 {hbold(f'Заказ №{order.id}')} от {order.order_date.strftime('%d.%m %H:%M')}",
            f"   Товар: «{order.item.name}»",
            f"   Заказал: {contact_info}",
            f"   Телефон: {order.user.phone_number}"
        ]
        text_parts.extend(order_info)
        text_parts.append("")
        builder.row(types.InlineKeyboardButton(text=f"✅ Выдать заказ №{order.id}", callback_data=f"complete_order_{order.id}"))
    
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    
    await callback.message.edit_text(
        text="\n".join(text_parts), 
        reply_markup=builder.as_markup(), 
        parse_mode="HTML",
        disable_web_page_preview=True
    )
    await callback.answer()
    
@router.callback_query(F.data.startswith("complete_order_"), RoleFilter('admin'))
async def complete_order(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    order_id = int(callback.data.split('_')[-1])
    
    admin_user = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not admin_user:
        await callback.answer("Ошибка: не удалось идентифицировать администратора.", show_alert=True)
        return

    order = await session.get(MerchOrder, order_id, options=[joinedload(MerchOrder.item), joinedload(MerchOrder.user)])
    if not order or order.status != 'pending_pickup':
        await callback.answer("Заказ не найден или уже обработан.", show_alert=True)
        return

    await admin_requests.complete_order(session, order_id, admin_user.id)
    await session.commit()
    await callback.answer(f"✅ Заказ №{order_id} помечен как выданный.", show_alert=True)
    
    try:
        await bot.send_message(
            chat_id=order.user.telegram_id,
            text=f"🎉 Ваш заказ «{order.item.name}» был выдан. Приятного пользования!"
        )
    except Exception as e:
        logger.error(f"Failed to notify user {order.user.id} about order completion: {e}")
    
    await process_orders_list(callback, session)


--- КОНЕЦ ФАЙЛА: bot/handlers/admin/merch_management.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/system.py ---

import io
import csv
import logging
import zipfile
import datetime
from aiogram import Router, F, types, Bot
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests
from bot.filters.role import RoleFilter

router = Router(name="admin_system")
logger = logging.getLogger(__name__)


# =============================================================================
# --- 💾 ЭКСПОРТ ДАННЫХ (ТОЛЬКО ДЛЯ ГЛАВНОГО АДМИНА) ---
# =============================================================================

async def create_full_backup_zip(session: AsyncSession) -> io.BytesIO:
    """
    Собирает данные из всех таблиц, создает CSV-файлы и упаковывает их в ZIP-архив в памяти.
    """
    all_data = await admin_requests.get_all_data_for_export(session)
    
    zip_buffer = io.BytesIO()
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for table_name, records in all_data.items():
            if not records:
                continue

            csv_buffer = io.StringIO()
            headers = [c.name for c in records[0].__table__.columns]
            writer = csv.DictWriter(csv_buffer, fieldnames=headers, delimiter=';')
            writer.writeheader()
            
            for record in records:
                row_data = {}
                for h in headers:
                    # Преобразуем сложные типы в строки, чтобы избежать ошибок csv
                    value = getattr(record, h)
                    if isinstance(value, (datetime.datetime, datetime.date)):
                        row_data[h] = value.isoformat()
                    elif isinstance(value, list):
                         row_data[h] = str(value) # для relationship полей, хотя лучше их не выгружать так
                    else:
                        row_data[h] = value
                writer.writerow(row_data)
            
            # Добавляем CSV-строку в ZIP-архив как файл
            zip_file.writestr(f"{table_name}.csv", csv_buffer.getvalue().encode('utf-8-sig'))

    zip_buffer.seek(0)
    return zip_buffer


@router.callback_query(F.data == "ma_export_data", RoleFilter('main_admin'))
async def export_data_start(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    """
    Запускает процесс создания и отправки полного бэкапа.
    """
    msg = await callback.message.edit_text("⏳ Начинаю сбор данных и создание архива... Это может занять некоторое время.")
    await callback.answer()

    try:
        zip_archive_bytes = await create_full_backup_zip(session)
        
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")
        filename = f"donor_bot_backup_{timestamp}.zip"
        
        await bot.send_document(
            chat_id=callback.from_user.id,
            document=types.BufferedInputFile(zip_archive_bytes.read(), filename=filename),
            caption="✅ Полный бэкап базы данных готов."
        )
        
        await msg.delete()

    except Exception as e:
        logger.error(f"Failed to create data backup: {e}", exc_info=True)
        await msg.edit_text("❌ Произошла ошибка при создании бэкапа. Подробности в логах.")

--- КОНЕЦ ФАЙЛА: bot/handlers/admin/system.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/user_management.py ---

import logging
import datetime
from aiogram import Router, F, types, Bot
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.markdown import hbold, hcode
from sqlalchemy.ext.asyncio import AsyncSession

from bot.db import admin_requests, user_requests, event_requests
from bot.filters.role import RoleFilter
from bot.states.states import (
    PointsChange,
    ManualWaiver,
    UserSearch,
    BlockUser,
)
from bot.keyboards import inline

router = Router(name="admin_user_management")
logger = logging.getLogger(__name__)


# =============================================================================
# --- 👥 УПРАВЛЕНИЕ ПОЛЬЗОВАТЕЛЯМИ ---
# =============================================================================

@router.callback_query(F.data == "admin_manage_users", RoleFilter('admin'))
async def manage_users_main_menu(callback: types.CallbackQuery):
    """Показывает главное меню управления пользователями."""
    await callback.message.edit_text(
        "👥 *Управление пользователями*",
        reply_markup=inline.get_user_management_main_keyboard(),
        parse_mode="Markdown"
    )
    await callback.answer()

# --- Список пользователей с пагинацией ---
@router.callback_query(F.data.startswith("admin_users_list_page_"), RoleFilter('admin'))
async def show_users_list(callback: types.CallbackQuery, session: AsyncSession):
    page = int(callback.data.split('_')[-1])
    page_size = 10

    users, total_pages = await admin_requests.get_users_page(session, page, page_size)

    if not users:
        await callback.message.edit_text("В базе данных пока нет пользователей.", reply_markup=inline.get_user_management_main_keyboard())
        await callback.answer()
        return

    text = f"📜 *Список пользователей (Страница {page}/{total_pages})*\n\n"
    builder = InlineKeyboardBuilder()
    for user in users:
        builder.row(types.InlineKeyboardButton(text=f"👤 {user.full_name}", callback_data=f"admin_show_user_{user.id}"))

    pagination_keyboard = inline.get_users_list_pagination_keyboard(page, total_pages)
    for row in pagination_keyboard.inline_keyboard:
        builder.row(*row)

    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode="Markdown")
    await callback.answer()

# --- Поиск пользователя ---
@router.callback_query(F.data == "admin_search_user", RoleFilter('admin'))
async def search_user_start(callback: types.CallbackQuery, state: FSMContext):
    """Запускает FSM для поиска пользователя."""
    await state.clear()
    await state.set_state(UserSearch.awaiting_query)
    await callback.message.edit_text("🔍 Введите запрос для поиска (ФИО, username, ID, телефон):")
    await callback.answer()

@router.message(UserSearch.awaiting_query)
async def process_user_search(message: types.Message, state: FSMContext, session: AsyncSession):
    """Ищет пользователей по запросу и выводит результат."""
    await state.clear()
    query = message.text
    users_found = await admin_requests.find_user_for_admin(session, query)

    if not users_found:
        await message.answer("🤷‍♂️ По вашему запросу никого не найдено.", reply_markup=inline.get_user_management_main_keyboard())
        return

    text = f"🔍 *Результаты поиска по запросу «{query}»:*\n\n"
    builder = InlineKeyboardBuilder()
    for user in users_found:
        builder.row(types.InlineKeyboardButton(text=f"👤 {user.full_name}", callback_data=f"admin_show_user_{user.id}"))
    builder.row(types.InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_users"))

    await message.answer(text, reply_markup=builder.as_markup(), parse_mode="Markdown")

# --- Карточка пользователя и управление им ---
@router.callback_query(F.data.startswith("admin_show_user_"), RoleFilter('admin'))
async def show_single_user_card(callback: types.CallbackQuery, session: AsyncSession):
    """Показывает карточку одного пользователя с динамической клавиатурой."""
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer: return

    target_user_id = int(callback.data.split('_')[-1])
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return

    block_status = "ЗАБЛОКИРОВАН" if target_user.is_blocked else "Активен"

    text_lines = [
        hbold(f"👤 Профиль пользователя: {target_user.full_name}"),
        "",
        f"  *ФИО:* {target_user.full_name}",
        f"  *ID:* {hcode(target_user.telegram_id)}",
        f"  *Username:* @{target_user.telegram_username or 'не указан'}",
        f"  *Телефон:* {hcode(target_user.phone_number)}",
        f"  *Роль:* {hcode(target_user.role)}",
        f"  *Баллы:* {hbold(str(target_user.points))}",
        f"  *Статус:* {hbold(block_status)}"
    ]
    text = "\n".join(text_lines)

    await callback.message.edit_text(
        text,
        reply_markup=inline.get_user_management_keyboard(
            target_user_id=target_user.id,
            target_user_role=target_user.role,
            viewer_role=viewer.role,
            is_blocked=target_user.is_blocked
        ),
        parse_mode="HTML"
    )
    await callback.answer()

# --- +/- Баллы (FSM) ---
@router.callback_query(F.data.startswith("admin_points_"), RoleFilter('admin'))
async def change_points_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    user_id = int(callback.data.split('_')[-1])
    await state.update_data(user_id=user_id)
    await state.set_state(PointsChange.awaiting_points_amount)
    await callback.message.edit_text("Введите сумму баллов для начисления (например, 50) или списания (-50):")
    await callback.answer()

@router.message(PointsChange.awaiting_points_amount)
async def change_points_amount(message: types.Message, state: FSMContext):
    try:
        points = int(message.text)
        await state.update_data(points=points)
        await state.set_state(PointsChange.awaiting_reason)
        await message.answer("Введите причину начисления/списания:")
    except ValueError:
        await message.answer("❌ Введите целое число.")

@router.message(PointsChange.awaiting_reason)
async def change_points_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason, user_id, points_change = message.text, data['user_id'], data['points']
    
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await message.answer("Пользователь не найден.")
        await state.clear()
        return

    await admin_requests.add_points_to_user(session, user_id, points_change, reason)
    await session.commit() # Unit of Work
    await state.clear()

    new_balance = user.points # aidd_points_to_user уже изменил user.points
    await message.answer(f"✅ Баланс пользователя {user.full_name} изменен. Новый баланс: {new_balance}", reply_markup=inline.get_back_to_admin_panel_keyboard())

    try:
        await bot.send_message(user.telegram_id, f"⚙️ Администратор изменил ваш баланс на {points_change} баллов.\n*Причина:* {reason}\n*Ваш новый баланс:* {new_balance}", parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Failed to notify user {user_id} about points change: {e}")

# --- Ручное управление ролями ---
@router.callback_query(F.data.startswith("admin_promote_volunteer_"), RoleFilter('admin'))
async def promote_to_volunteer(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, user_id, 'volunteer')
    await session.commit()
    user = await user_requests.get_user_by_id(session, user_id)
    await callback.answer(f"✅ Пользователь {user.full_name} назначен волонтером.", show_alert=True)
    try:
        await bot.send_message(user.telegram_id, "⭐ Поздравляем! Администратор назначил вас волонтером. Вам доступно меню волонтера.")
    except Exception as e:
        logger.error(f"Failed to notify user {user.id} about promotion: {e}")
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("admin_demote_volunteer_"), RoleFilter('admin'))
async def demote_from_volunteer(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, user_id, 'student')
    await session.commit()
    user = await user_requests.get_user_by_id(session, user_id)
    await callback.answer(f"✅ Пользователь {user.full_name} снят с должности волонтера.", show_alert=True)
    try:
        await bot.send_message(user.telegram_id, "⚙️ Ваша роль изменена на 'студент'. Меню волонтера больше недоступно.")
    except Exception as e:
        logger.error(f"Failed to notify user {user.id} about demotion: {e}")
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("ma_promote_admin_"), RoleFilter('main_admin'))
async def promote_to_admin(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    target_user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, target_user_id, 'admin')
    await session.commit()
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    await callback.answer(f"✅ {target_user.full_name} назначен администратором.", show_alert=True)
    try:
        await bot.send_message(target_user.telegram_id, "Поздравляем! Вас назначили администратором бота.")
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about admin promotion: {e}")
    await show_single_user_card(callback, session)

@router.callback_query(F.data.startswith("ma_demote_admin_"), RoleFilter('main_admin'))
async def demote_from_admin(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    target_user_id = int(callback.data.split('_')[-1])
    await admin_requests.change_user_role(session, target_user_id, 'student')
    await session.commit()
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    await callback.answer(f"✅ {target_user.full_name} разжалован до студента.", show_alert=True)
    try:
        await bot.send_message(target_user.telegram_id, "Ваша роль изменена на 'студент'.")
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about admin demotion: {e}")
    await show_single_user_card(callback, session)

# --- Управление блокировками ---
@router.callback_query(F.data.startswith("ma_block_user_"), RoleFilter('main_admin'))
async def block_user_from_card(callback: types.CallbackQuery, state: FSMContext):
    target_user_id = int(callback.data.split('_')[-1])
    await state.clear()
    await state.update_data(user_id=target_user_id)
    await state.set_state(BlockUser.awaiting_reason)
    await callback.message.edit_text("Введите причину блокировки:")
    await callback.answer()

@router.message(BlockUser.awaiting_reason)
async def process_block_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason = message.text
    target_user_id = data['user_id']

    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    if not admin_user:
        await message.answer("Критическая ошибка: не удалось идентифицировать вас.")
        await state.clear()
        return

    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await message.answer("Ошибка: целевой пользователь не найден.")
        await state.clear()
        return

    await admin_requests.block_user(session, target_user_id, admin_user.id, reason)
    await session.commit()
    await state.clear()

    await message.answer(f"✅ Пользователь {target_user.full_name} заблокирован. Причина: {reason}", reply_markup=inline.get_back_to_admin_panel_keyboard())
    try:
        await bot.send_message(target_user.telegram_id, f"Ваш аккаунт был заблокирован.\nПричина: {reason}")
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about block: {e}")

@router.callback_query(F.data.startswith("ma_unblock_user_"), RoleFilter('main_admin'))
async def unblock_user_from_card(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    target_user_id = int(callback.data.split('_')[-1])
    await admin_requests.unblock_user(session, target_user_id)
    await session.commit()
    target_user = await user_requests.get_user_by_id(session, target_user_id)
    if not target_user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return

    await callback.answer(f"✅ Пользователь {target_user.full_name} успешно разблокирован.", show_alert=True)
    try:
        await bot.send_message(target_user.telegram_id, "🎉 Ваш аккаунт был разблокирован. Теперь вы снова можете пользоваться ботом.")
    except Exception as e:
        logger.error(f"Failed to notify user {target_user.id} about unblock: {e}")
    await show_single_user_card(callback, session)


# --- Ручное управление регистрациями ---
@router.callback_query(F.data.startswith("admin_manage_user_regs_"), RoleFilter('admin'))
async def manage_user_registrations_menu(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return

    await callback.message.edit_text(
        f"🎟️ Управление регистрациями для: *{user.full_name}*\n\nВыберите действие:",
        reply_markup=inline.get_manual_registration_management_keyboard(user_id),
        parse_mode="Markdown"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_reg_start_"), RoleFilter('admin'))
async def show_events_for_manual_registration(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    events = await event_requests.get_upcoming_events(session)
    if not events:
        await callback.answer("Нет предстоящих мероприятий для записи.", show_alert=True)
        return

    await callback.message.edit_text(
        "Выберите мероприятие, на которое нужно записать пользователя:",
        reply_markup=inline.get_events_for_manual_registration_keyboard(user_id, events)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("adminReg_"), RoleFilter('admin'))
async def confirm_manual_registration(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    _, user_id_str, event_id_str = callback.data.split('_')
    user_id, event_id = int(user_id_str), int(event_id_str)
    
    user = await user_requests.get_user_by_id(session, user_id)
    event = await event_requests.get_event_by_id(session, event_id)
    if not user or not event:
        await callback.answer("Ошибка: пользователь или мероприятие не найдены.", show_alert=True)
        return

    success, message = await admin_requests.manually_register_user(session, user, event)
    if success:
        await session.commit()
        try:
            await bot.send_message(
                user.telegram_id,
                f"⚙️ Администратор записал вас на мероприятие «*{event.name}*» на {event.event_date.strftime('%d.%m.%Y')}.",
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about manual registration: {e}")
            await callback.message.answer(f"⚠️ Не удалось уведомить пользователя {user.full_name}.")
    else:
        await session.rollback()

    await callback.answer(message, show_alert=True)
    await manage_user_registrations_menu(callback, session)

@router.callback_query(F.data.startswith("admin_cancel_start_"), RoleFilter('admin'))
async def show_registrations_for_cancellation(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    registrations = await admin_requests.get_user_registrations(session, user_id)
    
    if not registrations:
        await callback.answer("У этого пользователя нет активных регистраций на будущие мероприятия.", show_alert=True)
        return

    await callback.message.edit_text(
        "Выберите регистрацию, которую нужно отменить:",
        reply_markup=inline.get_registrations_for_cancellation_keyboard(user_id, registrations)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("adminCancel_"), RoleFilter('admin'))
async def confirm_manual_cancellation(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    _, user_id_str, event_id_str = callback.data.split('_')
    user_id, event_id = int(user_id_str), int(event_id_str)

    user = await user_requests.get_user_by_id(session, user_id)
    event = await event_requests.get_event_by_id(session, event_id)
    if not user or not event:
        await callback.answer("Ошибка: пользователь или мероприятие не найдены.", show_alert=True)
        return
        
    success = await event_requests.cancel_registration(session, user_id, event_id)
    if success:
        await session.commit()
        await callback.answer(f"Регистрация пользователя {user.full_name} на {event.name} отменена.", show_alert=True)
        try:
            await bot.send_message(
                user.telegram_id,
                f"⚙️ Администратор отменил вашу запись на мероприятие «*{event.name}*».",
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about manual cancellation: {e}")
            await callback.message.answer(f"⚠️ Не удалось уведомить пользователя {user.full_name}.")
    else:
        await session.rollback()
        await callback.answer("Не удалось отменить регистрацию (возможно, уже отменена).", show_alert=True)
        
    await manage_user_registrations_menu(callback, session)

# --- Управление медотводами ---
@router.callback_query(F.data.startswith("admin_manage_waivers_"), RoleFilter('admin'))
async def admin_manage_user_waivers_menu(callback: types.CallbackQuery, session: AsyncSession):
    user_id = int(callback.data.split('_')[-1])
    user = await user_requests.get_user_by_id(session, user_id)
    if not user:
        await callback.answer("Пользователь не найден.", show_alert=True)
        return

    waivers = await admin_requests.get_all_user_active_waivers(session, user_id)
    text_header = f"⚕️ Управление медотводами пользователя *{user.full_name}*.\n\n"
    if not waivers:
        text = text_header + "Активных медотводов нет. Вы можете установить новый."
    else:
        text = text_header + "Нажмите на медотвод, чтобы удалить, или установите новый:"

    await callback.message.edit_text(
        text,
        reply_markup=inline.get_admin_waiver_management_keyboard(user_id, waivers),
        parse_mode="Markdown"
    )
    await callback.answer()

@router.callback_query(F.data.startswith("admin_waiver_"), RoleFilter('admin'))
async def set_waiver_start(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    user_id = int(callback.data.split('_')[-1])
    await state.update_data(user_id=user_id)
    await state.set_state(ManualWaiver.awaiting_end_date)
    await callback.message.edit_text("Введите дату окончания медотвода в формате ДД.ММ.ГГГГ:")
    await callback.answer()

@router.message(ManualWaiver.awaiting_end_date)
async def set_waiver_date(message: types.Message, state: FSMContext):
    try:
        end_date = datetime.datetime.strptime(message.text, "%d.%m.%Y").date()
        await state.update_data(end_date=end_date)
        await state.set_state(ManualWaiver.awaiting_reason)
        await message.answer("Введите причину медотвода:")
    except ValueError:
        await message.answer("❌ Неверный формат даты. Введите ДД.ММ.ГГГГ.")

@router.message(ManualWaiver.awaiting_reason)
async def set_waiver_reason(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    reason, user_id, end_date = message.text, data['user_id'], data['end_date']
    
    admin_user = await user_requests.get_user_by_tg_id(session, message.from_user.id)
    user = await user_requests.get_user_by_id(session, user_id)

    await admin_requests.create_manual_waiver(session, user_id, end_date, reason, admin_user.id)
    await session.commit()
    await state.clear()

    await message.answer(f"✅ Медотвод для {user.full_name} установлен до {end_date.strftime('%d.%m.%Y')}.", reply_markup=inline.get_back_to_admin_panel_keyboard())
    try:
        await bot.send_message(user.telegram_id, f"⚕️ Администратор установил вам медотвод до {end_date.strftime('%d.%m.%Y')}.\n*Причина:* {reason}", parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Failed to notify user {user_id} about manual waiver: {e}")

@router.callback_query(F.data.startswith("admin_del_waiver_"), RoleFilter('admin'))
async def admin_delete_waiver(callback: types.CallbackQuery, session: AsyncSession, bot: Bot):
    try:
        _, _, _, waiver_id_str, user_id_str = callback.data.split('_')
        waiver_id, user_id = int(waiver_id_str), int(user_id_str)
    except ValueError:
        await callback.answer("Ошибка в данных. Попробуйте снова.", show_alert=True)
        return

    success = await admin_requests.force_delete_waiver(session, waiver_id)
    if success:
        await session.commit()
        await callback.answer("✅ Медотвод успешно удален.", show_alert=True)
        try:
            user = await user_requests.get_user_by_id(session, user_id)
            if user:
                await bot.send_message(
                    user.telegram_id,
                    "⚙️ Администратор отменил один из ваших медицинских отводов."
                )
        except Exception as e:
            logger.error(f"Failed to notify user {user_id} about admin waiver deletion: {e}")
    else:
        await session.rollback()
        await callback.answer("❌ Не удалось удалить медотвот.", show_alert=True)
    
    await admin_manage_user_waivers_menu(callback, session)


--- КОНЕЦ ФАЙЛА: bot/handlers/admin/user_management.py ---

--- НАЧАЛО ФАЙЛА: bot/handlers/admin/__init__.py ---

from aiogram import Router, F, types
from sqlalchemy.ext.asyncio import AsyncSession

from bot.filters.role import RoleFilter
from bot.db import user_requests
from bot.keyboards import inline

from . import user_management, event_management, merch_management, mailing, system


admin_router = Router(name="admin")


admin_router.include_routers(
    user_management.router,
    event_management.router,
    merch_management.router,
    mailing.router,
    system.router,
)


@admin_router.callback_query(F.data == "admin_panel", RoleFilter('admin'))
async def show_admin_panel(callback: types.CallbackQuery, session: AsyncSession):
    """
    Отображает главную панель администратора.
    Клавиатура динамически подстраивается под роль (admin или main_admin).
    """
    viewer = await user_requests.get_user_by_tg_id(session, callback.from_user.id)
    if not viewer:
        await callback.answer("Ошибка: ваш профиль не найден.", show_alert=True)
        return

    await callback.message.edit_text(
        text="⚙️ *Панель администратора*",
        reply_markup=inline.get_admin_panel_keyboard(viewer.role),
        parse_mode="Markdown"
    )
    await callback.answer()


--- КОНЕЦ ФАЙЛА: bot/handlers/admin/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/keyboards/inline.py ---

from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from bot.db.models import MerchItem

# --- КЛАВИАТУРЫ ---

def get_back_to_main_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_student_menu"))
    return builder.as_markup()

def get_student_main_menu(viewer_role: str = 'student'):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📅 Записаться на донацию", callback_data="register_donation"))
    builder.row(InlineKeyboardButton(text="👤 Мой профиль", callback_data="my_profile"))
    builder.row(InlineKeyboardButton(text="🎁 Магазин мерча", callback_data="merch_store"))
    builder.row(InlineKeyboardButton(text="ℹ️ Полезная информация", callback_data="info"))
    builder.row(InlineKeyboardButton(text="⚕️ Мои медотводы", callback_data="my_waivers"))
    # логика для ролей выше студента
    if viewer_role in ['admin', 'main_admin']:
        # builder.row(InlineKeyboardButton(text="⭐ Перейти в режим волонтера", callback_data="switch_to_volunteer_view"))  # лог
        builder.row(InlineKeyboardButton(
            text="⭐ Перейти в режим волонтера",
            callback_data="switch_to_volunteer_view"
        ))
        # builder.row(InlineKeyboardButton(text="⚙️ Вернуться в админ-панель", callback_data="admin_panel"))  # лог
        builder.row(InlineKeyboardButton(
            text="⚙️ Вернуться в админ-панель",
            callback_data="admin_panel"
        ))
    return builder.as_markup()

def get_volunteer_main_menu():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="⭐ Меню волонтёра", callback_data="volunteer_panel"))
    student_menu = get_student_main_menu().inline_keyboard
    for row in student_menu:
        builder.row(*row)
    return builder.as_markup()

def get_admin_main_menu():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="⚙️ Панель администратора", callback_data="admin_panel"))
    return builder.as_markup()  

def get_main_admin_main_menu():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="⚙️ Открыть панель администратора", callback_data="admin_panel"))
    return builder.as_markup()

def get_faculties_keyboard():
    faculties = ["ИИКС", "ФИБС", "ИнЯз", "ИФТЭБ", "a", "ИФИБ"]
    builder = InlineKeyboardBuilder()
    for faculty in faculties:
        builder.row(InlineKeyboardButton(text=faculty, callback_data=f"faculty_{faculty}"))
    builder.row(InlineKeyboardButton(text="Другой/Не из списка", callback_data="faculty_Other"))
    return builder.as_markup()

def get_blood_type_keyboard():
    builder = InlineKeyboardBuilder()
    types = ["O(I)", "A(II)", "B(III)", "AB(IV)"]
    builder.row(*[InlineKeyboardButton(text=t, callback_data=f"bloodtype_{t}") for t in types])
    return builder.as_markup()

def get_rh_factor_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="Rh+", callback_data="rhfactor_+"), InlineKeyboardButton(text="Rh-", callback_data="rhfactor_-"))
    return builder.as_markup()

def get_profile_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📊 Мои данные", callback_data="profile_data"))
    builder.row(InlineKeyboardButton(text="🩸 История донаций", callback_data="profile_history"))
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_main_menu"))
    return builder.as_markup()

def get_back_to_profile_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ Назад в профиль", callback_data="my_profile"))
    return builder.as_markup()

def get_info_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="Как подготовиться?", callback_data="info_prepare"))
    builder.row(InlineKeyboardButton(text="Противопоказания", callback_data="info_contraindications"))
    builder.row(InlineKeyboardButton(text="Что делать после?", callback_data="info_after"))
    builder.row(InlineKeyboardButton(text="Связаться с организаторами", callback_data="info_contacts"))
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_student_menu"))
    return builder.as_markup()

def get_back_to_info_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ Назад к разделам", callback_data="info"))
    return builder.as_markup()

def get_merch_store_keyboard(item: MerchItem, page: int, total_pages: int):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text=f'Купить за {item.price}Б', callback_data=f"buy_merch_{item.id}"))
    nav_buttons = []
    prev_page = total_pages if page == 1 else page - 1
    nav_buttons.append(InlineKeyboardButton(text="◀️", callback_data=f"merch_page_{prev_page}"))
    nav_buttons.append(InlineKeyboardButton(text=f"{page}/{total_pages}", callback_data="ignore"))
    next_page = 1 if page == total_pages else page + 1
    nav_buttons.append(InlineKeyboardButton(text="▶️", callback_data=f"merch_page_{next_page}"))
    builder.row(*nav_buttons)
    builder.row(InlineKeyboardButton(text="🛍️ Мои заказы", callback_data="my_orders"))
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_student_menu"))
    return builder.as_markup()

def get_purchase_confirmation_keyboard(item_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="✅ Подтвердить", callback_data=f"confirm_buy_{item_id}"),
        InlineKeyboardButton(text="❌ Отмена", callback_data="merch_store")
    )
    return builder.as_markup()

def get_back_to_merch_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ Назад в магазин", callback_data="merch_store"))
    return builder.as_markup()
    
def get_admin_panel_keyboard(viewer_role: str):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="🗓️ Упр. мероприятиями", callback_data="admin_manage_events"))
    builder.row(InlineKeyboardButton(text="👥 Упр. пользователями", callback_data="admin_manage_users"))
    builder.row(InlineKeyboardButton(text="🛍️ Упр. магазином", callback_data="admin_manage_merch"))
    builder.row(InlineKeyboardButton(text="📦 Обработка заказов", callback_data="admin_process_orders"))
    builder.row(InlineKeyboardButton(text="📣 Рассылки", callback_data="admin_mailing"))
    # логика для главного админа
    if viewer_role == 'main_admin':
        # builder.row(InlineKeyboardButton(text="💾 Экспорт данных", callback_data="ma_export_data"))  # лог
        builder.row(InlineKeyboardButton(text="💾 Экспорт данных", callback_data="ma_export_data"))
    builder.row(InlineKeyboardButton(text="👤 Перейти в режим донора", callback_data="switch_to_donor_view"))
    return builder.as_markup()

def get_events_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Создать мероприятие", callback_data="admin_create_event"))
    builder.row(InlineKeyboardButton(text="📜 Просмотр/Редактирование активных", callback_data="admin_view_events"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    return builder.as_markup()

def get_single_event_management_keyboard(event_id: int, registration_is_open: bool):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="✏️ Редактировать", callback_data=f"admin_edit_event_{event_id}"))
    reg_status_text = "🔒 Закрыть регистрацию" if registration_is_open else "🔓 Открыть регистрацию"
    builder.row(InlineKeyboardButton(text=reg_status_text, callback_data=f"admin_toggle_reg_{event_id}"))
    builder.row(InlineKeyboardButton(text="👥 Список участников (.csv)", callback_data=f"admin_event_participants_{event_id}"))
    builder.row(InlineKeyboardButton(text="🚨 Отменить мероприятие", callback_data=f"admin_cancel_event_{event_id}"))
    builder.row(InlineKeyboardButton(text="↩️ К списку мероприятий", callback_data="admin_view_events"))
    return builder.as_markup()

def get_back_to_admin_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ В панель администратора", callback_data="admin_panel"))
    return builder.as_markup()

def get_user_management_keyboard(target_user_id: int, target_user_role: str, viewer_role: str, is_blocked: bool):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="🎟️ Упр. регистрациями", callback_data=f"admin_manage_user_regs_{target_user_id}"))
    builder.row(InlineKeyboardButton(text="⚕️ Упр. медотводами", callback_data=f"admin_manage_waivers_{target_user_id}"))

    builder.row(InlineKeyboardButton(text="+/- Баллы", callback_data=f"admin_points_{target_user_id}"))

    if target_user_role == 'student':
        builder.row(InlineKeyboardButton(text="⭐ Назначить волонтером", callback_data=f"admin_promote_volunteer_{target_user_id}"))
    elif target_user_role == 'volunteer':
        builder.row(InlineKeyboardButton(text="🧑‍🎓 Снять с должности волонтера", callback_data=f"admin_demote_volunteer_{target_user_id}"))
    
    if viewer_role == 'main_admin' and target_user_role != 'main_admin':
        if target_user_role == 'admin':
            builder.row(InlineKeyboardButton(text="👑➖ Разжаловать админа", callback_data=f"ma_demote_admin_{target_user_id}"))
        else:
            builder.row(InlineKeyboardButton(text="👑➕ Назначить админом", callback_data=f"ma_promote_admin_{target_user_id}"))
        if is_blocked:
            builder.row(InlineKeyboardButton(text="✅ Разблокировать", callback_data=f"ma_unblock_user_{target_user_id}"))
        else:
            builder.row(InlineKeyboardButton(text="🚫 Заблокировать", callback_data=f"ma_block_user_{target_user_id}"))
            
    builder.row(InlineKeyboardButton(text="↩️ Назад к управлению", callback_data="admin_manage_users"))
    return builder.as_markup()

def get_donation_type_keyboard():
    builder = InlineKeyboardBuilder()
    types = {'whole_blood': 'Цельная кровь', 'plasma': 'Плазма', 'platelets': 'Тромбоциты', 'erythrocytes': 'Эритроциты'}
    for key, value in types.items():
        builder.row(InlineKeyboardButton(text=value, callback_data=f"settype_{key}"))
    return builder.as_markup()

def get_main_admin_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="👮‍♂️ Управление администраторами", callback_data="ma_manage_admins"))
    builder.row(InlineKeyboardButton(text="🚫 Управление блокировками", callback_data="ma_manage_blocks"))
    builder.row(InlineKeyboardButton(text="💾 Экспорт данных", callback_data="ma_export_data"))
    builder.row(InlineKeyboardButton(text="↩️ В панель администратора", callback_data="admin_panel"))
    return builder.as_markup()
    
def get_back_to_ma_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ В панель гл. администратора", callback_data="main_admin_panel"))
    return builder.as_markup()

def get_admins_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Назначить администратора", callback_data="add_admin"))
    builder.row(InlineKeyboardButton(text="➖ Разжаловать администратора", callback_data="remove_admin"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="main_admin_panel"))
    return builder.as_markup()

def get_blocks_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="🔒 Заблокировать пользователя", callback_data="block_user_start"))
    builder.row(InlineKeyboardButton(text="🔓 Разблокировать пользователя", callback_data="unblock_user_start"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="main_admin_panel"))
    return builder.as_markup()
    
def get_export_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="Выгрузить пользователей (.csv)", callback_data="export_users_csv"))
    builder.row(InlineKeyboardButton(text="Выгрузить донации (.csv)", callback_data="export_donations_csv"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="main_admin_panel"))
    return builder.as_markup()

def get_merch_management_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Добавить товар", callback_data="admin_create_merch"))
    builder.row(InlineKeyboardButton(text="📜 Просмотр/Редактирование", callback_data="admin_view_merch"))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="admin_panel"))
    return builder.as_markup()

def get_event_cancellation_confirmation_keyboard(event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="❌ Да, отменить", callback_data=f"admin_confirm_cancel_{event_id}"),
        InlineKeyboardButton(text="↩️ Нет, назад", callback_data=f"admin_show_event_{event_id}")
    )
    return builder.as_markup()

def get_back_to_events_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ К управлению мероприятиями", callback_data="admin_manage_events"))
    return builder.as_markup()

def get_single_merch_management_keyboard(item_id: int, is_available: bool):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="✏️ Редактировать", callback_data=f"admin_edit_merch_{item_id}"))
    availability_text = "✅ Сделать доступным" if not is_available else "❌ Сделать недоступным"
    builder.row(InlineKeyboardButton(text=availability_text, callback_data=f"admin_toggle_merch_{item_id}"))
    builder.row(InlineKeyboardButton(text="🗑️ Удалить товар", callback_data=f"admin_delete_merch_{item_id}"))
    builder.row(InlineKeyboardButton(text="↩️ К списку товаров", callback_data="admin_view_merch"))
    return builder.as_markup()

def get_merch_deletion_confirmation_keyboard(item_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="🗑️ Да, удалить", callback_data=f"admin_confirm_delete_merch_{item_id}"),
        InlineKeyboardButton(text="↩️ Нет, назад", callback_data=f"admin_show_merch_{item_id}")
    )
    return builder.as_markup()

def get_back_to_merch_menu_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="↩️ К управлению магазином", callback_data="admin_manage_merch"))
    return builder.as_markup()

def get_already_registered_keyboard(event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(
        text="❌ Отменить мою регистрацию",
        callback_data=f"cancel_reg_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="↩️ К списку мероприятий",
        callback_data="register_donation"
    ))
    return builder.as_markup()

def get_event_creation_confirmation_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="✅ Создать и разослать", callback_data="confirm_create_event"))
    builder.row(InlineKeyboardButton(text="❌ Отмена", callback_data="admin_manage_events"))
    return builder.as_markup()

def get_mailing_audience_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📢 Всем пользователям", callback_data="mail_audience_all"))
    builder.row(InlineKeyboardButton(text="🩸 Только донорам (кто может сдавать)", callback_data="mail_audience_can_donate"))
    builder.row(InlineKeyboardButton(text="⭐ Только волонтерам", callback_data="mail_audience_volunteers"))
    builder.row(InlineKeyboardButton(text="⚙️ Только администраторам", callback_data="mail_audience_admins"))
    builder.row(InlineKeyboardButton(text="❌ Отмена", callback_data="admin_panel"))
    return builder.as_markup()

def get_mailing_confirmation_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="🚀 Да, запустить рассылку", callback_data="confirm_mailing"),
        InlineKeyboardButton(text="✏️ Изменить текст", callback_data="edit_mailing_text"),
        InlineKeyboardButton(text="❌ Отмена", callback_data="admin_panel")
    )
    return builder.as_markup()

def get_skip_media_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➡️ Пропустить", callback_data="skip_media"))
    builder.row(InlineKeyboardButton(text="❌ Отмена", callback_data="admin_panel"))
    return builder.as_markup()

def get_user_management_main_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📜 Список всех пользователей", callback_data="admin_users_list_page_1"))
    builder.row(InlineKeyboardButton(text="🔍 Найти пользователя", callback_data="admin_search_user"))
    builder.row(InlineKeyboardButton(text="↩️ Назад в админ-панель", callback_data="admin_panel"))
    return builder.as_markup()

def get_users_list_pagination_keyboard(page: int, total_pages: int):
    builder = InlineKeyboardBuilder()
    nav_buttons = []
    if page > 1:
        nav_buttons.append(InlineKeyboardButton(text="◀️", callback_data=f"admin_users_list_page_{page - 1}"))
    nav_buttons.append(InlineKeyboardButton(text=f"{page}/{total_pages}", callback_data="ignore"))
    if page < total_pages:
        nav_buttons.append(InlineKeyboardButton(text="▶️", callback_data=f"admin_users_list_page_{page + 1}"))
    builder.row(*nav_buttons)
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="admin_manage_users"))
    return builder.as_markup()

def get_successful_registration_keyboard(event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(
        text="🔲 Мой QR-код для этого мероприятия",
        callback_data=f"get_event_qr_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="❌ Отменить мою регистрацию",
        callback_data=f"cancel_reg_{event_id}"
    ))
    builder.row(InlineKeyboardButton(
        text="↩️ К списку мероприятий",
        callback_data="register_donation"
    ))
    return builder.as_markup()

def get_donation_confirmation_keyboard(user_id: int, event_id: int):
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(
            text="✅ Подтвердить",
            callback_data=f"confirm_donation_{user_id}_{event_id}"
        ),
        InlineKeyboardButton(
            text="❌ Отмена",
            callback_data="volunteer_panel"
        )
    )
    return builder.as_markup()

def get_volunteer_panel_keyboard():
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="📷 Подтвердить донацию (QR)", callback_data="confirm_donation_qr"))
    builder.row(InlineKeyboardButton(text="↩️ Назад в меню донора", callback_data="switch_to_donor_view"))
    return builder.as_markup()

def get_manual_registration_management_keyboard(user_id: int):
    """Клавиатура для выбора: записать или отменить запись."""
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Записать на мероприятие", callback_data=f"admin_reg_start_{user_id}"))
    builder.row(InlineKeyboardButton(text="➖ Отменить регистрацию", callback_data=f"admin_cancel_start_{user_id}"))
    builder.row(InlineKeyboardButton(text="↩️ Назад к пользователю", callback_data=f"admin_show_user_{user_id}"))
    return builder.as_markup()

def get_events_for_manual_registration_keyboard(user_id: int, events: list):
    """Клавиатура со списком мероприятий для ручной записи."""
    builder = InlineKeyboardBuilder()
    for event in events:
        builder.row(InlineKeyboardButton(
            text=f"{event.event_date.strftime('%d.%m')} - {event.name}",
            # --- ИЗМЕНЕНИЕ ---
            callback_data=f"adminReg_{user_id}_{event.id}" 
            # -----------------
        ))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data=f"admin_manage_user_regs_{user_id}"))
    return builder.as_markup()

def get_registrations_for_cancellation_keyboard(user_id: int, registrations: list):
    """Клавиатура со списком регистраций для отмены."""
    builder = InlineKeyboardBuilder()
    for reg in registrations:
        builder.row(InlineKeyboardButton(
            text=f"❌ {reg.event.event_date.strftime('%d.%m')} - {reg.event.name}",
            # --- ИЗМЕНЕНИЕ ---
            callback_data=f"adminCancel_{user_id}_{reg.event_id}"
            # -----------------
        ))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data=f"admin_manage_user_regs_{user_id}"))
    return builder.as_markup()



def get_my_waivers_keyboard(user_waivers_exist: bool):
    """
    Клавиатура для меню 'Мои медотводы'.
    Показывает кнопку удаления, только если у пользователя есть созданные им отводы.
    """
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="➕ Установить временный отвод", callback_data="set_user_waiver"))
    if user_waivers_exist:
        builder.row(InlineKeyboardButton(text="➖ Отменить свой отвод", callback_data="cancel_user_waiver"))
    builder.row(InlineKeyboardButton(text="↩️ В главное меню", callback_data="back_to_student_menu"))
    return builder.as_markup()

def get_waiver_cancellation_keyboard(waivers: list):
    """Клавиатура со списком медотводов, созданных пользователем, для отмены."""
    builder = InlineKeyboardBuilder()
    for waiver in waivers:
        builder.row(InlineKeyboardButton(
            text=f"❌ До {waiver.end_date.strftime('%d.%m.%y')}: {waiver.reason[:25]}...",
            callback_data=f"delete_waiver_{waiver.id}"
        ))
    builder.row(InlineKeyboardButton(text="↩️ Назад", callback_data="my_waivers"))
    return builder.as_markup()

def get_admin_waiver_management_keyboard(user_id: int, waivers: list):
    """Клавиатура для админа со списком медотводов пользователя для удаления."""
    builder = InlineKeyboardBuilder()
    for waiver in waivers:
        creator_map = {'user': '👤', 'system': '⚙️', 'admin': '👑'}
        creator_icon = creator_map.get(str(waiver.created_by).lower(), '❓')
        
        # Если создатель - админ, и это число, то используем иконку админа
        if str(waiver.created_by).isdigit():
            creator_icon = '👑'

        reason_short = (waiver.reason[:20] + '...') if len(waiver.reason) > 20 else waiver.reason
        
        builder.row(InlineKeyboardButton(
            text=f"❌ {creator_icon} До {waiver.end_date.strftime('%d.%m')} - {reason_short}",
            callback_data=f"admin_del_waiver_{waiver.id}_{user_id}" # Добавляем user_id для возврата
        ))
        
    builder.row(InlineKeyboardButton(text="➕ Установить новый медотвод", callback_data=f"admin_waiver_{user_id}"))
    builder.row(InlineKeyboardButton(text="↩️ Назад к пользователю", callback_data=f"admin_show_user_{user_id}"))
    return builder.as_markup()


--- КОНЕЦ ФАЙЛА: bot/keyboards/inline.py ---

--- НАЧАЛО ФАЙЛА: bot/keyboards/reply.py ---

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

def get_contact_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="Поделиться контактом", request_contact=True)]],
        resize_keyboard=True
    )
    
def get_gender_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="Мужской"), KeyboardButton(text="Женский")]
        ],
        resize_keyboard=True,
        one_time_keyboard=True
    )

--- КОНЕЦ ФАЙЛА: bot/keyboards/reply.py ---

--- НАЧАЛО ФАЙЛА: bot/keyboards/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/keyboards/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/middlewares/block.py ---

from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, Message, CallbackQuery
from sqlalchemy.ext.asyncio import AsyncSession
from bot.db import user_requests

class BlockUserMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        if not isinstance(event, (Message, CallbackQuery)):
            return await handler(event, data)

        session: AsyncSession = data.get("session")
        if not session:
            return await handler(event, data)

        user = await user_requests.get_user_by_tg_id(session, event.from_user.id)
        
        if user and user.is_blocked:
            if isinstance(event, Message):
                await event.answer("❌ Вы заблокированы и не можете использовать этого бота.")
            elif isinstance(event, CallbackQuery):
                await event.answer("❌ Вы заблокированы.", show_alert=True)
            return
        
        return await handler(event, data)

--- КОНЕЦ ФАЙЛА: bot/middlewares/block.py ---

--- НАЧАЛО ФАЙЛА: bot/middlewares/db.py ---

from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from sqlalchemy.ext.asyncio import async_sessionmaker

class DbSessionMiddleware(BaseMiddleware):
    def __init__(self, session_pool: async_sessionmaker):
        super().__init__()
        self.session_pool = session_pool

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        async with self.session_pool() as session:
            data["session"] = session
            return await handler(event, data)

--- КОНЕЦ ФАЙЛА: bot/middlewares/db.py ---

--- НАЧАЛО ФАЙЛА: bot/middlewares/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/middlewares/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/states/states.py ---

from aiogram.fsm.state import State, StatesGroup

class Registration(StatesGroup):
    awaiting_full_name = State()
    awaiting_faculty = State()
    awaiting_study_group = State()
    awaiting_blood_type = State()
    awaiting_rh_factor = State()
    awaiting_gender = State()

class EventCreation(StatesGroup):
    awaiting_name = State()
    awaiting_date = State()
    awaiting_location = State()
    awaiting_donation_type = State()
    awaiting_points = State()
    awaiting_bonus_points = State()
    awaiting_limit = State()

class MerchCreation(StatesGroup):
    awaiting_photo = State()
    awaiting_name = State()
    awaiting_description = State()
    awaiting_price = State()

class PointsChange(StatesGroup):
    awaiting_user_id = State()
    awaiting_points_amount = State()
    awaiting_reason = State()

class ManualWaiver(StatesGroup):
    awaiting_end_date = State()
    awaiting_reason = State()

class Mailing(StatesGroup):
    awaiting_message = State()
    awaiting_audience = State()
    
class AdminManagement(StatesGroup):
    awaiting_user_to_promote = State()
    awaiting_user_to_demote = State()
    
class BlockUser(StatesGroup):
    awaiting_user_id = State()
    awaiting_reason = State()
    awaiting_user_id_unblock = State()

class VolunteerActions(StatesGroup):
    awaiting_qr_photo = State()
    awaiting_confirmation = State()
    
class EventEditing(StatesGroup):
    choosing_field = State() 
    awaiting_new_value = State()
    
class MerchEditing(StatesGroup):
    choosing_field = State()
    awaiting_new_value = State()
    
class EventCreation(StatesGroup):
    awaiting_name = State()
    awaiting_date = State()
    awaiting_location = State()
    awaiting_donation_type = State()
    awaiting_points = State()
    awaiting_bonus_points = State()
    awaiting_limit = State()
    awaiting_confirmation = State()
    
class Mailing(StatesGroup):
    awaiting_message_text = State()
    awaiting_media = State()
    awaiting_audience_choice = State()
    awaiting_confirmation = State()
    
class UserSearch(StatesGroup):
    awaiting_query = State()
    
    
class UserWaiver(StatesGroup):
    awaiting_end_date = State()
    awaiting_reason = State()


--- КОНЕЦ ФАЙЛА: bot/states/states.py ---

--- НАЧАЛО ФАЙЛА: bot/states/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/states/__init__.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/qr_service.py ---

import io
import hashlib
import qrcode
import json
import logging
from PIL import Image
from pyzbar.pyzbar import decode, ZBarSymbol

from bot.config_reader import config

logger = logging.getLogger(__name__)

def create_secure_payload(data: dict) -> str:
    # Формирует строку для QR-кода
    json_string = json.dumps(data, sort_keys=True, separators=(',', ':'))
    salt = config.qr_secret_key.get_secret_value()
    string_to_hash = json_string + salt
    # logger.info(f"[CREATE] String to be hashed: '{string_to_hash}'")
    h = hashlib.sha256(string_to_hash.encode()).hexdigest()
    # logger.info(f"[CREATE] Generated hash: {h}")
    return f"{json_string}|{h}"

def verify_secure_payload(payload: str) -> dict | None:
    # Проверяет строку и возвращает данные
    try:
        json_string, received_hash = payload.split('|', 1)
        salt = config.qr_secret_key.get_secret_value()
        string_to_hash = json_string + salt
        # logger.info(f"[VERIFY] String to be hashed: '{string_to_hash}'")
        expected_hash = hashlib.sha256(string_to_hash.encode()).hexdigest()
        # logger.info(f"[VERIFY] Received hash:  {received_hash}")
        # logger.info(f"[VERIFY] Expected hash:  {expected_hash}")
        if received_hash == expected_hash:
            # logger.info("[VERIFY] Hashes MATCH. Verification successful.")
            return json.loads(json_string)
        else:
            # logger.error("[VERIFY] Hashes DO NOT MATCH. Verification failed.")
            return None
    except (ValueError, IndexError, json.JSONDecodeError) as e:
        # logger.error(f"[VERIFY] An exception occurred during verification: {e}")
        return None

async def generate_qr(data: dict) -> bytes:
    # Генерирует QR-код
    # logger.info(f"--- Generating QR for data: {data} ---")
    payload = create_secure_payload(data)
    img = qrcode.make(payload)
    buf = io.BytesIO()
    img.save(buf, 'PNG')
    buf.seek(0)
    return buf.read()

async def read_qr(photo_bytes: bytes) -> dict | None:
    # Читает QR-код и возвращает данные
    try:
        image = Image.open(io.BytesIO(photo_bytes)).convert('L')
        decoded_objects = decode(image, symbols=[ZBarSymbol.QRCODE])
        if not decoded_objects:
            # logger.warning("pyzbar failed to find any QR codes on the image.")
            return None
        payload = decoded_objects[0].data.decode('utf-8')
        # logger.info(f"--- Verifying QR with payload: '{payload}' ---")
        verified_data = verify_secure_payload(payload)
        return verified_data
    except Exception as e:
        # logger.error(f"An exception occurred in read_qr: {e}", exc_info=True)
        return None


--- КОНЕЦ ФАЙЛА: bot/utils/qr_service.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/scheduler.py ---

import logging
import datetime
from aiogram import Bot
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy import select
from bot.db.models import EventRegistration, MedicalWaiver, Event, User

logger = logging.getLogger(__name__)

async def send_event_reminders(bot: Bot, session_pool: async_sessionmaker):
    # Напоминания о мероприятиях
    # logger.info("Running job: send_event_reminders")
    reminder_date = datetime.date.today() + datetime.timedelta(days=2)
    async with session_pool() as session:
        stmt = (
            select(EventRegistration)
            .join(EventRegistration.user)
            .join(EventRegistration.event)
            .where(
                Event.event_date == reminder_date,
                EventRegistration.status == 'registered'
            )
        )
        results = await session.execute(stmt)
        registrations = results.scalars().all()
        if not registrations:
            # logger.info("No event reminders to send today.")
            return
        # logger.info(f"Found {len(registrations)} users to remind.")
        success_count = 0
        for reg in registrations:
            try:
                user: User = reg.user
                event: Event = reg.event
                text = (
                    f"👋 Напоминание о донации!\n\n"
                    f"Вы записаны на мероприятие «*{event.name}*»,"
                    f" которое состоится послезавтра, *{event.event_date.strftime('%d.%m.%Y')}*.\n\n"
                    f"📍 *Место:* {event.location}\n\n"
                    f"Пожалуйста, не забудьте паспорт и хорошо выспитесь. Спасибо, что помогаете!"
                )
                await bot.send_message(chat_id=user.telegram_id, text=text, parse_mode="Markdown")
                success_count += 1
            except Exception as e:
                # logger.error(f"Failed to send reminder to user {reg.user_id} for event {reg.event_id}. Error: {e}")
                pass
        # logger.info(f"Successfully sent {success_count}/{len(registrations)} reminders.")

async def check_waiver_expirations(bot: Bot, session_pool: async_sessionmaker):
    # Проверка истечения медотводов
    # logger.info("Running job: check_waiver_expirations")
    yesterday = datetime.date.today() - datetime.timedelta(days=1)
    async with session_pool() as session:
        stmt = (
            select(MedicalWaiver.user_id)
            .where(MedicalWaiver.end_date == yesterday)
        )
        results = await session.execute(stmt)
        user_ids_to_notify = results.scalars().unique().all()
        if not user_ids_to_notify:
            # logger.info("No waiver expirations to notify about today.")
            return
        # logger.info(f"Found {len(user_ids_to_notify)} users whose waivers expired.")
        users_stmt = select(User).where(User.id.in_(user_ids_to_notify))
        users_result = await session.execute(users_stmt)
        users = users_result.scalars().all()
        success_count = 0
        for user in users:
            try:
                text = "🎉 Отличные новости! Срок вашего медицинского отвода истёк. Вы снова можете спасать жизни, участвуя в донациях! 💪"
                await bot.send_message(chat_id=user.telegram_id, text=text)
                success_count += 1
            except Exception as e:
                # logger.error(f"Failed to send waiver expiration notification to user {user.id}. Error: {e}")
                pass
        # logger.info(f"Successfully sent {success_count}/{len(users)} waiver expiration notifications.")

def setup_scheduler(bot: Bot, session_pool: async_sessionmaker) -> AsyncIOScheduler:
    # Настройка планировщика
    scheduler = AsyncIOScheduler(timezone="Europe/Moscow")
    scheduler.add_job(
        send_event_reminders,
        trigger='cron',
        hour=10,
        minute=0,
        args=[bot, session_pool]
    )
    scheduler.add_job(
        check_waiver_expirations,
        trigger='cron',
        hour=9,
        minute=0,
        args=[bot, session_pool]
    )
    # logger.info("Scheduler configured successfully with 2 jobs.")
    return scheduler


--- КОНЕЦ ФАЙЛА: bot/utils/scheduler.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/text_messages.py ---

class Text:
    WELCOME = "👋 Добро пожаловать в бот донорского движения МИФИ!\n\nДля начала работы, пожалуйста, поделитесь своим контактом. Это необходимо для вашей идентификации в системе доноров."
    AUTH_SUCCESS = "✅ Авторизация прошла успешно! С возвращением, {name}!"
    START_REGISTRATION = "🔍 Похоже, вы у нас впервые. Давайте познакомимся!"
    
    GET_FULL_NAME = "📝 Введите, пожалуйста, ваше ФИО (например, Иванов Иван Иванович):"
    GET_FACULTY = "🏛️ Выберите ваш факультет:"
    GET_GROUP = "🔢 Введите номер вашей учебной группы (например, Б20-505):"
    GET_BLOOD_TYPE = "🩸 Укажите вашу группу крови:"
    GET_RH_FACTOR = "➕ Укажите ваш резус-фактор:"
    GET_GENDER = "🚻 Укажите ваш пол:"
    
    REGISTRATION_COMPLETE = "🎉 Отлично! Регистрация завершена. Теперь вы можете пользоваться всеми возможностями бота."
    ERROR_WRONG_FORMAT = "❌ Неверный формат. Пожалуйста, попробуйте еще раз."

    # --- Полезная информация ---
    INFO_PREPARE = (
        "<b>Как подготовиться к сдаче крови:</b>\n\n"
        "<b>Накануне и в день сдачи крови запрещено:</b>\n"
        "▪️ Употреблять жирную, жареную, острую и копченую пищу, колбасные изделия, а также мясные, рыбные и молочные продукты, яйца и масло (в т.ч. растительное), шоколад, орехи и финики.\n"
        "▪️ Принимать алкоголь за 48 часов до донации.\n"
        "▪️ Принимать лекарства, содержащие аспирин и анальгетики, за 72 часа до донации.\n\n"
        "<b>Что нужно делать:</b>\n"
        "▪️ Хорошо выспаться.\n"
        "▪️ Легко позавтракать (сладкий чай, сухое печенье, каша на воде).\n"
        "▪️ Не курить за час до донации.\n"
        "▪️ Не приходить на донацию при недомогании."
    )
    INFO_CONTRAINDICATIONS = (
        "<b>Абсолютные противопоказания (отвод от донорства навсегда):</b>\n\n"
        "▪️ ВИЧ-инфекция, сифилис, вирусные гепатиты.\n"
        "▪️ Туберкулез (все формы).\n"
        "▪️ Болезни крови.\n"
        "▪️ Онкологические заболевания.\n"
        "▪️ Наркомания, алкоголизм.\n\n"
        "<b>Временные противопоказания:</b>\n"
        "▪️ Удаление зуба (10 дней).\n"
        "▪️ Нанесение татуировки, пирсинг (1 год).\n"
        "▪️ Ангина, грипп, ОРВИ (1 месяц после выздоровления).\n"
        "▪️ Прививки (от 10 дней до 1 года)."
    )
    INFO_AFTER = (
        "<b>Что делать после донации:</b>\n\n"
        "▪️ Отдохните 10–15 минут.\n"
        "▪️ Не снимайте повязку 3–4 часа.\n"
        "▪️ Не подвергайтесь физическим нагрузкам в течение дня.\n"
        "▪️ Воздержитесь от употребления алкоголя в течение суток.\n"
        "▪️ Пейте больше жидкости и полноценно питайтесь в течение двух суток."
    )
    INFO_CONTACTS = (
        "<b>Связаться с организаторами:</b>\n\n"
        "Если у вас возникли вопросы, вы можете связаться с нами:\n"
        "▪️ Телеграм-чат для доноров: [ссылка на чат]\n"
        "▪️ Ответственный за донорское движение: [Александр, @Alkzaz7]"
    )
    NEW_EVENT_NOTIFICATION = (
        "🎉 *Анонс нового донорского мероприятия!*\n\n"
        "Открыта запись на: *{event_name}*\n"
        "🗓️ *Когда:* {event_date}\n"
        "📍 *Где:* {event_location}\n\n"
        "Вы можете принять участие! Записаться можно прямо сейчас через главное меню бота. "
        "Ваша помощь очень важна!"
    )

--- КОНЕЦ ФАЙЛА: bot/utils/text_messages.py ---

--- НАЧАЛО ФАЙЛА: bot/utils/__init__.py ---



--- КОНЕЦ ФАЙЛА: bot/utils/__init__.py ---

